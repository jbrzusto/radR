# This is an automatically generated file by the R module for SWIG.

##   Generated via the command line invocation:
##	 /usr/src/swig-1.3.33/swig -DLINUX -D__GNUC__=4 -r -I/usr/include -I/usr/include/linux -importall iris.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = RSWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################


setClass('_p_ymds_time', contains = 'ExternalReference')
setClass("ymds_time",
    representation(
        isec = "numeric"),
        contains = "RSWIGStruct")


# End class ymds_time

setClass('_p_color_scale_def', contains = 'ExternalReference')
setClass("color_scale_def",
    representation(
        iflags = "numeric",
        istart = "numeric",
        istep = "numeric"),
        contains = "RSWIGStruct")


# End class color_scale_def

setClass('_p_structure_header', contains = 'ExternalReference')
setClass("structure_header",
    representation(
        ibytes = "numeric"),
        contains = "RSWIGStruct")


# End class structure_header

setClass('_p_beam_psi_struct', contains = 'ExternalReference')
setClass("beam_psi_struct",
    representation(
        irmin = "numeric",
        irmax = "numeric",
        iaz_left = "numeric",
        iaz_right = "numeric",
        iel_low = "numeric",
        iel_high = "numeric",
        iaz_smooth = "numeric",
        iel_smooth = "numeric",
        iaz_sun_start = "numeric",
        iel_sun_start = "numeric",
        iaz_sun_end = "numeric",
        iel_sun_end = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class beam_psi_struct

setClass('_p_cappi_psi_struct', contains = 'ExternalReference')
setClass("cappi_psi_struct",
    representation(
        iShearFlags = "numeric",
        icappi_hgt = "numeric",
        svvp_name = "character",
        ivvp_max_age = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class cappi_psi_struct

setClass('_p_catch_psi_struct', contains = 'ExternalReference')
setClass("catch_psi_struct",
    representation(
        iFlags = "numeric",
        iHours = "numeric",
        iThresholdOffset = "numeric",
        iThresholdFactor = "numeric",
        sProduct = "character",
        sSubCatchment = "character",
        iSpanSeconds = "numeric",
        iRain1MinZ = "numeric",
        iRain1Span = "numeric",
        iGageFactor = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class catch_psi_struct

setClass('_p_comp_psi_struct', contains = 'ExternalReference')
setClass("comp_psi_struct",
    representation(
        sPNameIn = "character",
        sSiteOut = "character",
        sSiteInList = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class comp_psi_struct

setClass('_p_cross_psi_struct', contains = 'ExternalReference')
setClass("cross_psi_struct",
    representation(
        ipad2x10 = "character",
        icenterx = "numeric",
        icentery = "numeric",
        ivuser_misc = "numeric"),
        contains = "RSWIGStruct")


# End class cross_psi_struct

setClass('_p_dwell_target_psi', contains = 'ExternalReference')
setClass("dwell_target_psi",
    representation(
        iProtectMask = "numeric",
        sWarnSymbol = "character",
        ipad27x1 = "character",
        iFlags2 = "numeric",
        iAreaMax = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class dwell_target_psi

setClass('_p_dwell_warn_psi', contains = 'ExternalReference')
setClass("dwell_warn_psi",
    representation(
        sWarnSuffix1 = "character",
        sWarnSuffix2 = "character",
        iWarnAge2 = "numeric",
        ipad12x16 = "character",
        iFlags2 = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class dwell_warn_psi

setClass('_p_dwell_psi_union', contains = 'ExternalReference')
setClass('_p_dwell_psi_struct', contains = 'ExternalReference')
setClass("dwell_psi_struct",
    representation(
        iDataMin = "numeric",
        iDataMax = "numeric",
        sPNameIn = "character"),
        contains = "RSWIGStruct")


# End class dwell_psi_struct

setClass('_p_fcast_psi_struct', contains = 'ExternalReference')
setClass("fcast_psi_struct",
    representation(
        iCorrThreshold = "numeric",
        iDataThreshold = "numeric",
        iMeanSpeed = "numeric",
        iMeanDirection = "numeric",
        imax_time_step = "numeric",
        imax_velocity = "numeric",
        iflags = "numeric",
        iOutputResolution = "numeric",
        iptype = "numeric",
        spname = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class fcast_psi_struct

setClass('_p_gage_psi_struct', contains = 'ExternalReference')
setClass("gage_psi_struct",
    representation(
        iSpan = "numeric",
        iFlag = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class gage_psi_struct

setClass('_p_maximum_psi_struct', contains = 'ExternalReference')
setClass("maximum_psi_struct",
    representation(
        ipad0x4 = "character",
        ibottom = "numeric",
        itop = "numeric",
        iside_size = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class maximum_psi_struct

setClass('_p_ndop_input', contains = 'ExternalReference')
setClass("ndop_input",
    representation(
        sTName = "character",
        sSiteId = "character"),
        contains = "RSWIGStruct")


# End class ndop_input

setClass('_p_ndop_psi_struct', contains = 'ExternalReference')
setClass("ndop_psi_struct",
    representation(
        iTimeWindow = "numeric",
        iCappiHeight = "numeric",
        iOutputResolution = "numeric",
        iMinCrossingAngle = "numeric",
        iFlags = "numeric",
        sSiteOut = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class ndop_psi_struct

setClass('_p_ppi_psi_struct', contains = 'ExternalReference')
setClass("ppi_psi_struct",
    representation(
        ipad2x2 = "character",
        iMaxRange = "numeric",
        iMaxHeight = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class ppi_psi_struct

setClass('_p_rain_psi_struct', contains = 'ExternalReference')
setClass("rain_psi_struct",
    representation(
        irain1_minz = "numeric",
        sproduct = "character",
        iRain1Span = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class rain_psi_struct

setClass('_p_raw_psi_struct', contains = 'ExternalReference')
setClass("raw_psi_struct",
    representation(
        iDataMask0 = "numeric",
        iraw_bin_last = "numeric",
        iraw_convert = "numeric",
        iflags = "numeric",
        isweep = "numeric",
        iXhdrType = "numeric",
        iDataMask1 = "numeric",
        iDataMask2 = "numeric",
        iDataMask3 = "numeric",
        iDataMask4 = "numeric",
        iPlayback = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class raw_psi_struct

setClass('_p_rhi_psi_struct', contains = 'ExternalReference')
setClass("rhi_psi_struct",
    representation(
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class rhi_psi_struct

setClass('_p_rti_psi_struct', contains = 'ExternalReference')
setClass("rti_psi_struct",
    representation(
        iSweepAngle = "numeric",
        iStartOffset = "numeric",
        iEndOffset = "numeric",
        iStartAzimuth = "numeric",
        iStartElevation = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class rti_psi_struct

setClass('_p_shear_psi_struct', contains = 'ExternalReference')
setClass("shear_psi_struct",
    representation(
        iaz_smooth = "numeric",
        ipad6x2 = "character",
        iflags = "numeric",
        svvp_name = "character",
        ivvp_max_age = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class shear_psi_struct

setClass('_p_sline_psi_struct', contains = 'ExternalReference')
setClass("sline_psi_struct",
    representation(
        iarea = "numeric",
        ishear_threshold = "numeric",
        iprotect_mask = "numeric",
        iforecast_time = "numeric",
        imax_time_step = "numeric",
        imax_velocity = "numeric",
        iflags = "numeric",
        iaz_smooth = "numeric",
        iel1 = "numeric",
        iel2 = "numeric",
        svvp_name = "character",
        ivvp_max_age = "numeric",
        ifit_threshold = "numeric",
        iMaxs = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class sline_psi_struct

setClass('_p_sri_psi_struct', contains = 'ExternalReference')
setClass("sri_psi_struct",
    representation(
        iPsiFlags = "numeric",
        iBinCount = "numeric",
        iDataCount = "numeric",
        iCorrCount = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class sri_psi_struct

setClass('_p_tdwr_psi_struct', contains = 'ExternalReference')
setClass("tdwr_psi_struct",
    representation(
        iFlags = "numeric",
        iRMax = "numeric",
        sSourceID = "character",
        sCFDirection = "character",
        sCFSpeed = "character",
        sCFGustSpeed = "character",
        iprotect_mask = "numeric",
        iCentroidCount = "numeric",
        iSlineCount = "numeric",
        iForecastTime = "numeric"),
        contains = "RSWIGStruct")


# End class tdwr_psi_struct

setClass('_p_top_psi_struct', contains = 'ExternalReference')
setClass("top_psi_struct",
    representation(
        ipad0x4 = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class top_psi_struct

setClass('_p_track_psi_struct', contains = 'ExternalReference')
setClass("track_psi_struct",
    representation(
        iarea = "numeric",
        ithreshold = "numeric",
        iprotect_mask = "numeric",
        iforecast_time = "numeric",
        imax_time_step = "numeric",
        imax_velocity = "numeric",
        iflags = "numeric",
        ispan_time = "numeric",
        iptype = "numeric",
        spname = "character",
        iconnect_error = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class track_psi_struct

setClass('_p_user_psi_struct', contains = 'ExternalReference')
setClass("user_psi_struct",
    representation(
        imisc = "numeric"),
        contains = "RSWIGStruct")


# End class user_psi_struct

setClass('_p_vil_psi_struct', contains = 'ExternalReference')
setClass("vil_psi_struct",
    representation(
        ipad0x4 = "character",
        ivil_bottom = "numeric",
        ivil_top = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class vil_psi_struct

setClass('_p_vvp_psi_struct', contains = 'ExternalReference')
setClass("vvp_psi_struct",
    representation(
        ivvp_rmin = "numeric",
        ivvp_rmax = "numeric",
        ivvp_hmin = "numeric",
        ivvp_hmax = "numeric",
        ipad18x2 = "character",
        ivvp_quota = "numeric",
        ivvp_switch = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class vvp_psi_struct

setClass('_p_warn_psi_struct', contains = 'ExternalReference')
setClass("warn_psi_struct",
    representation(
        iwarn_area = "numeric",
        iwarn_threshs = "numeric",
        ipad22x2 = "character",
        swarn_symbol = "character",
        swarn_names = "character",
        iprotect_mask = "numeric"),
        contains = "RSWIGStruct")


# End class warn_psi_struct

setClass('_p_wind_psi_struct', contains = 'ExternalReference')
setClass("wind_psi_struct",
    representation(
        ihmin = "numeric",
        ihmax = "numeric",
        irmin = "numeric",
        irmax = "numeric",
        irange_count = "numeric",
        iazimuth_count = "numeric",
        isector_length = "numeric",
        isector_width = "numeric",
        iflags = "numeric",
        ivvp_switch = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class wind_psi_struct

setClass('_p_product_specific_info', contains = 'ExternalReference')
setClass('_p_product_configuration', contains = 'ExternalReference')
setClass("product_configuration",
    representation(
        isch_skip = "numeric",
        ipad56x6 = "character",
        spname = "character",
        stname = "character",
        ixscale = "numeric",
        iyscale = "numeric",
        izscale = "numeric",
        ixsize = "numeric",
        iysize = "numeric",
        izsize = "numeric",
        ixrad = "numeric",
        iyrad = "numeric",
        izrad = "numeric",
        irange_last_v20 = "numeric",
        ipad128x2 = "character",
        sprojection_name = "character",
        ipad147x1 = "character",
        izr_const = "numeric",
        izr_exp = "numeric",
        sTaskMinorList = "character",
        ipad260x12 = "character"),
        contains = "RSWIGStruct")


# End class product_configuration

setClass('_p_product_configuration', contains = 'ExternalReference')
setClass('_p_task_rhi_scan_info', contains = 'ExternalReference')
setClass("task_rhi_scan_info",
    representation(
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_rhi_scan_info

setClass('_p_serv_task_rhi_scan_info', contains = 'ExternalReference')
setClass("serv_task_rhi_scan_info",
    representation(
        istartel = "numeric",
        iendel = "numeric",
        iazlst = "numeric",
        iStartEnd = "numeric"),
        contains = "RSWIGStruct")


# End class serv_task_rhi_scan_info

setClass('_p_task_ppi_scan_info', contains = 'ExternalReference')
setClass("task_ppi_scan_info",
    representation(
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_ppi_scan_info

setClass('_p_serv_task_ppi_scan_info', contains = 'ExternalReference')
setClass("serv_task_ppi_scan_info",
    representation(
        istartaz = "numeric",
        iendaz = "numeric",
        iellst = "numeric",
        iStartEnd = "numeric"),
        contains = "RSWIGStruct")


# End class serv_task_ppi_scan_info

setClass('_p_task_file_scan_info', contains = 'ExternalReference')
setClass("task_file_scan_info",
    representation(
        scan_file = "character",
        ipad = "character"),
        contains = "RSWIGStruct")


# End class task_file_scan_info

setClass('_p_task_manual_scan_info', contains = 'ExternalReference')
setClass("task_manual_scan_info",
    representation(
        ipad2x2 = "character",
        iStartAz = "numeric",
        iStartEl = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_manual_scan_info

setClass('_p_task_exec_scan_info', contains = 'ExternalReference')
setClass("task_exec_scan_info",
    representation(
        sCommand = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_exec_scan_info

setClass('_p_serv_task_file_scan_info', contains = 'ExternalReference')
setClass("serv_task_file_scan_info",
    representation(
        ifirstaz = "numeric",
        ifirstel = "numeric",
        scan_file = "character"),
        contains = "RSWIGStruct")


# End class serv_task_file_scan_info

setClass('_p_serv_task_manual_scan_info', contains = 'ExternalReference')
setClass("serv_task_manual_scan_info",
    representation(
        iman_flags = "numeric",
        iStartAz = "numeric",
        iStartEl = "numeric"),
        contains = "RSWIGStruct")


# End class serv_task_manual_scan_info

setClass('_p_task_scan_info_u', contains = 'ExternalReference')
setClass('_p_task_range_info', contains = 'ExternalReference')
setClass("task_range_info",
    representation(
        ibin_first = "numeric",
        ibin_last = "numeric",
        ibin_in_step = "numeric",
        ibin_out_step = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_range_info

setClass('_p_task_scan_info', contains = 'ExternalReference')
setClass("task_scan_info",
    representation(
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_scan_info

setClass('_p_serv_task_scan_info_u', contains = 'ExternalReference')
setClass('_p_serv_task_scan_info', contains = 'ExternalReference')
setClass("serv_task_scan_info",
    representation(
        iscan = "numeric",
        ires1000 = "numeric",
        iscan_speed = "numeric",
        isweeps = "numeric"),
        contains = "RSWIGStruct")


# End class serv_task_scan_info

setClass('_p_product_end', contains = 'ExternalReference')
setClass("product_end",
    representation(
        sprod_sitename = "character",
        sprod_version = "character",
        sing_version = "character",
        ipad44x28 = "character",
        sIngHardwareName = "character",
        sing_sitename = "character",
        ilat_center = "numeric",
        ilon_center = "numeric",
        iprf = "numeric",
        ipw = "numeric",
        sfilter = "character",
        ilambda = "numeric",
        itrunc = "numeric",
        ibin_first = "numeric",
        ibin_last = "numeric",
        ibin_out_num = "numeric",
        ipad184x28 = "character",
        iStdParallel1 = "numeric",
        iStdParallel2 = "numeric",
        iEarthRadius = "numeric",
        iFlattening = "numeric",
        iFaultBits = "numeric",
        iSiteMask = "numeric",
        ilat_ref = "numeric",
        ilon_ref = "numeric",
        ipad290x2 = "character",
        sLocalTZName = "character",
        ipad300x8 = "character"),
        contains = "RSWIGStruct")


# End class product_end

setClass('_p_product_hdr', contains = 'ExternalReference')
setClass("product_hdr",
    representation(
),
        contains = "RSWIGStruct")


# End class product_hdr

setClass('_p_product_hdr', contains = 'ExternalReference')
setClass('_p_task_misc_info', contains = 'ExternalReference')
setClass("task_misc_info",
    representation(
        ilambda = "numeric",
        str_id = "character",
        ixmt_pwr = "numeric",
        itrunc = "numeric",
        ipad32x18 = "character",
        ipad50x12 = "character",
        iHorzBeamWidth = "numeric",
        iVertBeamWidth = "numeric",
        iUser = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_misc_info

setClass('_p_task_end_info', contains = 'ExternalReference')
setClass("task_end_info",
    representation(
        stname = "character",
        sdscript = "character",
        ihybrid_count = "numeric",
        ipad102x2 = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_end_info

setClass('_p_task_sched_info', contains = 'ExternalReference')
setClass("task_sched_info",
    representation(
        istart = "numeric",
        istop = "numeric",
        iskip = "numeric",
        ilast_run_sec = "numeric",
        itime_used_sec = "numeric",
        ilast_run_day = "numeric",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_sched_info

setClass('_p_task_dsp_mode_batch', contains = 'ExternalReference')
setClass("task_dsp_mode_batch",
    representation(
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_dsp_mode_batch

setClass('_p_task_dsp_mode_other', contains = 'ExternalReference')
setClass("task_dsp_mode_other",
    representation(
),
        contains = "RSWIGStruct")


# End class task_dsp_mode_other

setClass('_p_task_dsp_mode_u', contains = 'ExternalReference')
setClass('_p_dsp_data_mask', contains = 'ExternalReference')
setClass("dsp_data_mask",
    representation(
        iWord0 = "numeric",
        iXhdrType = "numeric",
        iWord1 = "numeric",
        iWord2 = "numeric",
        iWord3 = "numeric",
        iWord4 = "numeric"),
        contains = "RSWIGStruct")


# End class dsp_data_mask

setClass('_p_task_dsp_info', contains = 'ExternalReference')
setClass("task_dsp_info",
    representation(
        ipad_84x52 = "character",
        iprf = "numeric",
        ipw = "numeric",
        sfilter = "character",
        iCfgHdrMask = "numeric",
        ipad_182x2 = "character",
        sCustomRayHeader = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_dsp_info

setClass('_p_task_calib_info', contains = 'ExternalReference')
setClass("task_calib_info",
    representation(
        ipad10x8 = "character",
        ipad30x6 = "character",
        ipad38x2 = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class task_calib_info

setClass('_p_serv_task_calib_info', contains = 'ExternalReference')
setClass("serv_task_calib_info",
    representation(
        iz_slope = "numeric",
        izns_thr = "numeric",
        iccr_thr = "numeric",
        isqi_thr = "numeric",
        isig_thr = "numeric",
        iz_calib = "numeric",
        iuz_tcf = "numeric",
        icz_tcf = "numeric",
        ivl_tcf = "numeric",
        iwd_tcf = "numeric",
        izdr_tcf = "numeric",
        iflags = "numeric",
        iPointClutterThreshold = "numeric",
        iPointClutterSkip = "numeric"),
        contains = "RSWIGStruct")


# End class serv_task_calib_info

setClass('_p_task_configuration', contains = 'ExternalReference')
setClass("task_configuration",
    representation(
),
        contains = "RSWIGStruct")


# End class task_configuration

setClass('_p_task_configuration', contains = 'ExternalReference')
setClass('_p_gparm', contains = 'ExternalReference')
setClass("gparm",
    representation(
),
        contains = "RSWIGStruct")


# End class gparm

setClass('_p_ingest_configuration', contains = 'ExternalReference')
setClass("ingest_configuration",
    representation(
        sfile = "character",
        idfsize = "numeric",
        ipad100x12 = "character",
        ipad120x4 = "character",
        siris_version = "character",
        sHardwareName = "character",
        sSitename = "character",
        ilat = "numeric",
        ilon = "numeric",
        ialtitude = "numeric",
        inu_vel = "numeric",
        inu_offset = "numeric",
        iFaultBits = "numeric",
        ipad222x2 = "character",
        sLocalTZName = "character",
        iIcfFlags = "numeric",
        sDpolappConfigName = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class ingest_configuration

setClass('_p_ingest_configuration', contains = 'ExternalReference')
setClass('_p_ingest_header', contains = 'ExternalReference')
setClass("ingest_header",
    representation(
        ipad_3104x732 = "character",
        ipad_end = "character"),
        contains = "RSWIGStruct")


# End class ingest_header

setClass('_p_ingest_header', contains = 'ExternalReference')
setClass('_p_ingest_data_header', contains = 'ExternalReference')
setClass("ingest_data_header",
    representation(
        ipad40x36 = "character"),
        contains = "RSWIGStruct")


# End class ingest_data_header

setClass('_p_raw_prod_bhdr', contains = 'ExternalReference')
setClass("raw_prod_bhdr",
    representation(
),
        contains = "RSWIGStruct")


# End class raw_prod_bhdr

setClass('_p_raw_prod_block', contains = 'ExternalReference')
setClass("raw_prod_block",
    representation(
),
        contains = "RSWIGStruct")


# End class raw_prod_block

setClass('_p_ray_header', contains = 'ExternalReference')
setClass("ray_header",
    representation(
),
        contains = "RSWIGStruct")


# End class ray_header

setClass('_p_extended_header_v0', contains = 'ExternalReference')
setClass("extended_header_v0",
    representation(
        itimems = "numeric",
        ipad6x14 = "character"),
        contains = "RSWIGStruct")


# End class extended_header_v0

setClass('_p_extended_header_v1', contains = 'ExternalReference')
setClass("extended_header_v1",
    representation(
        itimems = "numeric",
        ilatitude = "numeric",
        ilongitude = "numeric",
        iupdate_age = "numeric"),
        contains = "RSWIGStruct")


# End class extended_header_v1

setClass('_p_ppp_time_series', contains = 'ExternalReference')
setClass("ppp_time_series",
    representation(
),
        contains = "RSWIGStruct")


# End class ppp_time_series

setClass('_p_ray_data', contains = 'ExternalReference')
setClass('_p_data_ray', contains = 'ExternalReference')
setClass("data_ray",
    representation(
),
        contains = "RSWIGStruct")


# End class data_ray




setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})

# Start of ymds_time_isec_set

`ymds_time_isec_set` = function(self, s_isec)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  s_isec = as.numeric(s_isec) 
  
  assert(length(s_isec) == 1 && s_isec >= 0, "All values must be non-negative")
  
  .Call('R_swig_ymds_time_isec_set', self, s_isec, PACKAGE='iris')
  
}

attr(`ymds_time_isec_set`, 'returnType') = 'void'
attr(`ymds_time_isec_set`, "inputTypes") = c('_p_ymds_time', 'numeric')
class(`ymds_time_isec_set`) = c("SWIGFunction", class('ymds_time_isec_set'))

# Start of ymds_time_isec_get

`ymds_time_isec_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  .Call('R_swig_ymds_time_isec_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ymds_time_isec_get`, 'returnType') = 'numeric'
attr(`ymds_time_isec_get`, "inputTypes") = c('_p_ymds_time')
class(`ymds_time_isec_get`) = c("SWIGFunction", class('ymds_time_isec_get'))

# Start of ymds_time_imills_set

`ymds_time_imills_set` = function(self, s_imills)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  s_imills = coerceIfNotSubclass(s_imills, "_p_unsigned_short") 
  .Call('R_swig_ymds_time_imills_set', self, s_imills, PACKAGE='iris')
  
}

attr(`ymds_time_imills_set`, 'returnType') = 'void'
attr(`ymds_time_imills_set`, "inputTypes") = c('_p_ymds_time', '_p_unsigned_short')
class(`ymds_time_imills_set`) = c("SWIGFunction", class('ymds_time_imills_set'))

# Start of ymds_time_imills_get

`ymds_time_imills_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  ans = .Call('R_swig_ymds_time_imills_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ymds_time_imills_get`, 'returnType') = '_p_unsigned_short'
attr(`ymds_time_imills_get`, "inputTypes") = c('_p_ymds_time')
class(`ymds_time_imills_get`) = c("SWIGFunction", class('ymds_time_imills_get'))

# Start of ymds_time_iyear_set

`ymds_time_iyear_set` = function(self, s_iyear)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  s_iyear = coerceIfNotSubclass(s_iyear, "_p_unsigned_short") 
  .Call('R_swig_ymds_time_iyear_set', self, s_iyear, PACKAGE='iris')
  
}

attr(`ymds_time_iyear_set`, 'returnType') = 'void'
attr(`ymds_time_iyear_set`, "inputTypes") = c('_p_ymds_time', '_p_unsigned_short')
class(`ymds_time_iyear_set`) = c("SWIGFunction", class('ymds_time_iyear_set'))

# Start of ymds_time_iyear_get

`ymds_time_iyear_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  ans = .Call('R_swig_ymds_time_iyear_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ymds_time_iyear_get`, 'returnType') = '_p_unsigned_short'
attr(`ymds_time_iyear_get`, "inputTypes") = c('_p_ymds_time')
class(`ymds_time_iyear_get`) = c("SWIGFunction", class('ymds_time_iyear_get'))

# Start of ymds_time_imon_set

`ymds_time_imon_set` = function(self, s_imon)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  s_imon = coerceIfNotSubclass(s_imon, "_p_unsigned_short") 
  .Call('R_swig_ymds_time_imon_set', self, s_imon, PACKAGE='iris')
  
}

attr(`ymds_time_imon_set`, 'returnType') = 'void'
attr(`ymds_time_imon_set`, "inputTypes") = c('_p_ymds_time', '_p_unsigned_short')
class(`ymds_time_imon_set`) = c("SWIGFunction", class('ymds_time_imon_set'))

# Start of ymds_time_imon_get

`ymds_time_imon_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  ans = .Call('R_swig_ymds_time_imon_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ymds_time_imon_get`, 'returnType') = '_p_unsigned_short'
attr(`ymds_time_imon_get`, "inputTypes") = c('_p_ymds_time')
class(`ymds_time_imon_get`) = c("SWIGFunction", class('ymds_time_imon_get'))

# Start of ymds_time_iday_set

`ymds_time_iday_set` = function(self, s_iday)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  s_iday = coerceIfNotSubclass(s_iday, "_p_unsigned_short") 
  .Call('R_swig_ymds_time_iday_set', self, s_iday, PACKAGE='iris')
  
}

attr(`ymds_time_iday_set`, 'returnType') = 'void'
attr(`ymds_time_iday_set`, "inputTypes") = c('_p_ymds_time', '_p_unsigned_short')
class(`ymds_time_iday_set`) = c("SWIGFunction", class('ymds_time_iday_set'))

# Start of ymds_time_iday_get

`ymds_time_iday_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  ans = .Call('R_swig_ymds_time_iday_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ymds_time_iday_get`, 'returnType') = '_p_unsigned_short'
attr(`ymds_time_iday_get`, "inputTypes") = c('_p_ymds_time')
class(`ymds_time_iday_get`) = c("SWIGFunction", class('ymds_time_iday_get'))

# Start of new_ymds_time

`ymds_time` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ymds_time', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`ymds_time`, 'returnType') = '_p_ymds_time'
class(`ymds_time`) = c("SWIGFunction", class('ymds_time'))

# Start of delete_ymds_time

`delete_ymds_time` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ymds_time") 
  .Call('R_swig_delete_ymds_time', self, PACKAGE='iris')
  
}

attr(`delete_ymds_time`, 'returnType') = 'void'
attr(`delete_ymds_time`, "inputTypes") = c('_p_ymds_time')
class(`delete_ymds_time`) = c("SWIGFunction", class('delete_ymds_time'))

# Start of accessor method for ymds_time
setMethod('$', '_p_ymds_time', function(x, name)

{
  accessorFuns = list('isec' = ymds_time_isec_get, 'imills' = ymds_time_imills_get, 'iyear' = ymds_time_iyear_get, 'imon' = ymds_time_imon_get, 'iday' = ymds_time_iday_get)
  vaccessors = c('isec', 'imills', 'iyear', 'imon', 'iday')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ymds_time
# Start of accessor method for ymds_time
setMethod('$<-', '_p_ymds_time', function(x, name, value)

{
  accessorFuns = list('isec' = ymds_time_isec_set, 'imills' = ymds_time_imills_set, 'iyear' = ymds_time_iyear_set, 'imon' = ymds_time_imon_set, 'iday' = ymds_time_iday_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ymds_time', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('isec' = ymds_time_isec_set, 'imills' = ymds_time_imills_set, 'iyear' = ymds_time_iyear_set, 'imon' = ymds_time_imon_set, 'iday' = ymds_time_iday_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ymds_time
setMethod('delete', '_p_ymds_time', function(obj) {delete_ymds_time(obj)})
# Start definition of copy functions & methods for ymds_time
CopyToR_ymds_time = function(value, obj = new("ymds_time"))
{
  obj@isec = value$isec
  obj
}



CopyToC_ymds_time = function(value, obj)
{
  obj$isec = value@isec
  obj
}



# Start definition of copy methods for ymds_time
setMethod('copyToR', '_p_ymds_time', CopyToR_ymds_time)
setMethod('copyToC', 'ymds_time', CopyToC_ymds_time)

# End definition of copy methods for ymds_time
# End definition of copy functions & methods for ymds_time
# Start of color_scale_def_iflags_set

`color_scale_def_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_color_scale_def_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`color_scale_def_iflags_set`, 'returnType') = 'void'
attr(`color_scale_def_iflags_set`, "inputTypes") = c('_p_color_scale_def', 'numeric')
class(`color_scale_def_iflags_set`) = c("SWIGFunction", class('color_scale_def_iflags_set'))

# Start of color_scale_def_iflags_get

`color_scale_def_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  .Call('R_swig_color_scale_def_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`color_scale_def_iflags_get`, 'returnType') = 'numeric'
attr(`color_scale_def_iflags_get`, "inputTypes") = c('_p_color_scale_def')
class(`color_scale_def_iflags_get`) = c("SWIGFunction", class('color_scale_def_iflags_get'))

# Start of color_scale_def_istart_set

`color_scale_def_istart_set` = function(self, s_istart)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  s_istart = as.integer(s_istart) 
  
  if(length(s_istart) > 1) {
    Rf_warning("using only the first element of s_istart")
  }
  
  .Call('R_swig_color_scale_def_istart_set', self, s_istart, PACKAGE='iris')
  
}

attr(`color_scale_def_istart_set`, 'returnType') = 'void'
attr(`color_scale_def_istart_set`, "inputTypes") = c('_p_color_scale_def', 'numeric')
class(`color_scale_def_istart_set`) = c("SWIGFunction", class('color_scale_def_istart_set'))

# Start of color_scale_def_istart_get

`color_scale_def_istart_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  .Call('R_swig_color_scale_def_istart_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`color_scale_def_istart_get`, 'returnType') = 'numeric'
attr(`color_scale_def_istart_get`, "inputTypes") = c('_p_color_scale_def')
class(`color_scale_def_istart_get`) = c("SWIGFunction", class('color_scale_def_istart_get'))

# Start of color_scale_def_istep_set

`color_scale_def_istep_set` = function(self, s_istep)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  s_istep = as.integer(s_istep) 
  
  if(length(s_istep) > 1) {
    Rf_warning("using only the first element of s_istep")
  }
  
  .Call('R_swig_color_scale_def_istep_set', self, s_istep, PACKAGE='iris')
  
}

attr(`color_scale_def_istep_set`, 'returnType') = 'void'
attr(`color_scale_def_istep_set`, "inputTypes") = c('_p_color_scale_def', 'numeric')
class(`color_scale_def_istep_set`) = c("SWIGFunction", class('color_scale_def_istep_set'))

# Start of color_scale_def_istep_get

`color_scale_def_istep_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  .Call('R_swig_color_scale_def_istep_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`color_scale_def_istep_get`, 'returnType') = 'numeric'
attr(`color_scale_def_istep_get`, "inputTypes") = c('_p_color_scale_def')
class(`color_scale_def_istep_get`) = c("SWIGFunction", class('color_scale_def_istep_get'))

# Start of color_scale_def_icolcnt_set

`color_scale_def_icolcnt_set` = function(self, s_icolcnt)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  s_icolcnt = coerceIfNotSubclass(s_icolcnt, "_p_short") 
  .Call('R_swig_color_scale_def_icolcnt_set', self, s_icolcnt, PACKAGE='iris')
  
}

attr(`color_scale_def_icolcnt_set`, 'returnType') = 'void'
attr(`color_scale_def_icolcnt_set`, "inputTypes") = c('_p_color_scale_def', '_p_short')
class(`color_scale_def_icolcnt_set`) = c("SWIGFunction", class('color_scale_def_icolcnt_set'))

# Start of color_scale_def_icolcnt_get

`color_scale_def_icolcnt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  ans = .Call('R_swig_color_scale_def_icolcnt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`color_scale_def_icolcnt_get`, 'returnType') = '_p_short'
attr(`color_scale_def_icolcnt_get`, "inputTypes") = c('_p_color_scale_def')
class(`color_scale_def_icolcnt_get`) = c("SWIGFunction", class('color_scale_def_icolcnt_get'))

# Start of color_scale_def_iset_and_scale_set

`color_scale_def_iset_and_scale_set` = function(self, s_iset_and_scale)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  s_iset_and_scale = coerceIfNotSubclass(s_iset_and_scale, "_p_unsigned_short") 
  .Call('R_swig_color_scale_def_iset_and_scale_set', self, s_iset_and_scale, PACKAGE='iris')
  
}

attr(`color_scale_def_iset_and_scale_set`, 'returnType') = 'void'
attr(`color_scale_def_iset_and_scale_set`, "inputTypes") = c('_p_color_scale_def', '_p_unsigned_short')
class(`color_scale_def_iset_and_scale_set`) = c("SWIGFunction", class('color_scale_def_iset_and_scale_set'))

# Start of color_scale_def_iset_and_scale_get

`color_scale_def_iset_and_scale_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  ans = .Call('R_swig_color_scale_def_iset_and_scale_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`color_scale_def_iset_and_scale_get`, 'returnType') = '_p_unsigned_short'
attr(`color_scale_def_iset_and_scale_get`, "inputTypes") = c('_p_color_scale_def')
class(`color_scale_def_iset_and_scale_get`) = c("SWIGFunction", class('color_scale_def_iset_and_scale_get'))

# Start of color_scale_def_ilevel_seams_set

`color_scale_def_ilevel_seams_set` = function(self, s_ilevel_seams)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  
  if(is.list(s_ilevel_seams))
  assert(all(sapply(s_ilevel_seams, class) == "_p_unsigned_short"))     
  
  
#  assert(length(s_ilevel_seams) >= 16)
  
  .Call('R_swig_color_scale_def_ilevel_seams_set', self, s_ilevel_seams, PACKAGE='iris')
  
}

attr(`color_scale_def_ilevel_seams_set`, 'returnType') = 'void'
attr(`color_scale_def_ilevel_seams_set`, "inputTypes") = c('_p_color_scale_def', '_p_unsigned_short')
class(`color_scale_def_ilevel_seams_set`) = c("SWIGFunction", class('color_scale_def_ilevel_seams_set'))

# Start of color_scale_def_ilevel_seams_get

`color_scale_def_ilevel_seams_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  ans = .Call('R_swig_color_scale_def_ilevel_seams_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`color_scale_def_ilevel_seams_get`, 'returnType') = '_p_unsigned_short'
attr(`color_scale_def_ilevel_seams_get`, "inputTypes") = c('_p_color_scale_def')
class(`color_scale_def_ilevel_seams_get`) = c("SWIGFunction", class('color_scale_def_ilevel_seams_get'))

# Start of new_color_scale_def

`color_scale_def` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_color_scale_def', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_color_scale_def"
  
  ans
  
}

attr(`color_scale_def`, 'returnType') = '_p_color_scale_def'
class(`color_scale_def`) = c("SWIGFunction", class('color_scale_def'))

# Start of delete_color_scale_def

`delete_color_scale_def` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_color_scale_def") 
  .Call('R_swig_delete_color_scale_def', self, PACKAGE='iris')
  
}

attr(`delete_color_scale_def`, 'returnType') = 'void'
attr(`delete_color_scale_def`, "inputTypes") = c('_p_color_scale_def')
class(`delete_color_scale_def`) = c("SWIGFunction", class('delete_color_scale_def'))

# Start of accessor method for color_scale_def
setMethod('$', '_p_color_scale_def', function(x, name)

{
  accessorFuns = list('iflags' = color_scale_def_iflags_get, 'istart' = color_scale_def_istart_get, 'istep' = color_scale_def_istep_get, 'icolcnt' = color_scale_def_icolcnt_get, 'iset_and_scale' = color_scale_def_iset_and_scale_get, 'ilevel_seams' = color_scale_def_ilevel_seams_get)
  vaccessors = c('iflags', 'istart', 'istep', 'icolcnt', 'iset_and_scale', 'ilevel_seams')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for color_scale_def
# Start of accessor method for color_scale_def
setMethod('$<-', '_p_color_scale_def', function(x, name, value)

{
  accessorFuns = list('iflags' = color_scale_def_iflags_set, 'istart' = color_scale_def_istart_set, 'istep' = color_scale_def_istep_set, 'icolcnt' = color_scale_def_icolcnt_set, 'iset_and_scale' = color_scale_def_iset_and_scale_set, 'ilevel_seams' = color_scale_def_ilevel_seams_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_color_scale_def', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iflags' = color_scale_def_iflags_set, 'istart' = color_scale_def_istart_set, 'istep' = color_scale_def_istep_set, 'icolcnt' = color_scale_def_icolcnt_set, 'iset_and_scale' = color_scale_def_iset_and_scale_set, 'ilevel_seams' = color_scale_def_ilevel_seams_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for color_scale_def
setMethod('delete', '_p_color_scale_def', function(obj) {delete_color_scale_def(obj)})
# Start definition of copy functions & methods for color_scale_def
CopyToR_color_scale_def = function(value, obj = new("color_scale_def"))
{
  obj@iflags = value$iflags
  obj@istart = value$istart
  obj@istep = value$istep
  obj
}



CopyToC_color_scale_def = function(value, obj)
{
  obj$iflags = value@iflags
  obj$istart = value@istart
  obj$istep = value@istep
  obj
}



# Start definition of copy methods for color_scale_def
setMethod('copyToR', '_p_color_scale_def', CopyToR_color_scale_def)
setMethod('copyToC', 'color_scale_def', CopyToC_color_scale_def)

# End definition of copy methods for color_scale_def
# End definition of copy functions & methods for color_scale_def
# Start of structure_header_id_set

`structure_header_id_set` = function(self, s_id)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  s_id = coerceIfNotSubclass(s_id, "_p_short") 
  .Call('R_swig_structure_header_id_set', self, s_id, PACKAGE='iris')
  
}

attr(`structure_header_id_set`, 'returnType') = 'void'
attr(`structure_header_id_set`, "inputTypes") = c('_p_structure_header', '_p_short')
class(`structure_header_id_set`) = c("SWIGFunction", class('structure_header_id_set'))

# Start of structure_header_id_get

`structure_header_id_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  ans = .Call('R_swig_structure_header_id_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`structure_header_id_get`, 'returnType') = '_p_short'
attr(`structure_header_id_get`, "inputTypes") = c('_p_structure_header')
class(`structure_header_id_get`) = c("SWIGFunction", class('structure_header_id_get'))

# Start of structure_header_ivers_set

`structure_header_ivers_set` = function(self, s_ivers)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  s_ivers = coerceIfNotSubclass(s_ivers, "_p_short") 
  .Call('R_swig_structure_header_ivers_set', self, s_ivers, PACKAGE='iris')
  
}

attr(`structure_header_ivers_set`, 'returnType') = 'void'
attr(`structure_header_ivers_set`, "inputTypes") = c('_p_structure_header', '_p_short')
class(`structure_header_ivers_set`) = c("SWIGFunction", class('structure_header_ivers_set'))

# Start of structure_header_ivers_get

`structure_header_ivers_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  ans = .Call('R_swig_structure_header_ivers_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`structure_header_ivers_get`, 'returnType') = '_p_short'
attr(`structure_header_ivers_get`, "inputTypes") = c('_p_structure_header')
class(`structure_header_ivers_get`) = c("SWIGFunction", class('structure_header_ivers_get'))

# Start of structure_header_ibytes_set

`structure_header_ibytes_set` = function(self, s_ibytes)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  s_ibytes = as.integer(s_ibytes) 
  
  if(length(s_ibytes) > 1) {
    Rf_warning("using only the first element of s_ibytes")
  }
  
  .Call('R_swig_structure_header_ibytes_set', self, s_ibytes, PACKAGE='iris')
  
}

attr(`structure_header_ibytes_set`, 'returnType') = 'void'
attr(`structure_header_ibytes_set`, "inputTypes") = c('_p_structure_header', 'numeric')
class(`structure_header_ibytes_set`) = c("SWIGFunction", class('structure_header_ibytes_set'))

# Start of structure_header_ibytes_get

`structure_header_ibytes_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  .Call('R_swig_structure_header_ibytes_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`structure_header_ibytes_get`, 'returnType') = 'numeric'
attr(`structure_header_ibytes_get`, "inputTypes") = c('_p_structure_header')
class(`structure_header_ibytes_get`) = c("SWIGFunction", class('structure_header_ibytes_get'))

# Start of structure_header_reserved_set

`structure_header_reserved_set` = function(self, s_reserved)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  s_reserved = coerceIfNotSubclass(s_reserved, "_p_short") 
  .Call('R_swig_structure_header_reserved_set', self, s_reserved, PACKAGE='iris')
  
}

attr(`structure_header_reserved_set`, 'returnType') = 'void'
attr(`structure_header_reserved_set`, "inputTypes") = c('_p_structure_header', '_p_short')
class(`structure_header_reserved_set`) = c("SWIGFunction", class('structure_header_reserved_set'))

# Start of structure_header_reserved_get

`structure_header_reserved_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  ans = .Call('R_swig_structure_header_reserved_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`structure_header_reserved_get`, 'returnType') = '_p_short'
attr(`structure_header_reserved_get`, "inputTypes") = c('_p_structure_header')
class(`structure_header_reserved_get`) = c("SWIGFunction", class('structure_header_reserved_get'))

# Start of structure_header_iflags_set

`structure_header_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_short") 
  .Call('R_swig_structure_header_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`structure_header_iflags_set`, 'returnType') = 'void'
attr(`structure_header_iflags_set`, "inputTypes") = c('_p_structure_header', '_p_short')
class(`structure_header_iflags_set`) = c("SWIGFunction", class('structure_header_iflags_set'))

# Start of structure_header_iflags_get

`structure_header_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  ans = .Call('R_swig_structure_header_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`structure_header_iflags_get`, 'returnType') = '_p_short'
attr(`structure_header_iflags_get`, "inputTypes") = c('_p_structure_header')
class(`structure_header_iflags_get`) = c("SWIGFunction", class('structure_header_iflags_get'))

# Start of new_structure_header

`structure_header` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_structure_header', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_structure_header"
  
  ans
  
}

attr(`structure_header`, 'returnType') = '_p_structure_header'
class(`structure_header`) = c("SWIGFunction", class('structure_header'))

# Start of delete_structure_header

`delete_structure_header` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_structure_header") 
  .Call('R_swig_delete_structure_header', self, PACKAGE='iris')
  
}

attr(`delete_structure_header`, 'returnType') = 'void'
attr(`delete_structure_header`, "inputTypes") = c('_p_structure_header')
class(`delete_structure_header`) = c("SWIGFunction", class('delete_structure_header'))

# Start of accessor method for structure_header
setMethod('$', '_p_structure_header', function(x, name)

{
  accessorFuns = list('id' = structure_header_id_get, 'ivers' = structure_header_ivers_get, 'ibytes' = structure_header_ibytes_get, 'reserved' = structure_header_reserved_get, 'iflags' = structure_header_iflags_get)
  vaccessors = c('id', 'ivers', 'ibytes', 'reserved', 'iflags')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for structure_header
# Start of accessor method for structure_header
setMethod('$<-', '_p_structure_header', function(x, name, value)

{
  accessorFuns = list('id' = structure_header_id_set, 'ivers' = structure_header_ivers_set, 'ibytes' = structure_header_ibytes_set, 'reserved' = structure_header_reserved_set, 'iflags' = structure_header_iflags_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_structure_header', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('id' = structure_header_id_set, 'ivers' = structure_header_ivers_set, 'ibytes' = structure_header_ibytes_set, 'reserved' = structure_header_reserved_set, 'iflags' = structure_header_iflags_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for structure_header
setMethod('delete', '_p_structure_header', function(obj) {delete_structure_header(obj)})
# Start definition of copy functions & methods for structure_header
CopyToR_structure_header = function(value, obj = new("structure_header"))
{
  obj@ibytes = value$ibytes
  obj
}



CopyToC_structure_header = function(value, obj)
{
  obj$ibytes = value@ibytes
  obj
}



# Start definition of copy methods for structure_header
setMethod('copyToR', '_p_structure_header', CopyToR_structure_header)
setMethod('copyToC', 'structure_header', CopyToC_structure_header)

# End definition of copy methods for structure_header
# End definition of copy functions & methods for structure_header
# Start of beam_psi_struct_irmin_set

`beam_psi_struct_irmin_set` = function(self, s_irmin)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_irmin = as.numeric(s_irmin) 
  
  assert(length(s_irmin) == 1 && s_irmin >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_irmin_set', self, s_irmin, PACKAGE='iris')
  
}

attr(`beam_psi_struct_irmin_set`, 'returnType') = 'void'
attr(`beam_psi_struct_irmin_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_irmin_set`) = c("SWIGFunction", class('beam_psi_struct_irmin_set'))

# Start of beam_psi_struct_irmin_get

`beam_psi_struct_irmin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_irmin_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_irmin_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_irmin_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_irmin_get`) = c("SWIGFunction", class('beam_psi_struct_irmin_get'))

# Start of beam_psi_struct_irmax_set

`beam_psi_struct_irmax_set` = function(self, s_irmax)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_irmax = as.numeric(s_irmax) 
  
  assert(length(s_irmax) == 1 && s_irmax >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_irmax_set', self, s_irmax, PACKAGE='iris')
  
}

attr(`beam_psi_struct_irmax_set`, 'returnType') = 'void'
attr(`beam_psi_struct_irmax_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_irmax_set`) = c("SWIGFunction", class('beam_psi_struct_irmax_set'))

# Start of beam_psi_struct_irmax_get

`beam_psi_struct_irmax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_irmax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_irmax_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_irmax_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_irmax_get`) = c("SWIGFunction", class('beam_psi_struct_irmax_get'))

# Start of beam_psi_struct_iaz_left_set

`beam_psi_struct_iaz_left_set` = function(self, s_iaz_left)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iaz_left = as.numeric(s_iaz_left) 
  
  assert(length(s_iaz_left) == 1 && s_iaz_left >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iaz_left_set', self, s_iaz_left, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_left_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iaz_left_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iaz_left_set`) = c("SWIGFunction", class('beam_psi_struct_iaz_left_set'))

# Start of beam_psi_struct_iaz_left_get

`beam_psi_struct_iaz_left_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iaz_left_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_left_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iaz_left_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iaz_left_get`) = c("SWIGFunction", class('beam_psi_struct_iaz_left_get'))

# Start of beam_psi_struct_iaz_right_set

`beam_psi_struct_iaz_right_set` = function(self, s_iaz_right)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iaz_right = as.numeric(s_iaz_right) 
  
  assert(length(s_iaz_right) == 1 && s_iaz_right >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iaz_right_set', self, s_iaz_right, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_right_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iaz_right_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iaz_right_set`) = c("SWIGFunction", class('beam_psi_struct_iaz_right_set'))

# Start of beam_psi_struct_iaz_right_get

`beam_psi_struct_iaz_right_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iaz_right_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_right_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iaz_right_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iaz_right_get`) = c("SWIGFunction", class('beam_psi_struct_iaz_right_get'))

# Start of beam_psi_struct_iel_low_set

`beam_psi_struct_iel_low_set` = function(self, s_iel_low)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iel_low = as.numeric(s_iel_low) 
  
  assert(length(s_iel_low) == 1 && s_iel_low >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iel_low_set', self, s_iel_low, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_low_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iel_low_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iel_low_set`) = c("SWIGFunction", class('beam_psi_struct_iel_low_set'))

# Start of beam_psi_struct_iel_low_get

`beam_psi_struct_iel_low_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iel_low_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_low_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iel_low_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iel_low_get`) = c("SWIGFunction", class('beam_psi_struct_iel_low_get'))

# Start of beam_psi_struct_iel_high_set

`beam_psi_struct_iel_high_set` = function(self, s_iel_high)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iel_high = as.numeric(s_iel_high) 
  
  assert(length(s_iel_high) == 1 && s_iel_high >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iel_high_set', self, s_iel_high, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_high_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iel_high_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iel_high_set`) = c("SWIGFunction", class('beam_psi_struct_iel_high_set'))

# Start of beam_psi_struct_iel_high_get

`beam_psi_struct_iel_high_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iel_high_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_high_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iel_high_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iel_high_get`) = c("SWIGFunction", class('beam_psi_struct_iel_high_get'))

# Start of beam_psi_struct_iaz_smooth_set

`beam_psi_struct_iaz_smooth_set` = function(self, s_iaz_smooth)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iaz_smooth = as.numeric(s_iaz_smooth) 
  
  assert(length(s_iaz_smooth) == 1 && s_iaz_smooth >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iaz_smooth_set', self, s_iaz_smooth, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_smooth_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iaz_smooth_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iaz_smooth_set`) = c("SWIGFunction", class('beam_psi_struct_iaz_smooth_set'))

# Start of beam_psi_struct_iaz_smooth_get

`beam_psi_struct_iaz_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iaz_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_smooth_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iaz_smooth_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iaz_smooth_get`) = c("SWIGFunction", class('beam_psi_struct_iaz_smooth_get'))

# Start of beam_psi_struct_iel_smooth_set

`beam_psi_struct_iel_smooth_set` = function(self, s_iel_smooth)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iel_smooth = as.numeric(s_iel_smooth) 
  
  assert(length(s_iel_smooth) == 1 && s_iel_smooth >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iel_smooth_set', self, s_iel_smooth, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_smooth_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iel_smooth_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iel_smooth_set`) = c("SWIGFunction", class('beam_psi_struct_iel_smooth_set'))

# Start of beam_psi_struct_iel_smooth_get

`beam_psi_struct_iel_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iel_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_smooth_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iel_smooth_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iel_smooth_get`) = c("SWIGFunction", class('beam_psi_struct_iel_smooth_get'))

# Start of beam_psi_struct_iaz_sun_start_set

`beam_psi_struct_iaz_sun_start_set` = function(self, s_iaz_sun_start)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iaz_sun_start = as.numeric(s_iaz_sun_start) 
  
  assert(length(s_iaz_sun_start) == 1 && s_iaz_sun_start >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iaz_sun_start_set', self, s_iaz_sun_start, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_sun_start_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iaz_sun_start_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iaz_sun_start_set`) = c("SWIGFunction", class('beam_psi_struct_iaz_sun_start_set'))

# Start of beam_psi_struct_iaz_sun_start_get

`beam_psi_struct_iaz_sun_start_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iaz_sun_start_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_sun_start_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iaz_sun_start_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iaz_sun_start_get`) = c("SWIGFunction", class('beam_psi_struct_iaz_sun_start_get'))

# Start of beam_psi_struct_iel_sun_start_set

`beam_psi_struct_iel_sun_start_set` = function(self, s_iel_sun_start)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iel_sun_start = as.numeric(s_iel_sun_start) 
  
  assert(length(s_iel_sun_start) == 1 && s_iel_sun_start >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iel_sun_start_set', self, s_iel_sun_start, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_sun_start_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iel_sun_start_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iel_sun_start_set`) = c("SWIGFunction", class('beam_psi_struct_iel_sun_start_set'))

# Start of beam_psi_struct_iel_sun_start_get

`beam_psi_struct_iel_sun_start_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iel_sun_start_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_sun_start_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iel_sun_start_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iel_sun_start_get`) = c("SWIGFunction", class('beam_psi_struct_iel_sun_start_get'))

# Start of beam_psi_struct_iaz_sun_end_set

`beam_psi_struct_iaz_sun_end_set` = function(self, s_iaz_sun_end)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iaz_sun_end = as.numeric(s_iaz_sun_end) 
  
  assert(length(s_iaz_sun_end) == 1 && s_iaz_sun_end >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iaz_sun_end_set', self, s_iaz_sun_end, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_sun_end_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iaz_sun_end_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iaz_sun_end_set`) = c("SWIGFunction", class('beam_psi_struct_iaz_sun_end_set'))

# Start of beam_psi_struct_iaz_sun_end_get

`beam_psi_struct_iaz_sun_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iaz_sun_end_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iaz_sun_end_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iaz_sun_end_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iaz_sun_end_get`) = c("SWIGFunction", class('beam_psi_struct_iaz_sun_end_get'))

# Start of beam_psi_struct_iel_sun_end_set

`beam_psi_struct_iel_sun_end_set` = function(self, s_iel_sun_end)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  s_iel_sun_end = as.numeric(s_iel_sun_end) 
  
  assert(length(s_iel_sun_end) == 1 && s_iel_sun_end >= 0, "All values must be non-negative")
  
  .Call('R_swig_beam_psi_struct_iel_sun_end_set', self, s_iel_sun_end, PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_sun_end_set`, 'returnType') = 'void'
attr(`beam_psi_struct_iel_sun_end_set`, "inputTypes") = c('_p_beam_psi_struct', 'numeric')
class(`beam_psi_struct_iel_sun_end_set`) = c("SWIGFunction", class('beam_psi_struct_iel_sun_end_set'))

# Start of beam_psi_struct_iel_sun_end_get

`beam_psi_struct_iel_sun_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_beam_psi_struct_iel_sun_end_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`beam_psi_struct_iel_sun_end_get`, 'returnType') = 'numeric'
attr(`beam_psi_struct_iel_sun_end_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_iel_sun_end_get`) = c("SWIGFunction", class('beam_psi_struct_iel_sun_end_get'))

# Start of beam_psi_struct_ipad_end_set

`beam_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -48)
  
  .Call('R_swig_beam_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`beam_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`beam_psi_struct_ipad_end_set`, "inputTypes") = c('_p_beam_psi_struct', '_p_char')
class(`beam_psi_struct_ipad_end_set`) = c("SWIGFunction", class('beam_psi_struct_ipad_end_set'))

# Start of beam_psi_struct_ipad_end_get

`beam_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  ans = .Call('R_swig_beam_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`beam_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`beam_psi_struct_ipad_end_get`, "inputTypes") = c('_p_beam_psi_struct')
class(`beam_psi_struct_ipad_end_get`) = c("SWIGFunction", class('beam_psi_struct_ipad_end_get'))

# Start of new_beam_psi_struct

`beam_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_beam_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_beam_psi_struct"
  
  ans
  
}

attr(`beam_psi_struct`, 'returnType') = '_p_beam_psi_struct'
class(`beam_psi_struct`) = c("SWIGFunction", class('beam_psi_struct'))

# Start of delete_beam_psi_struct

`delete_beam_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_beam_psi_struct") 
  .Call('R_swig_delete_beam_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_beam_psi_struct`, 'returnType') = 'void'
attr(`delete_beam_psi_struct`, "inputTypes") = c('_p_beam_psi_struct')
class(`delete_beam_psi_struct`) = c("SWIGFunction", class('delete_beam_psi_struct'))

# Start of accessor method for beam_psi_struct
setMethod('$', '_p_beam_psi_struct', function(x, name)

{
  accessorFuns = list('irmin' = beam_psi_struct_irmin_get, 'irmax' = beam_psi_struct_irmax_get, 'iaz_left' = beam_psi_struct_iaz_left_get, 'iaz_right' = beam_psi_struct_iaz_right_get, 'iel_low' = beam_psi_struct_iel_low_get, 'iel_high' = beam_psi_struct_iel_high_get, 'iaz_smooth' = beam_psi_struct_iaz_smooth_get, 'iel_smooth' = beam_psi_struct_iel_smooth_get, 'iaz_sun_start' = beam_psi_struct_iaz_sun_start_get, 'iel_sun_start' = beam_psi_struct_iel_sun_start_get, 'iaz_sun_end' = beam_psi_struct_iaz_sun_end_get, 'iel_sun_end' = beam_psi_struct_iel_sun_end_get, 'ipad_end' = beam_psi_struct_ipad_end_get)
  vaccessors = c('irmin', 'irmax', 'iaz_left', 'iaz_right', 'iel_low', 'iel_high', 'iaz_smooth', 'iel_smooth', 'iaz_sun_start', 'iel_sun_start', 'iaz_sun_end', 'iel_sun_end', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for beam_psi_struct
# Start of accessor method for beam_psi_struct
setMethod('$<-', '_p_beam_psi_struct', function(x, name, value)

{
  accessorFuns = list('irmin' = beam_psi_struct_irmin_set, 'irmax' = beam_psi_struct_irmax_set, 'iaz_left' = beam_psi_struct_iaz_left_set, 'iaz_right' = beam_psi_struct_iaz_right_set, 'iel_low' = beam_psi_struct_iel_low_set, 'iel_high' = beam_psi_struct_iel_high_set, 'iaz_smooth' = beam_psi_struct_iaz_smooth_set, 'iel_smooth' = beam_psi_struct_iel_smooth_set, 'iaz_sun_start' = beam_psi_struct_iaz_sun_start_set, 'iel_sun_start' = beam_psi_struct_iel_sun_start_set, 'iaz_sun_end' = beam_psi_struct_iaz_sun_end_set, 'iel_sun_end' = beam_psi_struct_iel_sun_end_set, 'ipad_end' = beam_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_beam_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('irmin' = beam_psi_struct_irmin_set, 'irmax' = beam_psi_struct_irmax_set, 'iaz_left' = beam_psi_struct_iaz_left_set, 'iaz_right' = beam_psi_struct_iaz_right_set, 'iel_low' = beam_psi_struct_iel_low_set, 'iel_high' = beam_psi_struct_iel_high_set, 'iaz_smooth' = beam_psi_struct_iaz_smooth_set, 'iel_smooth' = beam_psi_struct_iel_smooth_set, 'iaz_sun_start' = beam_psi_struct_iaz_sun_start_set, 'iel_sun_start' = beam_psi_struct_iel_sun_start_set, 'iaz_sun_end' = beam_psi_struct_iaz_sun_end_set, 'iel_sun_end' = beam_psi_struct_iel_sun_end_set, 'ipad_end' = beam_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for beam_psi_struct
setMethod('delete', '_p_beam_psi_struct', function(obj) {delete_beam_psi_struct(obj)})
# Start definition of copy functions & methods for beam_psi_struct
CopyToR_beam_psi_struct = function(value, obj = new("beam_psi_struct"))
{
  obj@irmin = value$irmin
  obj@irmax = value$irmax
  obj@iaz_left = value$iaz_left
  obj@iaz_right = value$iaz_right
  obj@iel_low = value$iel_low
  obj@iel_high = value$iel_high
  obj@iaz_smooth = value$iaz_smooth
  obj@iel_smooth = value$iel_smooth
  obj@iaz_sun_start = value$iaz_sun_start
  obj@iel_sun_start = value$iel_sun_start
  obj@iaz_sun_end = value$iaz_sun_end
  obj@iel_sun_end = value$iel_sun_end
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_beam_psi_struct = function(value, obj)
{
  obj$irmin = value@irmin
  obj$irmax = value@irmax
  obj$iaz_left = value@iaz_left
  obj$iaz_right = value@iaz_right
  obj$iel_low = value@iel_low
  obj$iel_high = value@iel_high
  obj$iaz_smooth = value@iaz_smooth
  obj$iel_smooth = value@iel_smooth
  obj$iaz_sun_start = value@iaz_sun_start
  obj$iel_sun_start = value@iel_sun_start
  obj$iaz_sun_end = value@iaz_sun_end
  obj$iel_sun_end = value@iel_sun_end
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for beam_psi_struct
setMethod('copyToR', '_p_beam_psi_struct', CopyToR_beam_psi_struct)
setMethod('copyToC', 'beam_psi_struct', CopyToC_beam_psi_struct)

# End definition of copy methods for beam_psi_struct
# End definition of copy functions & methods for beam_psi_struct
# Start of cappi_psi_struct_iShearFlags_set

`cappi_psi_struct_iShearFlags_set` = function(self, s_iShearFlags)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  s_iShearFlags = as.numeric(s_iShearFlags) 
  
  assert(length(s_iShearFlags) == 1 && s_iShearFlags >= 0, "All values must be non-negative")
  
  .Call('R_swig_cappi_psi_struct_iShearFlags_set', self, s_iShearFlags, PACKAGE='iris')
  
}

attr(`cappi_psi_struct_iShearFlags_set`, 'returnType') = 'void'
attr(`cappi_psi_struct_iShearFlags_set`, "inputTypes") = c('_p_cappi_psi_struct', 'numeric')
class(`cappi_psi_struct_iShearFlags_set`) = c("SWIGFunction", class('cappi_psi_struct_iShearFlags_set'))

# Start of cappi_psi_struct_iShearFlags_get

`cappi_psi_struct_iShearFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  .Call('R_swig_cappi_psi_struct_iShearFlags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`cappi_psi_struct_iShearFlags_get`, 'returnType') = 'numeric'
attr(`cappi_psi_struct_iShearFlags_get`, "inputTypes") = c('_p_cappi_psi_struct')
class(`cappi_psi_struct_iShearFlags_get`) = c("SWIGFunction", class('cappi_psi_struct_iShearFlags_get'))

# Start of cappi_psi_struct_icappi_hgt_set

`cappi_psi_struct_icappi_hgt_set` = function(self, s_icappi_hgt)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  s_icappi_hgt = as.integer(s_icappi_hgt) 
  
  if(length(s_icappi_hgt) > 1) {
    Rf_warning("using only the first element of s_icappi_hgt")
  }
  
  .Call('R_swig_cappi_psi_struct_icappi_hgt_set', self, s_icappi_hgt, PACKAGE='iris')
  
}

attr(`cappi_psi_struct_icappi_hgt_set`, 'returnType') = 'void'
attr(`cappi_psi_struct_icappi_hgt_set`, "inputTypes") = c('_p_cappi_psi_struct', 'numeric')
class(`cappi_psi_struct_icappi_hgt_set`) = c("SWIGFunction", class('cappi_psi_struct_icappi_hgt_set'))

# Start of cappi_psi_struct_icappi_hgt_get

`cappi_psi_struct_icappi_hgt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  .Call('R_swig_cappi_psi_struct_icappi_hgt_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`cappi_psi_struct_icappi_hgt_get`, 'returnType') = 'numeric'
attr(`cappi_psi_struct_icappi_hgt_get`, "inputTypes") = c('_p_cappi_psi_struct')
class(`cappi_psi_struct_icappi_hgt_get`) = c("SWIGFunction", class('cappi_psi_struct_icappi_hgt_get'))

# Start of cappi_psi_struct_icappi_flags_set

`cappi_psi_struct_icappi_flags_set` = function(self, s_icappi_flags)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  s_icappi_flags = coerceIfNotSubclass(s_icappi_flags, "_p_unsigned_short") 
  .Call('R_swig_cappi_psi_struct_icappi_flags_set', self, s_icappi_flags, PACKAGE='iris')
  
}

attr(`cappi_psi_struct_icappi_flags_set`, 'returnType') = 'void'
attr(`cappi_psi_struct_icappi_flags_set`, "inputTypes") = c('_p_cappi_psi_struct', '_p_unsigned_short')
class(`cappi_psi_struct_icappi_flags_set`) = c("SWIGFunction", class('cappi_psi_struct_icappi_flags_set'))

# Start of cappi_psi_struct_icappi_flags_get

`cappi_psi_struct_icappi_flags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  ans = .Call('R_swig_cappi_psi_struct_icappi_flags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`cappi_psi_struct_icappi_flags_get`, 'returnType') = '_p_unsigned_short'
attr(`cappi_psi_struct_icappi_flags_get`, "inputTypes") = c('_p_cappi_psi_struct')
class(`cappi_psi_struct_icappi_flags_get`) = c("SWIGFunction", class('cappi_psi_struct_icappi_flags_get'))

# Start of cappi_psi_struct_iAzSmooth_set

`cappi_psi_struct_iAzSmooth_set` = function(self, s_iAzSmooth)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  s_iAzSmooth = coerceIfNotSubclass(s_iAzSmooth, "_p_unsigned_short") 
  .Call('R_swig_cappi_psi_struct_iAzSmooth_set', self, s_iAzSmooth, PACKAGE='iris')
  
}

attr(`cappi_psi_struct_iAzSmooth_set`, 'returnType') = 'void'
attr(`cappi_psi_struct_iAzSmooth_set`, "inputTypes") = c('_p_cappi_psi_struct', '_p_unsigned_short')
class(`cappi_psi_struct_iAzSmooth_set`) = c("SWIGFunction", class('cappi_psi_struct_iAzSmooth_set'))

# Start of cappi_psi_struct_iAzSmooth_get

`cappi_psi_struct_iAzSmooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  ans = .Call('R_swig_cappi_psi_struct_iAzSmooth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`cappi_psi_struct_iAzSmooth_get`, 'returnType') = '_p_unsigned_short'
attr(`cappi_psi_struct_iAzSmooth_get`, "inputTypes") = c('_p_cappi_psi_struct')
class(`cappi_psi_struct_iAzSmooth_get`) = c("SWIGFunction", class('cappi_psi_struct_iAzSmooth_get'))

# Start of cappi_psi_struct_svvp_name_set

`cappi_psi_struct_svvp_name_set` = function(self, s_svvp_name)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  
  if(is.list(s_svvp_name))
  assert(all(sapply(s_svvp_name, class) == "_p_char"))     
  
  
#  assert(length(s_svvp_name) >= 12)
  
  .Call('R_swig_cappi_psi_struct_svvp_name_set', self, s_svvp_name, PACKAGE='iris')
  
}

attr(`cappi_psi_struct_svvp_name_set`, 'returnType') = 'void'
attr(`cappi_psi_struct_svvp_name_set`, "inputTypes") = c('_p_cappi_psi_struct', '_p_char')
class(`cappi_psi_struct_svvp_name_set`) = c("SWIGFunction", class('cappi_psi_struct_svvp_name_set'))

# Start of cappi_psi_struct_svvp_name_get

`cappi_psi_struct_svvp_name_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  ans = .Call('R_swig_cappi_psi_struct_svvp_name_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`cappi_psi_struct_svvp_name_get`, 'returnType') = '_p_char'
attr(`cappi_psi_struct_svvp_name_get`, "inputTypes") = c('_p_cappi_psi_struct')
class(`cappi_psi_struct_svvp_name_get`) = c("SWIGFunction", class('cappi_psi_struct_svvp_name_get'))

# Start of cappi_psi_struct_ivvp_max_age_set

`cappi_psi_struct_ivvp_max_age_set` = function(self, s_ivvp_max_age)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  s_ivvp_max_age = as.numeric(s_ivvp_max_age) 
  
  assert(length(s_ivvp_max_age) == 1 && s_ivvp_max_age >= 0, "All values must be non-negative")
  
  .Call('R_swig_cappi_psi_struct_ivvp_max_age_set', self, s_ivvp_max_age, PACKAGE='iris')
  
}

attr(`cappi_psi_struct_ivvp_max_age_set`, 'returnType') = 'void'
attr(`cappi_psi_struct_ivvp_max_age_set`, "inputTypes") = c('_p_cappi_psi_struct', 'numeric')
class(`cappi_psi_struct_ivvp_max_age_set`) = c("SWIGFunction", class('cappi_psi_struct_ivvp_max_age_set'))

# Start of cappi_psi_struct_ivvp_max_age_get

`cappi_psi_struct_ivvp_max_age_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  .Call('R_swig_cappi_psi_struct_ivvp_max_age_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`cappi_psi_struct_ivvp_max_age_get`, 'returnType') = 'numeric'
attr(`cappi_psi_struct_ivvp_max_age_get`, "inputTypes") = c('_p_cappi_psi_struct')
class(`cappi_psi_struct_ivvp_max_age_get`) = c("SWIGFunction", class('cappi_psi_struct_ivvp_max_age_get'))

# Start of cappi_psi_struct_ipad_end_set

`cappi_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -28)
  
  .Call('R_swig_cappi_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`cappi_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`cappi_psi_struct_ipad_end_set`, "inputTypes") = c('_p_cappi_psi_struct', '_p_char')
class(`cappi_psi_struct_ipad_end_set`) = c("SWIGFunction", class('cappi_psi_struct_ipad_end_set'))

# Start of cappi_psi_struct_ipad_end_get

`cappi_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  ans = .Call('R_swig_cappi_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`cappi_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`cappi_psi_struct_ipad_end_get`, "inputTypes") = c('_p_cappi_psi_struct')
class(`cappi_psi_struct_ipad_end_get`) = c("SWIGFunction", class('cappi_psi_struct_ipad_end_get'))

# Start of new_cappi_psi_struct

`cappi_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_cappi_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_cappi_psi_struct"
  
  ans
  
}

attr(`cappi_psi_struct`, 'returnType') = '_p_cappi_psi_struct'
class(`cappi_psi_struct`) = c("SWIGFunction", class('cappi_psi_struct'))

# Start of delete_cappi_psi_struct

`delete_cappi_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_cappi_psi_struct") 
  .Call('R_swig_delete_cappi_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_cappi_psi_struct`, 'returnType') = 'void'
attr(`delete_cappi_psi_struct`, "inputTypes") = c('_p_cappi_psi_struct')
class(`delete_cappi_psi_struct`) = c("SWIGFunction", class('delete_cappi_psi_struct'))

# Start of accessor method for cappi_psi_struct
setMethod('$', '_p_cappi_psi_struct', function(x, name)

{
  accessorFuns = list('iShearFlags' = cappi_psi_struct_iShearFlags_get, 'icappi_hgt' = cappi_psi_struct_icappi_hgt_get, 'icappi_flags' = cappi_psi_struct_icappi_flags_get, 'iAzSmooth' = cappi_psi_struct_iAzSmooth_get, 'svvp_name' = cappi_psi_struct_svvp_name_get, 'ivvp_max_age' = cappi_psi_struct_ivvp_max_age_get, 'ipad_end' = cappi_psi_struct_ipad_end_get)
  vaccessors = c('iShearFlags', 'icappi_hgt', 'icappi_flags', 'iAzSmooth', 'svvp_name', 'ivvp_max_age', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for cappi_psi_struct
# Start of accessor method for cappi_psi_struct
setMethod('$<-', '_p_cappi_psi_struct', function(x, name, value)

{
  accessorFuns = list('iShearFlags' = cappi_psi_struct_iShearFlags_set, 'icappi_hgt' = cappi_psi_struct_icappi_hgt_set, 'icappi_flags' = cappi_psi_struct_icappi_flags_set, 'iAzSmooth' = cappi_psi_struct_iAzSmooth_set, 'svvp_name' = cappi_psi_struct_svvp_name_set, 'ivvp_max_age' = cappi_psi_struct_ivvp_max_age_set, 'ipad_end' = cappi_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_cappi_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iShearFlags' = cappi_psi_struct_iShearFlags_set, 'icappi_hgt' = cappi_psi_struct_icappi_hgt_set, 'icappi_flags' = cappi_psi_struct_icappi_flags_set, 'iAzSmooth' = cappi_psi_struct_iAzSmooth_set, 'svvp_name' = cappi_psi_struct_svvp_name_set, 'ivvp_max_age' = cappi_psi_struct_ivvp_max_age_set, 'ipad_end' = cappi_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for cappi_psi_struct
setMethod('delete', '_p_cappi_psi_struct', function(obj) {delete_cappi_psi_struct(obj)})
# Start definition of copy functions & methods for cappi_psi_struct
CopyToR_cappi_psi_struct = function(value, obj = new("cappi_psi_struct"))
{
  obj@iShearFlags = value$iShearFlags
  obj@icappi_hgt = value$icappi_hgt
  obj@svvp_name = value$svvp_name
  obj@ivvp_max_age = value$ivvp_max_age
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_cappi_psi_struct = function(value, obj)
{
  obj$iShearFlags = value@iShearFlags
  obj$icappi_hgt = value@icappi_hgt
  obj$svvp_name = value@svvp_name
  obj$ivvp_max_age = value@ivvp_max_age
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for cappi_psi_struct
setMethod('copyToR', '_p_cappi_psi_struct', CopyToR_cappi_psi_struct)
setMethod('copyToC', 'cappi_psi_struct', CopyToC_cappi_psi_struct)

# End definition of copy methods for cappi_psi_struct
# End definition of copy functions & methods for cappi_psi_struct
# Start of catch_psi_struct_iFlags_set

`catch_psi_struct_iFlags_set` = function(self, s_iFlags)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iFlags = as.numeric(s_iFlags) 
  
  assert(length(s_iFlags) == 1 && s_iFlags >= 0, "All values must be non-negative")
  
  .Call('R_swig_catch_psi_struct_iFlags_set', self, s_iFlags, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iFlags_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iFlags_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iFlags_set`) = c("SWIGFunction", class('catch_psi_struct_iFlags_set'))

# Start of catch_psi_struct_iFlags_get

`catch_psi_struct_iFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iFlags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iFlags_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iFlags_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iFlags_get`) = c("SWIGFunction", class('catch_psi_struct_iFlags_get'))

# Start of catch_psi_struct_iHours_set

`catch_psi_struct_iHours_set` = function(self, s_iHours)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iHours = as.numeric(s_iHours) 
  
  assert(length(s_iHours) == 1 && s_iHours >= 0, "All values must be non-negative")
  
  .Call('R_swig_catch_psi_struct_iHours_set', self, s_iHours, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iHours_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iHours_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iHours_set`) = c("SWIGFunction", class('catch_psi_struct_iHours_set'))

# Start of catch_psi_struct_iHours_get

`catch_psi_struct_iHours_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iHours_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iHours_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iHours_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iHours_get`) = c("SWIGFunction", class('catch_psi_struct_iHours_get'))

# Start of catch_psi_struct_iThresholdOffset_set

`catch_psi_struct_iThresholdOffset_set` = function(self, s_iThresholdOffset)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iThresholdOffset = as.integer(s_iThresholdOffset) 
  
  if(length(s_iThresholdOffset) > 1) {
    Rf_warning("using only the first element of s_iThresholdOffset")
  }
  
  .Call('R_swig_catch_psi_struct_iThresholdOffset_set', self, s_iThresholdOffset, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iThresholdOffset_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iThresholdOffset_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iThresholdOffset_set`) = c("SWIGFunction", class('catch_psi_struct_iThresholdOffset_set'))

# Start of catch_psi_struct_iThresholdOffset_get

`catch_psi_struct_iThresholdOffset_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iThresholdOffset_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iThresholdOffset_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iThresholdOffset_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iThresholdOffset_get`) = c("SWIGFunction", class('catch_psi_struct_iThresholdOffset_get'))

# Start of catch_psi_struct_iThresholdFactor_set

`catch_psi_struct_iThresholdFactor_set` = function(self, s_iThresholdFactor)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iThresholdFactor = as.integer(s_iThresholdFactor) 
  
  if(length(s_iThresholdFactor) > 1) {
    Rf_warning("using only the first element of s_iThresholdFactor")
  }
  
  .Call('R_swig_catch_psi_struct_iThresholdFactor_set', self, s_iThresholdFactor, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iThresholdFactor_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iThresholdFactor_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iThresholdFactor_set`) = c("SWIGFunction", class('catch_psi_struct_iThresholdFactor_set'))

# Start of catch_psi_struct_iThresholdFactor_get

`catch_psi_struct_iThresholdFactor_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iThresholdFactor_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iThresholdFactor_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iThresholdFactor_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iThresholdFactor_get`) = c("SWIGFunction", class('catch_psi_struct_iThresholdFactor_get'))

# Start of catch_psi_struct_sProduct_set

`catch_psi_struct_sProduct_set` = function(self, s_sProduct)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  
  if(is.list(s_sProduct))
  assert(all(sapply(s_sProduct, class) == "_p_char"))     
  
  
#  assert(length(s_sProduct) >= 12)
  
  .Call('R_swig_catch_psi_struct_sProduct_set', self, s_sProduct, PACKAGE='iris')
  
}

attr(`catch_psi_struct_sProduct_set`, 'returnType') = 'void'
attr(`catch_psi_struct_sProduct_set`, "inputTypes") = c('_p_catch_psi_struct', '_p_char')
class(`catch_psi_struct_sProduct_set`) = c("SWIGFunction", class('catch_psi_struct_sProduct_set'))

# Start of catch_psi_struct_sProduct_get

`catch_psi_struct_sProduct_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  ans = .Call('R_swig_catch_psi_struct_sProduct_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`catch_psi_struct_sProduct_get`, 'returnType') = '_p_char'
attr(`catch_psi_struct_sProduct_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_sProduct_get`) = c("SWIGFunction", class('catch_psi_struct_sProduct_get'))

# Start of catch_psi_struct_sSubCatchment_set

`catch_psi_struct_sSubCatchment_set` = function(self, s_sSubCatchment)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  
  if(is.list(s_sSubCatchment))
  assert(all(sapply(s_sSubCatchment, class) == "_p_char"))     
  
  
#  assert(length(s_sSubCatchment) >= 16)
  
  .Call('R_swig_catch_psi_struct_sSubCatchment_set', self, s_sSubCatchment, PACKAGE='iris')
  
}

attr(`catch_psi_struct_sSubCatchment_set`, 'returnType') = 'void'
attr(`catch_psi_struct_sSubCatchment_set`, "inputTypes") = c('_p_catch_psi_struct', '_p_char')
class(`catch_psi_struct_sSubCatchment_set`) = c("SWIGFunction", class('catch_psi_struct_sSubCatchment_set'))

# Start of catch_psi_struct_sSubCatchment_get

`catch_psi_struct_sSubCatchment_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  ans = .Call('R_swig_catch_psi_struct_sSubCatchment_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`catch_psi_struct_sSubCatchment_get`, 'returnType') = '_p_char'
attr(`catch_psi_struct_sSubCatchment_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_sSubCatchment_get`) = c("SWIGFunction", class('catch_psi_struct_sSubCatchment_get'))

# Start of catch_psi_struct_iSpanSeconds_set

`catch_psi_struct_iSpanSeconds_set` = function(self, s_iSpanSeconds)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iSpanSeconds = as.numeric(s_iSpanSeconds) 
  
  assert(length(s_iSpanSeconds) == 1 && s_iSpanSeconds >= 0, "All values must be non-negative")
  
  .Call('R_swig_catch_psi_struct_iSpanSeconds_set', self, s_iSpanSeconds, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iSpanSeconds_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iSpanSeconds_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iSpanSeconds_set`) = c("SWIGFunction", class('catch_psi_struct_iSpanSeconds_set'))

# Start of catch_psi_struct_iSpanSeconds_get

`catch_psi_struct_iSpanSeconds_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iSpanSeconds_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iSpanSeconds_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iSpanSeconds_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iSpanSeconds_get`) = c("SWIGFunction", class('catch_psi_struct_iSpanSeconds_get'))

# Start of catch_psi_struct_iRain1MinZ_set

`catch_psi_struct_iRain1MinZ_set` = function(self, s_iRain1MinZ)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iRain1MinZ = as.numeric(s_iRain1MinZ) 
  
  assert(length(s_iRain1MinZ) == 1 && s_iRain1MinZ >= 0, "All values must be non-negative")
  
  .Call('R_swig_catch_psi_struct_iRain1MinZ_set', self, s_iRain1MinZ, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iRain1MinZ_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iRain1MinZ_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iRain1MinZ_set`) = c("SWIGFunction", class('catch_psi_struct_iRain1MinZ_set'))

# Start of catch_psi_struct_iRain1MinZ_get

`catch_psi_struct_iRain1MinZ_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iRain1MinZ_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iRain1MinZ_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iRain1MinZ_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iRain1MinZ_get`) = c("SWIGFunction", class('catch_psi_struct_iRain1MinZ_get'))

# Start of catch_psi_struct_iRain1Span_set

`catch_psi_struct_iRain1Span_set` = function(self, s_iRain1Span)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iRain1Span = as.numeric(s_iRain1Span) 
  
  assert(length(s_iRain1Span) == 1 && s_iRain1Span >= 0, "All values must be non-negative")
  
  .Call('R_swig_catch_psi_struct_iRain1Span_set', self, s_iRain1Span, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iRain1Span_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iRain1Span_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iRain1Span_set`) = c("SWIGFunction", class('catch_psi_struct_iRain1Span_set'))

# Start of catch_psi_struct_iRain1Span_get

`catch_psi_struct_iRain1Span_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iRain1Span_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iRain1Span_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iRain1Span_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iRain1Span_get`) = c("SWIGFunction", class('catch_psi_struct_iRain1Span_get'))

# Start of catch_psi_struct_iGageFactor_set

`catch_psi_struct_iGageFactor_set` = function(self, s_iGageFactor)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  s_iGageFactor = as.numeric(s_iGageFactor) 
  
  assert(length(s_iGageFactor) == 1 && s_iGageFactor >= 0, "All values must be non-negative")
  
  .Call('R_swig_catch_psi_struct_iGageFactor_set', self, s_iGageFactor, PACKAGE='iris')
  
}

attr(`catch_psi_struct_iGageFactor_set`, 'returnType') = 'void'
attr(`catch_psi_struct_iGageFactor_set`, "inputTypes") = c('_p_catch_psi_struct', 'numeric')
class(`catch_psi_struct_iGageFactor_set`) = c("SWIGFunction", class('catch_psi_struct_iGageFactor_set'))

# Start of catch_psi_struct_iGageFactor_get

`catch_psi_struct_iGageFactor_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_catch_psi_struct_iGageFactor_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`catch_psi_struct_iGageFactor_get`, 'returnType') = 'numeric'
attr(`catch_psi_struct_iGageFactor_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_iGageFactor_get`) = c("SWIGFunction", class('catch_psi_struct_iGageFactor_get'))

# Start of catch_psi_struct_ipad_end_set

`catch_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -60)
  
  .Call('R_swig_catch_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`catch_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`catch_psi_struct_ipad_end_set`, "inputTypes") = c('_p_catch_psi_struct', '_p_char')
class(`catch_psi_struct_ipad_end_set`) = c("SWIGFunction", class('catch_psi_struct_ipad_end_set'))

# Start of catch_psi_struct_ipad_end_get

`catch_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  ans = .Call('R_swig_catch_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`catch_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`catch_psi_struct_ipad_end_get`, "inputTypes") = c('_p_catch_psi_struct')
class(`catch_psi_struct_ipad_end_get`) = c("SWIGFunction", class('catch_psi_struct_ipad_end_get'))

# Start of new_catch_psi_struct

`catch_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_catch_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_catch_psi_struct"
  
  ans
  
}

attr(`catch_psi_struct`, 'returnType') = '_p_catch_psi_struct'
class(`catch_psi_struct`) = c("SWIGFunction", class('catch_psi_struct'))

# Start of delete_catch_psi_struct

`delete_catch_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_catch_psi_struct") 
  .Call('R_swig_delete_catch_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_catch_psi_struct`, 'returnType') = 'void'
attr(`delete_catch_psi_struct`, "inputTypes") = c('_p_catch_psi_struct')
class(`delete_catch_psi_struct`) = c("SWIGFunction", class('delete_catch_psi_struct'))

# Start of accessor method for catch_psi_struct
setMethod('$', '_p_catch_psi_struct', function(x, name)

{
  accessorFuns = list('iFlags' = catch_psi_struct_iFlags_get, 'iHours' = catch_psi_struct_iHours_get, 'iThresholdOffset' = catch_psi_struct_iThresholdOffset_get, 'iThresholdFactor' = catch_psi_struct_iThresholdFactor_get, 'sProduct' = catch_psi_struct_sProduct_get, 'sSubCatchment' = catch_psi_struct_sSubCatchment_get, 'iSpanSeconds' = catch_psi_struct_iSpanSeconds_get, 'iRain1MinZ' = catch_psi_struct_iRain1MinZ_get, 'iRain1Span' = catch_psi_struct_iRain1Span_get, 'iGageFactor' = catch_psi_struct_iGageFactor_get, 'ipad_end' = catch_psi_struct_ipad_end_get)
  vaccessors = c('iFlags', 'iHours', 'iThresholdOffset', 'iThresholdFactor', 'sProduct', 'sSubCatchment', 'iSpanSeconds', 'iRain1MinZ', 'iRain1Span', 'iGageFactor', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for catch_psi_struct
# Start of accessor method for catch_psi_struct
setMethod('$<-', '_p_catch_psi_struct', function(x, name, value)

{
  accessorFuns = list('iFlags' = catch_psi_struct_iFlags_set, 'iHours' = catch_psi_struct_iHours_set, 'iThresholdOffset' = catch_psi_struct_iThresholdOffset_set, 'iThresholdFactor' = catch_psi_struct_iThresholdFactor_set, 'sProduct' = catch_psi_struct_sProduct_set, 'sSubCatchment' = catch_psi_struct_sSubCatchment_set, 'iSpanSeconds' = catch_psi_struct_iSpanSeconds_set, 'iRain1MinZ' = catch_psi_struct_iRain1MinZ_set, 'iRain1Span' = catch_psi_struct_iRain1Span_set, 'iGageFactor' = catch_psi_struct_iGageFactor_set, 'ipad_end' = catch_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_catch_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iFlags' = catch_psi_struct_iFlags_set, 'iHours' = catch_psi_struct_iHours_set, 'iThresholdOffset' = catch_psi_struct_iThresholdOffset_set, 'iThresholdFactor' = catch_psi_struct_iThresholdFactor_set, 'sProduct' = catch_psi_struct_sProduct_set, 'sSubCatchment' = catch_psi_struct_sSubCatchment_set, 'iSpanSeconds' = catch_psi_struct_iSpanSeconds_set, 'iRain1MinZ' = catch_psi_struct_iRain1MinZ_set, 'iRain1Span' = catch_psi_struct_iRain1Span_set, 'iGageFactor' = catch_psi_struct_iGageFactor_set, 'ipad_end' = catch_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for catch_psi_struct
setMethod('delete', '_p_catch_psi_struct', function(obj) {delete_catch_psi_struct(obj)})
# Start definition of copy functions & methods for catch_psi_struct
CopyToR_catch_psi_struct = function(value, obj = new("catch_psi_struct"))
{
  obj@iFlags = value$iFlags
  obj@iHours = value$iHours
  obj@iThresholdOffset = value$iThresholdOffset
  obj@iThresholdFactor = value$iThresholdFactor
  obj@sProduct = value$sProduct
  obj@sSubCatchment = value$sSubCatchment
  obj@iSpanSeconds = value$iSpanSeconds
  obj@iRain1MinZ = value$iRain1MinZ
  obj@iRain1Span = value$iRain1Span
  obj@iGageFactor = value$iGageFactor
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_catch_psi_struct = function(value, obj)
{
  obj$iFlags = value@iFlags
  obj$iHours = value@iHours
  obj$iThresholdOffset = value@iThresholdOffset
  obj$iThresholdFactor = value@iThresholdFactor
  obj$sProduct = value@sProduct
  obj$sSubCatchment = value@sSubCatchment
  obj$iSpanSeconds = value@iSpanSeconds
  obj$iRain1MinZ = value@iRain1MinZ
  obj$iRain1Span = value@iRain1Span
  obj$iGageFactor = value@iGageFactor
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for catch_psi_struct
setMethod('copyToR', '_p_catch_psi_struct', CopyToR_catch_psi_struct)
setMethod('copyToC', 'catch_psi_struct', CopyToC_catch_psi_struct)

# End definition of copy methods for catch_psi_struct
# End definition of copy functions & methods for catch_psi_struct
# Start of comp_psi_struct_iPTypeIn_set

`comp_psi_struct_iPTypeIn_set` = function(self, s_iPTypeIn)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  s_iPTypeIn = coerceIfNotSubclass(s_iPTypeIn, "_p_unsigned_char") 
  .Call('R_swig_comp_psi_struct_iPTypeIn_set', self, s_iPTypeIn, PACKAGE='iris')
  
}

attr(`comp_psi_struct_iPTypeIn_set`, 'returnType') = 'void'
attr(`comp_psi_struct_iPTypeIn_set`, "inputTypes") = c('_p_comp_psi_struct', '_p_unsigned_char')
class(`comp_psi_struct_iPTypeIn_set`) = c("SWIGFunction", class('comp_psi_struct_iPTypeIn_set'))

# Start of comp_psi_struct_iPTypeIn_get

`comp_psi_struct_iPTypeIn_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  ans = .Call('R_swig_comp_psi_struct_iPTypeIn_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`comp_psi_struct_iPTypeIn_get`, 'returnType') = '_p_unsigned_char'
attr(`comp_psi_struct_iPTypeIn_get`, "inputTypes") = c('_p_comp_psi_struct')
class(`comp_psi_struct_iPTypeIn_get`) = c("SWIGFunction", class('comp_psi_struct_iPTypeIn_get'))

# Start of comp_psi_struct_iCombineScheme_set

`comp_psi_struct_iCombineScheme_set` = function(self, s_iCombineScheme)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  s_iCombineScheme = coerceIfNotSubclass(s_iCombineScheme, "_p_unsigned_char") 
  .Call('R_swig_comp_psi_struct_iCombineScheme_set', self, s_iCombineScheme, PACKAGE='iris')
  
}

attr(`comp_psi_struct_iCombineScheme_set`, 'returnType') = 'void'
attr(`comp_psi_struct_iCombineScheme_set`, "inputTypes") = c('_p_comp_psi_struct', '_p_unsigned_char')
class(`comp_psi_struct_iCombineScheme_set`) = c("SWIGFunction", class('comp_psi_struct_iCombineScheme_set'))

# Start of comp_psi_struct_iCombineScheme_get

`comp_psi_struct_iCombineScheme_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  ans = .Call('R_swig_comp_psi_struct_iCombineScheme_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`comp_psi_struct_iCombineScheme_get`, 'returnType') = '_p_unsigned_char'
attr(`comp_psi_struct_iCombineScheme_get`, "inputTypes") = c('_p_comp_psi_struct')
class(`comp_psi_struct_iCombineScheme_get`) = c("SWIGFunction", class('comp_psi_struct_iCombineScheme_get'))

# Start of comp_psi_struct_iTimeSpan_set

`comp_psi_struct_iTimeSpan_set` = function(self, s_iTimeSpan)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  s_iTimeSpan = coerceIfNotSubclass(s_iTimeSpan, "_p_unsigned_short") 
  .Call('R_swig_comp_psi_struct_iTimeSpan_set', self, s_iTimeSpan, PACKAGE='iris')
  
}

attr(`comp_psi_struct_iTimeSpan_set`, 'returnType') = 'void'
attr(`comp_psi_struct_iTimeSpan_set`, "inputTypes") = c('_p_comp_psi_struct', '_p_unsigned_short')
class(`comp_psi_struct_iTimeSpan_set`) = c("SWIGFunction", class('comp_psi_struct_iTimeSpan_set'))

# Start of comp_psi_struct_iTimeSpan_get

`comp_psi_struct_iTimeSpan_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  ans = .Call('R_swig_comp_psi_struct_iTimeSpan_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`comp_psi_struct_iTimeSpan_get`, 'returnType') = '_p_unsigned_short'
attr(`comp_psi_struct_iTimeSpan_get`, "inputTypes") = c('_p_comp_psi_struct')
class(`comp_psi_struct_iTimeSpan_get`) = c("SWIGFunction", class('comp_psi_struct_iTimeSpan_get'))

# Start of comp_psi_struct_sPNameIn_set

`comp_psi_struct_sPNameIn_set` = function(self, s_sPNameIn)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  
  if(is.list(s_sPNameIn))
  assert(all(sapply(s_sPNameIn, class) == "_p_char"))     
  
  
#  assert(length(s_sPNameIn) >= 12)
  
  .Call('R_swig_comp_psi_struct_sPNameIn_set', self, s_sPNameIn, PACKAGE='iris')
  
}

attr(`comp_psi_struct_sPNameIn_set`, 'returnType') = 'void'
attr(`comp_psi_struct_sPNameIn_set`, "inputTypes") = c('_p_comp_psi_struct', '_p_char')
class(`comp_psi_struct_sPNameIn_set`) = c("SWIGFunction", class('comp_psi_struct_sPNameIn_set'))

# Start of comp_psi_struct_sPNameIn_get

`comp_psi_struct_sPNameIn_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  ans = .Call('R_swig_comp_psi_struct_sPNameIn_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`comp_psi_struct_sPNameIn_get`, 'returnType') = '_p_char'
attr(`comp_psi_struct_sPNameIn_get`, "inputTypes") = c('_p_comp_psi_struct')
class(`comp_psi_struct_sPNameIn_get`) = c("SWIGFunction", class('comp_psi_struct_sPNameIn_get'))

# Start of comp_psi_struct_sSiteOut_set

`comp_psi_struct_sSiteOut_set` = function(self, s_sSiteOut)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  
  if(is.list(s_sSiteOut))
  assert(all(sapply(s_sSiteOut, class) == "_p_char"))     
  
  
#  assert(length(s_sSiteOut) >= 4)
  
  .Call('R_swig_comp_psi_struct_sSiteOut_set', self, s_sSiteOut, PACKAGE='iris')
  
}

attr(`comp_psi_struct_sSiteOut_set`, 'returnType') = 'void'
attr(`comp_psi_struct_sSiteOut_set`, "inputTypes") = c('_p_comp_psi_struct', '_p_char')
class(`comp_psi_struct_sSiteOut_set`) = c("SWIGFunction", class('comp_psi_struct_sSiteOut_set'))

# Start of comp_psi_struct_sSiteOut_get

`comp_psi_struct_sSiteOut_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  ans = .Call('R_swig_comp_psi_struct_sSiteOut_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`comp_psi_struct_sSiteOut_get`, 'returnType') = '_p_char'
attr(`comp_psi_struct_sSiteOut_get`, "inputTypes") = c('_p_comp_psi_struct')
class(`comp_psi_struct_sSiteOut_get`) = c("SWIGFunction", class('comp_psi_struct_sSiteOut_get'))

# Start of comp_psi_struct_sSiteInList_set

`comp_psi_struct_sSiteInList_set` = function(self, s_sSiteInList)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  
  if(is.list(s_sSiteInList))
  assert(all(sapply(s_sSiteInList, class) == "_p_a_3__char"))     
  
  
#  assert(length(s_sSiteInList) >= 16)
  
  .Call('R_swig_comp_psi_struct_sSiteInList_set', self, s_sSiteInList, PACKAGE='iris')
  
}

attr(`comp_psi_struct_sSiteInList_set`, 'returnType') = 'void'
attr(`comp_psi_struct_sSiteInList_set`, "inputTypes") = c('_p_comp_psi_struct', '_p_a_3__char')
class(`comp_psi_struct_sSiteInList_set`) = c("SWIGFunction", class('comp_psi_struct_sSiteInList_set'))

# Start of comp_psi_struct_sSiteInList_get

`comp_psi_struct_sSiteInList_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  ans = .Call('R_swig_comp_psi_struct_sSiteInList_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_a_3__char"
  
  ans
  
}

attr(`comp_psi_struct_sSiteInList_get`, 'returnType') = '_p_a_3__char'
attr(`comp_psi_struct_sSiteInList_get`, "inputTypes") = c('_p_comp_psi_struct')
class(`comp_psi_struct_sSiteInList_get`) = c("SWIGFunction", class('comp_psi_struct_sSiteInList_get'))

# Start of comp_psi_struct_ipad_end_set

`comp_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -68)
  
  .Call('R_swig_comp_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`comp_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`comp_psi_struct_ipad_end_set`, "inputTypes") = c('_p_comp_psi_struct', '_p_char')
class(`comp_psi_struct_ipad_end_set`) = c("SWIGFunction", class('comp_psi_struct_ipad_end_set'))

# Start of comp_psi_struct_ipad_end_get

`comp_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  ans = .Call('R_swig_comp_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`comp_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`comp_psi_struct_ipad_end_get`, "inputTypes") = c('_p_comp_psi_struct')
class(`comp_psi_struct_ipad_end_get`) = c("SWIGFunction", class('comp_psi_struct_ipad_end_get'))

# Start of new_comp_psi_struct

`comp_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_comp_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_comp_psi_struct"
  
  ans
  
}

attr(`comp_psi_struct`, 'returnType') = '_p_comp_psi_struct'
class(`comp_psi_struct`) = c("SWIGFunction", class('comp_psi_struct'))

# Start of delete_comp_psi_struct

`delete_comp_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_comp_psi_struct") 
  .Call('R_swig_delete_comp_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_comp_psi_struct`, 'returnType') = 'void'
attr(`delete_comp_psi_struct`, "inputTypes") = c('_p_comp_psi_struct')
class(`delete_comp_psi_struct`) = c("SWIGFunction", class('delete_comp_psi_struct'))

# Start of accessor method for comp_psi_struct
setMethod('$', '_p_comp_psi_struct', function(x, name)

{
  accessorFuns = list('iPTypeIn' = comp_psi_struct_iPTypeIn_get, 'iCombineScheme' = comp_psi_struct_iCombineScheme_get, 'iTimeSpan' = comp_psi_struct_iTimeSpan_get, 'sPNameIn' = comp_psi_struct_sPNameIn_get, 'sSiteOut' = comp_psi_struct_sSiteOut_get, 'sSiteInList' = comp_psi_struct_sSiteInList_get, 'ipad_end' = comp_psi_struct_ipad_end_get)
  vaccessors = c('iPTypeIn', 'iCombineScheme', 'iTimeSpan', 'sPNameIn', 'sSiteOut', 'sSiteInList', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for comp_psi_struct
# Start of accessor method for comp_psi_struct
setMethod('$<-', '_p_comp_psi_struct', function(x, name, value)

{
  accessorFuns = list('iPTypeIn' = comp_psi_struct_iPTypeIn_set, 'iCombineScheme' = comp_psi_struct_iCombineScheme_set, 'iTimeSpan' = comp_psi_struct_iTimeSpan_set, 'sPNameIn' = comp_psi_struct_sPNameIn_set, 'sSiteOut' = comp_psi_struct_sSiteOut_set, 'sSiteInList' = comp_psi_struct_sSiteInList_set, 'ipad_end' = comp_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_comp_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iPTypeIn' = comp_psi_struct_iPTypeIn_set, 'iCombineScheme' = comp_psi_struct_iCombineScheme_set, 'iTimeSpan' = comp_psi_struct_iTimeSpan_set, 'sPNameIn' = comp_psi_struct_sPNameIn_set, 'sSiteOut' = comp_psi_struct_sSiteOut_set, 'sSiteInList' = comp_psi_struct_sSiteInList_set, 'ipad_end' = comp_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for comp_psi_struct
setMethod('delete', '_p_comp_psi_struct', function(obj) {delete_comp_psi_struct(obj)})
# Start definition of copy functions & methods for comp_psi_struct
CopyToR_comp_psi_struct = function(value, obj = new("comp_psi_struct"))
{
  obj@sPNameIn = value$sPNameIn
  obj@sSiteOut = value$sSiteOut
  obj@sSiteInList = value$sSiteInList
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_comp_psi_struct = function(value, obj)
{
  obj$sPNameIn = value@sPNameIn
  obj$sSiteOut = value@sSiteOut
  obj$sSiteInList = value@sSiteInList
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for comp_psi_struct
setMethod('copyToR', '_p_comp_psi_struct', CopyToR_comp_psi_struct)
setMethod('copyToC', 'comp_psi_struct', CopyToC_comp_psi_struct)

# End definition of copy methods for comp_psi_struct
# End definition of copy functions & methods for comp_psi_struct
# Start of cross_psi_struct_iazimuth_set

`cross_psi_struct_iazimuth_set` = function(self, s_iazimuth)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  s_iazimuth = coerceIfNotSubclass(s_iazimuth, "_p_unsigned_short") 
  .Call('R_swig_cross_psi_struct_iazimuth_set', self, s_iazimuth, PACKAGE='iris')
  
}

attr(`cross_psi_struct_iazimuth_set`, 'returnType') = 'void'
attr(`cross_psi_struct_iazimuth_set`, "inputTypes") = c('_p_cross_psi_struct', '_p_unsigned_short')
class(`cross_psi_struct_iazimuth_set`) = c("SWIGFunction", class('cross_psi_struct_iazimuth_set'))

# Start of cross_psi_struct_iazimuth_get

`cross_psi_struct_iazimuth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  ans = .Call('R_swig_cross_psi_struct_iazimuth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`cross_psi_struct_iazimuth_get`, 'returnType') = '_p_unsigned_short'
attr(`cross_psi_struct_iazimuth_get`, "inputTypes") = c('_p_cross_psi_struct')
class(`cross_psi_struct_iazimuth_get`) = c("SWIGFunction", class('cross_psi_struct_iazimuth_get'))

# Start of cross_psi_struct_ipad2x10_set

`cross_psi_struct_ipad2x10_set` = function(self, s_ipad2x10)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  
  if(is.list(s_ipad2x10))
  assert(all(sapply(s_ipad2x10, class) == "_p_char"))     
  
  
#  assert(length(s_ipad2x10) >= 10)
  
  .Call('R_swig_cross_psi_struct_ipad2x10_set', self, s_ipad2x10, PACKAGE='iris')
  
}

attr(`cross_psi_struct_ipad2x10_set`, 'returnType') = 'void'
attr(`cross_psi_struct_ipad2x10_set`, "inputTypes") = c('_p_cross_psi_struct', '_p_char')
class(`cross_psi_struct_ipad2x10_set`) = c("SWIGFunction", class('cross_psi_struct_ipad2x10_set'))

# Start of cross_psi_struct_ipad2x10_get

`cross_psi_struct_ipad2x10_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  ans = .Call('R_swig_cross_psi_struct_ipad2x10_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`cross_psi_struct_ipad2x10_get`, 'returnType') = '_p_char'
attr(`cross_psi_struct_ipad2x10_get`, "inputTypes") = c('_p_cross_psi_struct')
class(`cross_psi_struct_ipad2x10_get`) = c("SWIGFunction", class('cross_psi_struct_ipad2x10_get'))

# Start of cross_psi_struct_icenterx_set

`cross_psi_struct_icenterx_set` = function(self, s_icenterx)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  s_icenterx = as.integer(s_icenterx) 
  
  if(length(s_icenterx) > 1) {
    Rf_warning("using only the first element of s_icenterx")
  }
  
  .Call('R_swig_cross_psi_struct_icenterx_set', self, s_icenterx, PACKAGE='iris')
  
}

attr(`cross_psi_struct_icenterx_set`, 'returnType') = 'void'
attr(`cross_psi_struct_icenterx_set`, "inputTypes") = c('_p_cross_psi_struct', 'numeric')
class(`cross_psi_struct_icenterx_set`) = c("SWIGFunction", class('cross_psi_struct_icenterx_set'))

# Start of cross_psi_struct_icenterx_get

`cross_psi_struct_icenterx_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  .Call('R_swig_cross_psi_struct_icenterx_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`cross_psi_struct_icenterx_get`, 'returnType') = 'numeric'
attr(`cross_psi_struct_icenterx_get`, "inputTypes") = c('_p_cross_psi_struct')
class(`cross_psi_struct_icenterx_get`) = c("SWIGFunction", class('cross_psi_struct_icenterx_get'))

# Start of cross_psi_struct_icentery_set

`cross_psi_struct_icentery_set` = function(self, s_icentery)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  s_icentery = as.integer(s_icentery) 
  
  if(length(s_icentery) > 1) {
    Rf_warning("using only the first element of s_icentery")
  }
  
  .Call('R_swig_cross_psi_struct_icentery_set', self, s_icentery, PACKAGE='iris')
  
}

attr(`cross_psi_struct_icentery_set`, 'returnType') = 'void'
attr(`cross_psi_struct_icentery_set`, "inputTypes") = c('_p_cross_psi_struct', 'numeric')
class(`cross_psi_struct_icentery_set`) = c("SWIGFunction", class('cross_psi_struct_icentery_set'))

# Start of cross_psi_struct_icentery_get

`cross_psi_struct_icentery_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  .Call('R_swig_cross_psi_struct_icentery_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`cross_psi_struct_icentery_get`, 'returnType') = 'numeric'
attr(`cross_psi_struct_icentery_get`, "inputTypes") = c('_p_cross_psi_struct')
class(`cross_psi_struct_icentery_get`) = c("SWIGFunction", class('cross_psi_struct_icentery_get'))

# Start of cross_psi_struct_ivuser_misc_set

`cross_psi_struct_ivuser_misc_set` = function(self, s_ivuser_misc)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  s_ivuser_misc = as.integer(s_ivuser_misc) 
  
#  assert(length(s_ivuser_misc) >= ((80) -20)/4)
  
  .Call('R_swig_cross_psi_struct_ivuser_misc_set', self, s_ivuser_misc, PACKAGE='iris')
  
}

attr(`cross_psi_struct_ivuser_misc_set`, 'returnType') = 'void'
attr(`cross_psi_struct_ivuser_misc_set`, "inputTypes") = c('_p_cross_psi_struct', '_p_int')
class(`cross_psi_struct_ivuser_misc_set`) = c("SWIGFunction", class('cross_psi_struct_ivuser_misc_set'))

# Start of cross_psi_struct_ivuser_misc_get

`cross_psi_struct_ivuser_misc_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  ans = .Call('R_swig_cross_psi_struct_ivuser_misc_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_int"
  
  ans
  
}

attr(`cross_psi_struct_ivuser_misc_get`, 'returnType') = '_p_int'
attr(`cross_psi_struct_ivuser_misc_get`, "inputTypes") = c('_p_cross_psi_struct')
class(`cross_psi_struct_ivuser_misc_get`) = c("SWIGFunction", class('cross_psi_struct_ivuser_misc_get'))

# Start of new_cross_psi_struct

`cross_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_cross_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_cross_psi_struct"
  
  ans
  
}

attr(`cross_psi_struct`, 'returnType') = '_p_cross_psi_struct'
class(`cross_psi_struct`) = c("SWIGFunction", class('cross_psi_struct'))

# Start of delete_cross_psi_struct

`delete_cross_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_cross_psi_struct") 
  .Call('R_swig_delete_cross_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_cross_psi_struct`, 'returnType') = 'void'
attr(`delete_cross_psi_struct`, "inputTypes") = c('_p_cross_psi_struct')
class(`delete_cross_psi_struct`) = c("SWIGFunction", class('delete_cross_psi_struct'))

# Start of accessor method for cross_psi_struct
setMethod('$', '_p_cross_psi_struct', function(x, name)

{
  accessorFuns = list('iazimuth' = cross_psi_struct_iazimuth_get, 'ipad2x10' = cross_psi_struct_ipad2x10_get, 'icenterx' = cross_psi_struct_icenterx_get, 'icentery' = cross_psi_struct_icentery_get, 'ivuser_misc' = cross_psi_struct_ivuser_misc_get)
  vaccessors = c('iazimuth', 'ipad2x10', 'icenterx', 'icentery', 'ivuser_misc')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for cross_psi_struct
# Start of accessor method for cross_psi_struct
setMethod('$<-', '_p_cross_psi_struct', function(x, name, value)

{
  accessorFuns = list('iazimuth' = cross_psi_struct_iazimuth_set, 'ipad2x10' = cross_psi_struct_ipad2x10_set, 'icenterx' = cross_psi_struct_icenterx_set, 'icentery' = cross_psi_struct_icentery_set, 'ivuser_misc' = cross_psi_struct_ivuser_misc_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_cross_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iazimuth' = cross_psi_struct_iazimuth_set, 'ipad2x10' = cross_psi_struct_ipad2x10_set, 'icenterx' = cross_psi_struct_icenterx_set, 'icentery' = cross_psi_struct_icentery_set, 'ivuser_misc' = cross_psi_struct_ivuser_misc_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for cross_psi_struct
setMethod('delete', '_p_cross_psi_struct', function(obj) {delete_cross_psi_struct(obj)})
# Start definition of copy functions & methods for cross_psi_struct
CopyToR_cross_psi_struct = function(value, obj = new("cross_psi_struct"))
{
  obj@ipad2x10 = value$ipad2x10
  obj@icenterx = value$icenterx
  obj@icentery = value$icentery
  obj@ivuser_misc = value$ivuser_misc
  obj
}



CopyToC_cross_psi_struct = function(value, obj)
{
  obj$ipad2x10 = value@ipad2x10
  obj$icenterx = value@icenterx
  obj$icentery = value@icentery
  obj$ivuser_misc = value@ivuser_misc
  obj
}



# Start definition of copy methods for cross_psi_struct
setMethod('copyToR', '_p_cross_psi_struct', CopyToR_cross_psi_struct)
setMethod('copyToC', 'cross_psi_struct', CopyToC_cross_psi_struct)

# End definition of copy methods for cross_psi_struct
# End definition of copy functions & methods for cross_psi_struct
# Start of dwell_target_psi_iDirLeft_set

`dwell_target_psi_iDirLeft_set` = function(self, s_iDirLeft)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iDirLeft = coerceIfNotSubclass(s_iDirLeft, "_p_unsigned_short") 
  .Call('R_swig_dwell_target_psi_iDirLeft_set', self, s_iDirLeft, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iDirLeft_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iDirLeft_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_unsigned_short')
class(`dwell_target_psi_iDirLeft_set`) = c("SWIGFunction", class('dwell_target_psi_iDirLeft_set'))

# Start of dwell_target_psi_iDirLeft_get

`dwell_target_psi_iDirLeft_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iDirLeft_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`dwell_target_psi_iDirLeft_get`, 'returnType') = '_p_unsigned_short'
attr(`dwell_target_psi_iDirLeft_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iDirLeft_get`) = c("SWIGFunction", class('dwell_target_psi_iDirLeft_get'))

# Start of dwell_target_psi_iDirRight_set

`dwell_target_psi_iDirRight_set` = function(self, s_iDirRight)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iDirRight = coerceIfNotSubclass(s_iDirRight, "_p_unsigned_short") 
  .Call('R_swig_dwell_target_psi_iDirRight_set', self, s_iDirRight, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iDirRight_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iDirRight_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_unsigned_short')
class(`dwell_target_psi_iDirRight_set`) = c("SWIGFunction", class('dwell_target_psi_iDirRight_set'))

# Start of dwell_target_psi_iDirRight_get

`dwell_target_psi_iDirRight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iDirRight_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`dwell_target_psi_iDirRight_get`, 'returnType') = '_p_unsigned_short'
attr(`dwell_target_psi_iDirRight_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iDirRight_get`) = c("SWIGFunction", class('dwell_target_psi_iDirRight_get'))

# Start of dwell_target_psi_iSpeedMin_set

`dwell_target_psi_iSpeedMin_set` = function(self, s_iSpeedMin)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iSpeedMin = coerceIfNotSubclass(s_iSpeedMin, "_p_unsigned_short") 
  .Call('R_swig_dwell_target_psi_iSpeedMin_set', self, s_iSpeedMin, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iSpeedMin_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iSpeedMin_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_unsigned_short')
class(`dwell_target_psi_iSpeedMin_set`) = c("SWIGFunction", class('dwell_target_psi_iSpeedMin_set'))

# Start of dwell_target_psi_iSpeedMin_get

`dwell_target_psi_iSpeedMin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iSpeedMin_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`dwell_target_psi_iSpeedMin_get`, 'returnType') = '_p_unsigned_short'
attr(`dwell_target_psi_iSpeedMin_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iSpeedMin_get`) = c("SWIGFunction", class('dwell_target_psi_iSpeedMin_get'))

# Start of dwell_target_psi_iSpeedMax_set

`dwell_target_psi_iSpeedMax_set` = function(self, s_iSpeedMax)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iSpeedMax = coerceIfNotSubclass(s_iSpeedMax, "_p_unsigned_short") 
  .Call('R_swig_dwell_target_psi_iSpeedMax_set', self, s_iSpeedMax, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iSpeedMax_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iSpeedMax_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_unsigned_short')
class(`dwell_target_psi_iSpeedMax_set`) = c("SWIGFunction", class('dwell_target_psi_iSpeedMax_set'))

# Start of dwell_target_psi_iSpeedMax_get

`dwell_target_psi_iSpeedMax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iSpeedMax_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`dwell_target_psi_iSpeedMax_get`, 'returnType') = '_p_unsigned_short'
attr(`dwell_target_psi_iSpeedMax_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iSpeedMax_get`) = c("SWIGFunction", class('dwell_target_psi_iSpeedMax_get'))

# Start of dwell_target_psi_iProtectMask_set

`dwell_target_psi_iProtectMask_set` = function(self, s_iProtectMask)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iProtectMask = as.numeric(s_iProtectMask) 
  
  assert(length(s_iProtectMask) == 1 && s_iProtectMask >= 0, "All values must be non-negative")
  
  .Call('R_swig_dwell_target_psi_iProtectMask_set', self, s_iProtectMask, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iProtectMask_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iProtectMask_set`, "inputTypes") = c('_p_dwell_target_psi', 'numeric')
class(`dwell_target_psi_iProtectMask_set`) = c("SWIGFunction", class('dwell_target_psi_iProtectMask_set'))

# Start of dwell_target_psi_iProtectMask_get

`dwell_target_psi_iProtectMask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  .Call('R_swig_dwell_target_psi_iProtectMask_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_target_psi_iProtectMask_get`, 'returnType') = 'numeric'
attr(`dwell_target_psi_iProtectMask_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iProtectMask_get`) = c("SWIGFunction", class('dwell_target_psi_iProtectMask_get'))

# Start of dwell_target_psi_sWarnSymbol_set

`dwell_target_psi_sWarnSymbol_set` = function(self, s_sWarnSymbol)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  
  if(is.list(s_sWarnSymbol))
  assert(all(sapply(s_sWarnSymbol, class) == "_p_char"))     
  
  
#  assert(length(s_sWarnSymbol) >= 12)
  
  .Call('R_swig_dwell_target_psi_sWarnSymbol_set', self, s_sWarnSymbol, PACKAGE='iris')
  
}

attr(`dwell_target_psi_sWarnSymbol_set`, 'returnType') = 'void'
attr(`dwell_target_psi_sWarnSymbol_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_char')
class(`dwell_target_psi_sWarnSymbol_set`) = c("SWIGFunction", class('dwell_target_psi_sWarnSymbol_set'))

# Start of dwell_target_psi_sWarnSymbol_get

`dwell_target_psi_sWarnSymbol_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_sWarnSymbol_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`dwell_target_psi_sWarnSymbol_get`, 'returnType') = '_p_char'
attr(`dwell_target_psi_sWarnSymbol_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_sWarnSymbol_get`) = c("SWIGFunction", class('dwell_target_psi_sWarnSymbol_get'))

# Start of dwell_target_psi_iPileThreshold_set

`dwell_target_psi_iPileThreshold_set` = function(self, s_iPileThreshold)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iPileThreshold = coerceIfNotSubclass(s_iPileThreshold, "_p_short") 
  .Call('R_swig_dwell_target_psi_iPileThreshold_set', self, s_iPileThreshold, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iPileThreshold_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iPileThreshold_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_short')
class(`dwell_target_psi_iPileThreshold_set`) = c("SWIGFunction", class('dwell_target_psi_iPileThreshold_set'))

# Start of dwell_target_psi_iPileThreshold_get

`dwell_target_psi_iPileThreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iPileThreshold_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`dwell_target_psi_iPileThreshold_get`, 'returnType') = '_p_short'
attr(`dwell_target_psi_iPileThreshold_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iPileThreshold_get`) = c("SWIGFunction", class('dwell_target_psi_iPileThreshold_get'))

# Start of dwell_target_psi_iMergeRange_set

`dwell_target_psi_iMergeRange_set` = function(self, s_iMergeRange)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iMergeRange = coerceIfNotSubclass(s_iMergeRange, "_p_unsigned_char") 
  .Call('R_swig_dwell_target_psi_iMergeRange_set', self, s_iMergeRange, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iMergeRange_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iMergeRange_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_unsigned_char')
class(`dwell_target_psi_iMergeRange_set`) = c("SWIGFunction", class('dwell_target_psi_iMergeRange_set'))

# Start of dwell_target_psi_iMergeRange_get

`dwell_target_psi_iMergeRange_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iMergeRange_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`dwell_target_psi_iMergeRange_get`, 'returnType') = '_p_unsigned_char'
attr(`dwell_target_psi_iMergeRange_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iMergeRange_get`) = c("SWIGFunction", class('dwell_target_psi_iMergeRange_get'))

# Start of dwell_target_psi_ipad27x1_set

`dwell_target_psi_ipad27x1_set` = function(self, s_ipad27x1)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_ipad27x1 = as(s_ipad27x1, "character");     
  .Call('R_swig_dwell_target_psi_ipad27x1_set', self, s_ipad27x1, PACKAGE='iris')
  
}

attr(`dwell_target_psi_ipad27x1_set`, 'returnType') = 'void'
attr(`dwell_target_psi_ipad27x1_set`, "inputTypes") = c('_p_dwell_target_psi', 'character')
class(`dwell_target_psi_ipad27x1_set`) = c("SWIGFunction", class('dwell_target_psi_ipad27x1_set'))

# Start of dwell_target_psi_ipad27x1_get

`dwell_target_psi_ipad27x1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  .Call('R_swig_dwell_target_psi_ipad27x1_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_target_psi_ipad27x1_get`, 'returnType') = 'character'
attr(`dwell_target_psi_ipad27x1_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_ipad27x1_get`) = c("SWIGFunction", class('dwell_target_psi_ipad27x1_get'))

# Start of dwell_target_psi_iFlags2_set

`dwell_target_psi_iFlags2_set` = function(self, s_iFlags2)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iFlags2 = as.numeric(s_iFlags2) 
  
  assert(length(s_iFlags2) == 1 && s_iFlags2 >= 0, "All values must be non-negative")
  
  .Call('R_swig_dwell_target_psi_iFlags2_set', self, s_iFlags2, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iFlags2_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iFlags2_set`, "inputTypes") = c('_p_dwell_target_psi', 'numeric')
class(`dwell_target_psi_iFlags2_set`) = c("SWIGFunction", class('dwell_target_psi_iFlags2_set'))

# Start of dwell_target_psi_iFlags2_get

`dwell_target_psi_iFlags2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  .Call('R_swig_dwell_target_psi_iFlags2_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_target_psi_iFlags2_get`, 'returnType') = 'numeric'
attr(`dwell_target_psi_iFlags2_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iFlags2_get`) = c("SWIGFunction", class('dwell_target_psi_iFlags2_get'))

# Start of dwell_target_psi_iAreaMax_set

`dwell_target_psi_iAreaMax_set` = function(self, s_iAreaMax)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iAreaMax = as.numeric(s_iAreaMax) 
  
  assert(length(s_iAreaMax) == 1 && s_iAreaMax >= 0, "All values must be non-negative")
  
  .Call('R_swig_dwell_target_psi_iAreaMax_set', self, s_iAreaMax, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iAreaMax_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iAreaMax_set`, "inputTypes") = c('_p_dwell_target_psi', 'numeric')
class(`dwell_target_psi_iAreaMax_set`) = c("SWIGFunction", class('dwell_target_psi_iAreaMax_set'))

# Start of dwell_target_psi_iAreaMax_get

`dwell_target_psi_iAreaMax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  .Call('R_swig_dwell_target_psi_iAreaMax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_target_psi_iAreaMax_get`, 'returnType') = 'numeric'
attr(`dwell_target_psi_iAreaMax_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iAreaMax_get`) = c("SWIGFunction", class('dwell_target_psi_iAreaMax_get'))

# Start of dwell_target_psi_iSpeedStep_set

`dwell_target_psi_iSpeedStep_set` = function(self, s_iSpeedStep)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iSpeedStep = coerceIfNotSubclass(s_iSpeedStep, "_p_unsigned_short") 
  .Call('R_swig_dwell_target_psi_iSpeedStep_set', self, s_iSpeedStep, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iSpeedStep_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iSpeedStep_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_unsigned_short')
class(`dwell_target_psi_iSpeedStep_set`) = c("SWIGFunction", class('dwell_target_psi_iSpeedStep_set'))

# Start of dwell_target_psi_iSpeedStep_get

`dwell_target_psi_iSpeedStep_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iSpeedStep_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`dwell_target_psi_iSpeedStep_get`, 'returnType') = '_p_unsigned_short'
attr(`dwell_target_psi_iSpeedStep_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iSpeedStep_get`) = c("SWIGFunction", class('dwell_target_psi_iSpeedStep_get'))

# Start of dwell_target_psi_iDirStep_set

`dwell_target_psi_iDirStep_set` = function(self, s_iDirStep)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  s_iDirStep = coerceIfNotSubclass(s_iDirStep, "_p_unsigned_short") 
  .Call('R_swig_dwell_target_psi_iDirStep_set', self, s_iDirStep, PACKAGE='iris')
  
}

attr(`dwell_target_psi_iDirStep_set`, 'returnType') = 'void'
attr(`dwell_target_psi_iDirStep_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_unsigned_short')
class(`dwell_target_psi_iDirStep_set`) = c("SWIGFunction", class('dwell_target_psi_iDirStep_set'))

# Start of dwell_target_psi_iDirStep_get

`dwell_target_psi_iDirStep_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_iDirStep_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`dwell_target_psi_iDirStep_get`, 'returnType') = '_p_unsigned_short'
attr(`dwell_target_psi_iDirStep_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_iDirStep_get`) = c("SWIGFunction", class('dwell_target_psi_iDirStep_get'))

# Start of dwell_target_psi_ipad_end_set

`dwell_target_psi_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -68)
  
  .Call('R_swig_dwell_target_psi_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`dwell_target_psi_ipad_end_set`, 'returnType') = 'void'
attr(`dwell_target_psi_ipad_end_set`, "inputTypes") = c('_p_dwell_target_psi', '_p_char')
class(`dwell_target_psi_ipad_end_set`) = c("SWIGFunction", class('dwell_target_psi_ipad_end_set'))

# Start of dwell_target_psi_ipad_end_get

`dwell_target_psi_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  ans = .Call('R_swig_dwell_target_psi_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`dwell_target_psi_ipad_end_get`, 'returnType') = '_p_char'
attr(`dwell_target_psi_ipad_end_get`, "inputTypes") = c('_p_dwell_target_psi')
class(`dwell_target_psi_ipad_end_get`) = c("SWIGFunction", class('dwell_target_psi_ipad_end_get'))

# Start of new_dwell_target_psi

`dwell_target_psi` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_dwell_target_psi', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dwell_target_psi"
  
  ans
  
}

attr(`dwell_target_psi`, 'returnType') = '_p_dwell_target_psi'
class(`dwell_target_psi`) = c("SWIGFunction", class('dwell_target_psi'))

# Start of delete_dwell_target_psi

`delete_dwell_target_psi` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_dwell_target_psi") 
  .Call('R_swig_delete_dwell_target_psi', self, PACKAGE='iris')
  
}

attr(`delete_dwell_target_psi`, 'returnType') = 'void'
attr(`delete_dwell_target_psi`, "inputTypes") = c('_p_dwell_target_psi')
class(`delete_dwell_target_psi`) = c("SWIGFunction", class('delete_dwell_target_psi'))

# Start of accessor method for dwell_target_psi
setMethod('$', '_p_dwell_target_psi', function(x, name)

{
  accessorFuns = list('iDirLeft' = dwell_target_psi_iDirLeft_get, 'iDirRight' = dwell_target_psi_iDirRight_get, 'iSpeedMin' = dwell_target_psi_iSpeedMin_get, 'iSpeedMax' = dwell_target_psi_iSpeedMax_get, 'iProtectMask' = dwell_target_psi_iProtectMask_get, 'sWarnSymbol' = dwell_target_psi_sWarnSymbol_get, 'iPileThreshold' = dwell_target_psi_iPileThreshold_get, 'iMergeRange' = dwell_target_psi_iMergeRange_get, 'ipad27x1' = dwell_target_psi_ipad27x1_get, 'iFlags2' = dwell_target_psi_iFlags2_get, 'iAreaMax' = dwell_target_psi_iAreaMax_get, 'iSpeedStep' = dwell_target_psi_iSpeedStep_get, 'iDirStep' = dwell_target_psi_iDirStep_get, 'ipad_end' = dwell_target_psi_ipad_end_get)
  vaccessors = c('iDirLeft', 'iDirRight', 'iSpeedMin', 'iSpeedMax', 'iProtectMask', 'sWarnSymbol', 'iPileThreshold', 'iMergeRange', 'ipad27x1', 'iFlags2', 'iAreaMax', 'iSpeedStep', 'iDirStep', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for dwell_target_psi
# Start of accessor method for dwell_target_psi
setMethod('$<-', '_p_dwell_target_psi', function(x, name, value)

{
  accessorFuns = list('iDirLeft' = dwell_target_psi_iDirLeft_set, 'iDirRight' = dwell_target_psi_iDirRight_set, 'iSpeedMin' = dwell_target_psi_iSpeedMin_set, 'iSpeedMax' = dwell_target_psi_iSpeedMax_set, 'iProtectMask' = dwell_target_psi_iProtectMask_set, 'sWarnSymbol' = dwell_target_psi_sWarnSymbol_set, 'iPileThreshold' = dwell_target_psi_iPileThreshold_set, 'iMergeRange' = dwell_target_psi_iMergeRange_set, 'ipad27x1' = dwell_target_psi_ipad27x1_set, 'iFlags2' = dwell_target_psi_iFlags2_set, 'iAreaMax' = dwell_target_psi_iAreaMax_set, 'iSpeedStep' = dwell_target_psi_iSpeedStep_set, 'iDirStep' = dwell_target_psi_iDirStep_set, 'ipad_end' = dwell_target_psi_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_dwell_target_psi', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iDirLeft' = dwell_target_psi_iDirLeft_set, 'iDirRight' = dwell_target_psi_iDirRight_set, 'iSpeedMin' = dwell_target_psi_iSpeedMin_set, 'iSpeedMax' = dwell_target_psi_iSpeedMax_set, 'iProtectMask' = dwell_target_psi_iProtectMask_set, 'sWarnSymbol' = dwell_target_psi_sWarnSymbol_set, 'iPileThreshold' = dwell_target_psi_iPileThreshold_set, 'iMergeRange' = dwell_target_psi_iMergeRange_set, 'ipad27x1' = dwell_target_psi_ipad27x1_set, 'iFlags2' = dwell_target_psi_iFlags2_set, 'iAreaMax' = dwell_target_psi_iAreaMax_set, 'iSpeedStep' = dwell_target_psi_iSpeedStep_set, 'iDirStep' = dwell_target_psi_iDirStep_set, 'ipad_end' = dwell_target_psi_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for dwell_target_psi
setMethod('delete', '_p_dwell_target_psi', function(obj) {delete_dwell_target_psi(obj)})
# Start definition of copy functions & methods for dwell_target_psi
CopyToR_dwell_target_psi = function(value, obj = new("dwell_target_psi"))
{
  obj@iProtectMask = value$iProtectMask
  obj@sWarnSymbol = value$sWarnSymbol
  obj@ipad27x1 = value$ipad27x1
  obj@iFlags2 = value$iFlags2
  obj@iAreaMax = value$iAreaMax
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_dwell_target_psi = function(value, obj)
{
  obj$iProtectMask = value@iProtectMask
  obj$sWarnSymbol = value@sWarnSymbol
  obj$ipad27x1 = value@ipad27x1
  obj$iFlags2 = value@iFlags2
  obj$iAreaMax = value@iAreaMax
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for dwell_target_psi
setMethod('copyToR', '_p_dwell_target_psi', CopyToR_dwell_target_psi)
setMethod('copyToC', 'dwell_target_psi', CopyToC_dwell_target_psi)

# End definition of copy methods for dwell_target_psi
# End definition of copy functions & methods for dwell_target_psi
# Start of dwell_warn_psi_sWarnSuffix1_set

`dwell_warn_psi_sWarnSuffix1_set` = function(self, s_sWarnSuffix1)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  
  if(is.list(s_sWarnSuffix1))
  assert(all(sapply(s_sWarnSuffix1, class) == "_p_char"))     
  
  
#  assert(length(s_sWarnSuffix1) >= 4)
  
  .Call('R_swig_dwell_warn_psi_sWarnSuffix1_set', self, s_sWarnSuffix1, PACKAGE='iris')
  
}

attr(`dwell_warn_psi_sWarnSuffix1_set`, 'returnType') = 'void'
attr(`dwell_warn_psi_sWarnSuffix1_set`, "inputTypes") = c('_p_dwell_warn_psi', '_p_char')
class(`dwell_warn_psi_sWarnSuffix1_set`) = c("SWIGFunction", class('dwell_warn_psi_sWarnSuffix1_set'))

# Start of dwell_warn_psi_sWarnSuffix1_get

`dwell_warn_psi_sWarnSuffix1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  ans = .Call('R_swig_dwell_warn_psi_sWarnSuffix1_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`dwell_warn_psi_sWarnSuffix1_get`, 'returnType') = '_p_char'
attr(`dwell_warn_psi_sWarnSuffix1_get`, "inputTypes") = c('_p_dwell_warn_psi')
class(`dwell_warn_psi_sWarnSuffix1_get`) = c("SWIGFunction", class('dwell_warn_psi_sWarnSuffix1_get'))

# Start of dwell_warn_psi_sWarnSuffix2_set

`dwell_warn_psi_sWarnSuffix2_set` = function(self, s_sWarnSuffix2)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  
  if(is.list(s_sWarnSuffix2))
  assert(all(sapply(s_sWarnSuffix2, class) == "_p_char"))     
  
  
#  assert(length(s_sWarnSuffix2) >= 4)
  
  .Call('R_swig_dwell_warn_psi_sWarnSuffix2_set', self, s_sWarnSuffix2, PACKAGE='iris')
  
}

attr(`dwell_warn_psi_sWarnSuffix2_set`, 'returnType') = 'void'
attr(`dwell_warn_psi_sWarnSuffix2_set`, "inputTypes") = c('_p_dwell_warn_psi', '_p_char')
class(`dwell_warn_psi_sWarnSuffix2_set`) = c("SWIGFunction", class('dwell_warn_psi_sWarnSuffix2_set'))

# Start of dwell_warn_psi_sWarnSuffix2_get

`dwell_warn_psi_sWarnSuffix2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  ans = .Call('R_swig_dwell_warn_psi_sWarnSuffix2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`dwell_warn_psi_sWarnSuffix2_get`, 'returnType') = '_p_char'
attr(`dwell_warn_psi_sWarnSuffix2_get`, "inputTypes") = c('_p_dwell_warn_psi')
class(`dwell_warn_psi_sWarnSuffix2_get`) = c("SWIGFunction", class('dwell_warn_psi_sWarnSuffix2_get'))

# Start of dwell_warn_psi_iWarnAge2_set

`dwell_warn_psi_iWarnAge2_set` = function(self, s_iWarnAge2)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  s_iWarnAge2 = as.integer(s_iWarnAge2) 
  
  if(length(s_iWarnAge2) > 1) {
    Rf_warning("using only the first element of s_iWarnAge2")
  }
  
  .Call('R_swig_dwell_warn_psi_iWarnAge2_set', self, s_iWarnAge2, PACKAGE='iris')
  
}

attr(`dwell_warn_psi_iWarnAge2_set`, 'returnType') = 'void'
attr(`dwell_warn_psi_iWarnAge2_set`, "inputTypes") = c('_p_dwell_warn_psi', 'numeric')
class(`dwell_warn_psi_iWarnAge2_set`) = c("SWIGFunction", class('dwell_warn_psi_iWarnAge2_set'))

# Start of dwell_warn_psi_iWarnAge2_get

`dwell_warn_psi_iWarnAge2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  .Call('R_swig_dwell_warn_psi_iWarnAge2_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_warn_psi_iWarnAge2_get`, 'returnType') = 'numeric'
attr(`dwell_warn_psi_iWarnAge2_get`, "inputTypes") = c('_p_dwell_warn_psi')
class(`dwell_warn_psi_iWarnAge2_get`) = c("SWIGFunction", class('dwell_warn_psi_iWarnAge2_get'))

# Start of dwell_warn_psi_ipad12x16_set

`dwell_warn_psi_ipad12x16_set` = function(self, s_ipad12x16)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  
  if(is.list(s_ipad12x16))
  assert(all(sapply(s_ipad12x16, class) == "_p_char"))     
  
  
#  assert(length(s_ipad12x16) >= 16)
  
  .Call('R_swig_dwell_warn_psi_ipad12x16_set', self, s_ipad12x16, PACKAGE='iris')
  
}

attr(`dwell_warn_psi_ipad12x16_set`, 'returnType') = 'void'
attr(`dwell_warn_psi_ipad12x16_set`, "inputTypes") = c('_p_dwell_warn_psi', '_p_char')
class(`dwell_warn_psi_ipad12x16_set`) = c("SWIGFunction", class('dwell_warn_psi_ipad12x16_set'))

# Start of dwell_warn_psi_ipad12x16_get

`dwell_warn_psi_ipad12x16_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  ans = .Call('R_swig_dwell_warn_psi_ipad12x16_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`dwell_warn_psi_ipad12x16_get`, 'returnType') = '_p_char'
attr(`dwell_warn_psi_ipad12x16_get`, "inputTypes") = c('_p_dwell_warn_psi')
class(`dwell_warn_psi_ipad12x16_get`) = c("SWIGFunction", class('dwell_warn_psi_ipad12x16_get'))

# Start of dwell_warn_psi_iFlags2_set

`dwell_warn_psi_iFlags2_set` = function(self, s_iFlags2)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  s_iFlags2 = as.numeric(s_iFlags2) 
  
  assert(length(s_iFlags2) == 1 && s_iFlags2 >= 0, "All values must be non-negative")
  
  .Call('R_swig_dwell_warn_psi_iFlags2_set', self, s_iFlags2, PACKAGE='iris')
  
}

attr(`dwell_warn_psi_iFlags2_set`, 'returnType') = 'void'
attr(`dwell_warn_psi_iFlags2_set`, "inputTypes") = c('_p_dwell_warn_psi', 'numeric')
class(`dwell_warn_psi_iFlags2_set`) = c("SWIGFunction", class('dwell_warn_psi_iFlags2_set'))

# Start of dwell_warn_psi_iFlags2_get

`dwell_warn_psi_iFlags2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  .Call('R_swig_dwell_warn_psi_iFlags2_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_warn_psi_iFlags2_get`, 'returnType') = 'numeric'
attr(`dwell_warn_psi_iFlags2_get`, "inputTypes") = c('_p_dwell_warn_psi')
class(`dwell_warn_psi_iFlags2_get`) = c("SWIGFunction", class('dwell_warn_psi_iFlags2_get'))

# Start of dwell_warn_psi_ipad_end_set

`dwell_warn_psi_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -60)
  
  .Call('R_swig_dwell_warn_psi_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`dwell_warn_psi_ipad_end_set`, 'returnType') = 'void'
attr(`dwell_warn_psi_ipad_end_set`, "inputTypes") = c('_p_dwell_warn_psi', '_p_char')
class(`dwell_warn_psi_ipad_end_set`) = c("SWIGFunction", class('dwell_warn_psi_ipad_end_set'))

# Start of dwell_warn_psi_ipad_end_get

`dwell_warn_psi_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  ans = .Call('R_swig_dwell_warn_psi_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`dwell_warn_psi_ipad_end_get`, 'returnType') = '_p_char'
attr(`dwell_warn_psi_ipad_end_get`, "inputTypes") = c('_p_dwell_warn_psi')
class(`dwell_warn_psi_ipad_end_get`) = c("SWIGFunction", class('dwell_warn_psi_ipad_end_get'))

# Start of new_dwell_warn_psi

`dwell_warn_psi` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_dwell_warn_psi', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dwell_warn_psi"
  
  ans
  
}

attr(`dwell_warn_psi`, 'returnType') = '_p_dwell_warn_psi'
class(`dwell_warn_psi`) = c("SWIGFunction", class('dwell_warn_psi'))

# Start of delete_dwell_warn_psi

`delete_dwell_warn_psi` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_dwell_warn_psi") 
  .Call('R_swig_delete_dwell_warn_psi', self, PACKAGE='iris')
  
}

attr(`delete_dwell_warn_psi`, 'returnType') = 'void'
attr(`delete_dwell_warn_psi`, "inputTypes") = c('_p_dwell_warn_psi')
class(`delete_dwell_warn_psi`) = c("SWIGFunction", class('delete_dwell_warn_psi'))

# Start of accessor method for dwell_warn_psi
setMethod('$', '_p_dwell_warn_psi', function(x, name)

{
  accessorFuns = list('sWarnSuffix1' = dwell_warn_psi_sWarnSuffix1_get, 'sWarnSuffix2' = dwell_warn_psi_sWarnSuffix2_get, 'iWarnAge2' = dwell_warn_psi_iWarnAge2_get, 'ipad12x16' = dwell_warn_psi_ipad12x16_get, 'iFlags2' = dwell_warn_psi_iFlags2_get, 'ipad_end' = dwell_warn_psi_ipad_end_get)
  vaccessors = c('sWarnSuffix1', 'sWarnSuffix2', 'iWarnAge2', 'ipad12x16', 'iFlags2', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for dwell_warn_psi
# Start of accessor method for dwell_warn_psi
setMethod('$<-', '_p_dwell_warn_psi', function(x, name, value)

{
  accessorFuns = list('sWarnSuffix1' = dwell_warn_psi_sWarnSuffix1_set, 'sWarnSuffix2' = dwell_warn_psi_sWarnSuffix2_set, 'iWarnAge2' = dwell_warn_psi_iWarnAge2_set, 'ipad12x16' = dwell_warn_psi_ipad12x16_set, 'iFlags2' = dwell_warn_psi_iFlags2_set, 'ipad_end' = dwell_warn_psi_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_dwell_warn_psi', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('sWarnSuffix1' = dwell_warn_psi_sWarnSuffix1_set, 'sWarnSuffix2' = dwell_warn_psi_sWarnSuffix2_set, 'iWarnAge2' = dwell_warn_psi_iWarnAge2_set, 'ipad12x16' = dwell_warn_psi_ipad12x16_set, 'iFlags2' = dwell_warn_psi_iFlags2_set, 'ipad_end' = dwell_warn_psi_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for dwell_warn_psi
setMethod('delete', '_p_dwell_warn_psi', function(obj) {delete_dwell_warn_psi(obj)})
# Start definition of copy functions & methods for dwell_warn_psi
CopyToR_dwell_warn_psi = function(value, obj = new("dwell_warn_psi"))
{
  obj@sWarnSuffix1 = value$sWarnSuffix1
  obj@sWarnSuffix2 = value$sWarnSuffix2
  obj@iWarnAge2 = value$iWarnAge2
  obj@ipad12x16 = value$ipad12x16
  obj@iFlags2 = value$iFlags2
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_dwell_warn_psi = function(value, obj)
{
  obj$sWarnSuffix1 = value@sWarnSuffix1
  obj$sWarnSuffix2 = value@sWarnSuffix2
  obj$iWarnAge2 = value@iWarnAge2
  obj$ipad12x16 = value@ipad12x16
  obj$iFlags2 = value@iFlags2
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for dwell_warn_psi
setMethod('copyToR', '_p_dwell_warn_psi', CopyToR_dwell_warn_psi)
setMethod('copyToC', 'dwell_warn_psi', CopyToC_dwell_warn_psi)

# End definition of copy methods for dwell_warn_psi
# End definition of copy functions & methods for dwell_warn_psi
# Start of dwell_psi_union_Target_set

`dwell_psi_union_Target_set` = function(self, s_Target)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_union") 
  s_Target = coerceIfNotSubclass(s_Target, "_p_dwell_target_psi") 
  .Call('R_swig_dwell_psi_union_Target_set', self, s_Target, PACKAGE='iris')
  
}

attr(`dwell_psi_union_Target_set`, 'returnType') = 'void'
attr(`dwell_psi_union_Target_set`, "inputTypes") = c('_p_dwell_psi_union', '_p_dwell_target_psi')
class(`dwell_psi_union_Target_set`) = c("SWIGFunction", class('dwell_psi_union_Target_set'))

# Start of dwell_psi_union_Target_get

`dwell_psi_union_Target_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_union") 
  ans = .Call('R_swig_dwell_psi_union_Target_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dwell_target_psi"
  
  ans
  
}

attr(`dwell_psi_union_Target_get`, 'returnType') = '_p_dwell_target_psi'
attr(`dwell_psi_union_Target_get`, "inputTypes") = c('_p_dwell_psi_union')
class(`dwell_psi_union_Target_get`) = c("SWIGFunction", class('dwell_psi_union_Target_get'))

# Start of dwell_psi_union_Warn_set

`dwell_psi_union_Warn_set` = function(self, s_Warn)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_union") 
  s_Warn = coerceIfNotSubclass(s_Warn, "_p_dwell_warn_psi") 
  .Call('R_swig_dwell_psi_union_Warn_set', self, s_Warn, PACKAGE='iris')
  
}

attr(`dwell_psi_union_Warn_set`, 'returnType') = 'void'
attr(`dwell_psi_union_Warn_set`, "inputTypes") = c('_p_dwell_psi_union', '_p_dwell_warn_psi')
class(`dwell_psi_union_Warn_set`) = c("SWIGFunction", class('dwell_psi_union_Warn_set'))

# Start of dwell_psi_union_Warn_get

`dwell_psi_union_Warn_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_union") 
  ans = .Call('R_swig_dwell_psi_union_Warn_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dwell_warn_psi"
  
  ans
  
}

attr(`dwell_psi_union_Warn_get`, 'returnType') = '_p_dwell_warn_psi'
attr(`dwell_psi_union_Warn_get`, "inputTypes") = c('_p_dwell_psi_union')
class(`dwell_psi_union_Warn_get`) = c("SWIGFunction", class('dwell_psi_union_Warn_get'))

# Start of new_dwell_psi_union

`dwell_psi_union` = function()
{
  ans = .Call('R_swig_new_dwell_psi_union', PACKAGE='iris')
  class(ans) <- "_p_dwell_psi_union"
  
  ans
  
}

attr(`dwell_psi_union`, 'returnType') = '_p_dwell_psi_union'
class(`dwell_psi_union`) = c("SWIGFunction", class('dwell_psi_union'))

# Start of delete_dwell_psi_union

`delete_dwell_psi_union` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_union") 
  .Call('R_swig_delete_dwell_psi_union', self, PACKAGE='iris')
  
}

attr(`delete_dwell_psi_union`, 'returnType') = 'void'
attr(`delete_dwell_psi_union`, "inputTypes") = c('_p_dwell_psi_union')
class(`delete_dwell_psi_union`) = c("SWIGFunction", class('delete_dwell_psi_union'))

# Start of accessor method for dwell_psi_union
setMethod('$', '_p_dwell_psi_union', function(x, name)

{
  accessorFuns = list('Target' = dwell_psi_union_Target_get, 'Warn' = dwell_psi_union_Warn_get)
  vaccessors = c('Target', 'Warn')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for dwell_psi_union
# Start of accessor method for dwell_psi_union
setMethod('$<-', '_p_dwell_psi_union', function(x, name, value)

{
  accessorFuns = list('Target' = dwell_psi_union_Target_set, 'Warn' = dwell_psi_union_Warn_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_dwell_psi_union', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('Target' = dwell_psi_union_Target_set, 'Warn' = dwell_psi_union_Warn_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for dwell_psi_union
setMethod('delete', '_p_dwell_psi_union', function(obj) {delete_dwell_psi_union(obj)})
# Start of dwell_psi_struct_iDataMin_set

`dwell_psi_struct_iDataMin_set` = function(self, s_iDataMin)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_iDataMin = as.integer(s_iDataMin) 
  
  if(length(s_iDataMin) > 1) {
    Rf_warning("using only the first element of s_iDataMin")
  }
  
  .Call('R_swig_dwell_psi_struct_iDataMin_set', self, s_iDataMin, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iDataMin_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_iDataMin_set`, "inputTypes") = c('_p_dwell_psi_struct', 'numeric')
class(`dwell_psi_struct_iDataMin_set`) = c("SWIGFunction", class('dwell_psi_struct_iDataMin_set'))

# Start of dwell_psi_struct_iDataMin_get

`dwell_psi_struct_iDataMin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  .Call('R_swig_dwell_psi_struct_iDataMin_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iDataMin_get`, 'returnType') = 'numeric'
attr(`dwell_psi_struct_iDataMin_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_iDataMin_get`) = c("SWIGFunction", class('dwell_psi_struct_iDataMin_get'))

# Start of dwell_psi_struct_iDataMax_set

`dwell_psi_struct_iDataMax_set` = function(self, s_iDataMax)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_iDataMax = as.integer(s_iDataMax) 
  
  if(length(s_iDataMax) > 1) {
    Rf_warning("using only the first element of s_iDataMax")
  }
  
  .Call('R_swig_dwell_psi_struct_iDataMax_set', self, s_iDataMax, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iDataMax_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_iDataMax_set`, "inputTypes") = c('_p_dwell_psi_struct', 'numeric')
class(`dwell_psi_struct_iDataMax_set`) = c("SWIGFunction", class('dwell_psi_struct_iDataMax_set'))

# Start of dwell_psi_struct_iDataMax_get

`dwell_psi_struct_iDataMax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  .Call('R_swig_dwell_psi_struct_iDataMax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iDataMax_get`, 'returnType') = 'numeric'
attr(`dwell_psi_struct_iDataMax_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_iDataMax_get`) = c("SWIGFunction", class('dwell_psi_struct_iDataMax_get'))

# Start of dwell_psi_struct_iContrastCoverage_set

`dwell_psi_struct_iContrastCoverage_set` = function(self, s_iContrastCoverage)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_iContrastCoverage = coerceIfNotSubclass(s_iContrastCoverage, "_p_short") 
  .Call('R_swig_dwell_psi_struct_iContrastCoverage_set', self, s_iContrastCoverage, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iContrastCoverage_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_iContrastCoverage_set`, "inputTypes") = c('_p_dwell_psi_struct', '_p_short')
class(`dwell_psi_struct_iContrastCoverage_set`) = c("SWIGFunction", class('dwell_psi_struct_iContrastCoverage_set'))

# Start of dwell_psi_struct_iContrastCoverage_get

`dwell_psi_struct_iContrastCoverage_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  ans = .Call('R_swig_dwell_psi_struct_iContrastCoverage_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`dwell_psi_struct_iContrastCoverage_get`, 'returnType') = '_p_short'
attr(`dwell_psi_struct_iContrastCoverage_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_iContrastCoverage_get`) = c("SWIGFunction", class('dwell_psi_struct_iContrastCoverage_get'))

# Start of dwell_psi_struct_iContrastThreshold_set

`dwell_psi_struct_iContrastThreshold_set` = function(self, s_iContrastThreshold)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_iContrastThreshold = coerceIfNotSubclass(s_iContrastThreshold, "_p_short") 
  .Call('R_swig_dwell_psi_struct_iContrastThreshold_set', self, s_iContrastThreshold, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iContrastThreshold_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_iContrastThreshold_set`, "inputTypes") = c('_p_dwell_psi_struct', '_p_short')
class(`dwell_psi_struct_iContrastThreshold_set`) = c("SWIGFunction", class('dwell_psi_struct_iContrastThreshold_set'))

# Start of dwell_psi_struct_iContrastThreshold_get

`dwell_psi_struct_iContrastThreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  ans = .Call('R_swig_dwell_psi_struct_iContrastThreshold_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`dwell_psi_struct_iContrastThreshold_get`, 'returnType') = '_p_short'
attr(`dwell_psi_struct_iContrastThreshold_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_iContrastThreshold_get`) = c("SWIGFunction", class('dwell_psi_struct_iContrastThreshold_get'))

# Start of dwell_psi_struct_iTimeSpan_set

`dwell_psi_struct_iTimeSpan_set` = function(self, s_iTimeSpan)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_iTimeSpan = coerceIfNotSubclass(s_iTimeSpan, "_p_unsigned_short") 
  .Call('R_swig_dwell_psi_struct_iTimeSpan_set', self, s_iTimeSpan, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iTimeSpan_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_iTimeSpan_set`, "inputTypes") = c('_p_dwell_psi_struct', '_p_unsigned_short')
class(`dwell_psi_struct_iTimeSpan_set`) = c("SWIGFunction", class('dwell_psi_struct_iTimeSpan_set'))

# Start of dwell_psi_struct_iTimeSpan_get

`dwell_psi_struct_iTimeSpan_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  ans = .Call('R_swig_dwell_psi_struct_iTimeSpan_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`dwell_psi_struct_iTimeSpan_get`, 'returnType') = '_p_unsigned_short'
attr(`dwell_psi_struct_iTimeSpan_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_iTimeSpan_get`) = c("SWIGFunction", class('dwell_psi_struct_iTimeSpan_get'))

# Start of dwell_psi_struct_iPTypeIn_set

`dwell_psi_struct_iPTypeIn_set` = function(self, s_iPTypeIn)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_iPTypeIn = coerceIfNotSubclass(s_iPTypeIn, "_p_unsigned_char") 
  .Call('R_swig_dwell_psi_struct_iPTypeIn_set', self, s_iPTypeIn, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iPTypeIn_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_iPTypeIn_set`, "inputTypes") = c('_p_dwell_psi_struct', '_p_unsigned_char')
class(`dwell_psi_struct_iPTypeIn_set`) = c("SWIGFunction", class('dwell_psi_struct_iPTypeIn_set'))

# Start of dwell_psi_struct_iPTypeIn_get

`dwell_psi_struct_iPTypeIn_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  ans = .Call('R_swig_dwell_psi_struct_iPTypeIn_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`dwell_psi_struct_iPTypeIn_get`, 'returnType') = '_p_unsigned_char'
attr(`dwell_psi_struct_iPTypeIn_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_iPTypeIn_get`) = c("SWIGFunction", class('dwell_psi_struct_iPTypeIn_get'))

# Start of dwell_psi_struct_iFlags_set

`dwell_psi_struct_iFlags_set` = function(self, s_iFlags)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_iFlags = coerceIfNotSubclass(s_iFlags, "_p_unsigned_char") 
  .Call('R_swig_dwell_psi_struct_iFlags_set', self, s_iFlags, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_iFlags_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_iFlags_set`, "inputTypes") = c('_p_dwell_psi_struct', '_p_unsigned_char')
class(`dwell_psi_struct_iFlags_set`) = c("SWIGFunction", class('dwell_psi_struct_iFlags_set'))

# Start of dwell_psi_struct_iFlags_get

`dwell_psi_struct_iFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  ans = .Call('R_swig_dwell_psi_struct_iFlags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`dwell_psi_struct_iFlags_get`, 'returnType') = '_p_unsigned_char'
attr(`dwell_psi_struct_iFlags_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_iFlags_get`) = c("SWIGFunction", class('dwell_psi_struct_iFlags_get'))

# Start of dwell_psi_struct_sPNameIn_set

`dwell_psi_struct_sPNameIn_set` = function(self, s_sPNameIn)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  
  if(is.list(s_sPNameIn))
  assert(all(sapply(s_sPNameIn, class) == "_p_char"))     
  
  
#  assert(length(s_sPNameIn) >= 12)
  
  .Call('R_swig_dwell_psi_struct_sPNameIn_set', self, s_sPNameIn, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_sPNameIn_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_sPNameIn_set`, "inputTypes") = c('_p_dwell_psi_struct', '_p_char')
class(`dwell_psi_struct_sPNameIn_set`) = c("SWIGFunction", class('dwell_psi_struct_sPNameIn_set'))

# Start of dwell_psi_struct_sPNameIn_get

`dwell_psi_struct_sPNameIn_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  ans = .Call('R_swig_dwell_psi_struct_sPNameIn_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`dwell_psi_struct_sPNameIn_get`, 'returnType') = '_p_char'
attr(`dwell_psi_struct_sPNameIn_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_sPNameIn_get`) = c("SWIGFunction", class('dwell_psi_struct_sPNameIn_get'))

# Start of dwell_psi_struct_u_set

`dwell_psi_struct_u_set` = function(self, s_u)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  s_u = coerceIfNotSubclass(s_u, "_p_dwell_psi_union") 
  .Call('R_swig_dwell_psi_struct_u_set', self, s_u, PACKAGE='iris')
  
}

attr(`dwell_psi_struct_u_set`, 'returnType') = 'void'
attr(`dwell_psi_struct_u_set`, "inputTypes") = c('_p_dwell_psi_struct', '_p_dwell_psi_union')
class(`dwell_psi_struct_u_set`) = c("SWIGFunction", class('dwell_psi_struct_u_set'))

# Start of dwell_psi_struct_u_get

`dwell_psi_struct_u_get` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  ans = .Call('R_swig_dwell_psi_struct_u_get', self, PACKAGE='iris')
  class(ans) <- "_p_dwell_psi_union"
  
  ans
  
}

attr(`dwell_psi_struct_u_get`, 'returnType') = '_p_dwell_psi_union'
attr(`dwell_psi_struct_u_get`, "inputTypes") = c('_p_dwell_psi_struct')
class(`dwell_psi_struct_u_get`) = c("SWIGFunction", class('dwell_psi_struct_u_get'))

# Start of new_dwell_psi_struct

`dwell_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_dwell_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dwell_psi_struct"
  
  ans
  
}

attr(`dwell_psi_struct`, 'returnType') = '_p_dwell_psi_struct'
class(`dwell_psi_struct`) = c("SWIGFunction", class('dwell_psi_struct'))

# Start of delete_dwell_psi_struct

`delete_dwell_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_dwell_psi_struct") 
  .Call('R_swig_delete_dwell_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_dwell_psi_struct`, 'returnType') = 'void'
attr(`delete_dwell_psi_struct`, "inputTypes") = c('_p_dwell_psi_struct')
class(`delete_dwell_psi_struct`) = c("SWIGFunction", class('delete_dwell_psi_struct'))

# Start of accessor method for dwell_psi_struct
setMethod('$', '_p_dwell_psi_struct', function(x, name)

{
  accessorFuns = list('iDataMin' = dwell_psi_struct_iDataMin_get, 'iDataMax' = dwell_psi_struct_iDataMax_get, 'iContrastCoverage' = dwell_psi_struct_iContrastCoverage_get, 'iContrastThreshold' = dwell_psi_struct_iContrastThreshold_get, 'iTimeSpan' = dwell_psi_struct_iTimeSpan_get, 'iPTypeIn' = dwell_psi_struct_iPTypeIn_get, 'iFlags' = dwell_psi_struct_iFlags_get, 'sPNameIn' = dwell_psi_struct_sPNameIn_get, 'u' = dwell_psi_struct_u_get)
  vaccessors = c('iDataMin', 'iDataMax', 'iContrastCoverage', 'iContrastThreshold', 'iTimeSpan', 'iPTypeIn', 'iFlags', 'sPNameIn', 'u')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for dwell_psi_struct
# Start of accessor method for dwell_psi_struct
setMethod('$<-', '_p_dwell_psi_struct', function(x, name, value)

{
  accessorFuns = list('iDataMin' = dwell_psi_struct_iDataMin_set, 'iDataMax' = dwell_psi_struct_iDataMax_set, 'iContrastCoverage' = dwell_psi_struct_iContrastCoverage_set, 'iContrastThreshold' = dwell_psi_struct_iContrastThreshold_set, 'iTimeSpan' = dwell_psi_struct_iTimeSpan_set, 'iPTypeIn' = dwell_psi_struct_iPTypeIn_set, 'iFlags' = dwell_psi_struct_iFlags_set, 'sPNameIn' = dwell_psi_struct_sPNameIn_set, 'u' = dwell_psi_struct_u_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_dwell_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iDataMin' = dwell_psi_struct_iDataMin_set, 'iDataMax' = dwell_psi_struct_iDataMax_set, 'iContrastCoverage' = dwell_psi_struct_iContrastCoverage_set, 'iContrastThreshold' = dwell_psi_struct_iContrastThreshold_set, 'iTimeSpan' = dwell_psi_struct_iTimeSpan_set, 'iPTypeIn' = dwell_psi_struct_iPTypeIn_set, 'iFlags' = dwell_psi_struct_iFlags_set, 'sPNameIn' = dwell_psi_struct_sPNameIn_set, 'u' = dwell_psi_struct_u_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for dwell_psi_struct
setMethod('delete', '_p_dwell_psi_struct', function(obj) {delete_dwell_psi_struct(obj)})
# Start definition of copy functions & methods for dwell_psi_struct
CopyToR_dwell_psi_struct = function(value, obj = new("dwell_psi_struct"))
{
  obj@iDataMin = value$iDataMin
  obj@iDataMax = value$iDataMax
  obj@sPNameIn = value$sPNameIn
  obj
}



CopyToC_dwell_psi_struct = function(value, obj)
{
  obj$iDataMin = value@iDataMin
  obj$iDataMax = value@iDataMax
  obj$sPNameIn = value@sPNameIn
  obj
}



# Start definition of copy methods for dwell_psi_struct
setMethod('copyToR', '_p_dwell_psi_struct', CopyToR_dwell_psi_struct)
setMethod('copyToC', 'dwell_psi_struct', CopyToC_dwell_psi_struct)

# End definition of copy methods for dwell_psi_struct
# End definition of copy functions & methods for dwell_psi_struct
# Start of fcast_psi_struct_iCorrThreshold_set

`fcast_psi_struct_iCorrThreshold_set` = function(self, s_iCorrThreshold)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_iCorrThreshold = as.numeric(s_iCorrThreshold) 
  
  assert(length(s_iCorrThreshold) == 1 && s_iCorrThreshold >= 0, "All values must be non-negative")
  
  .Call('R_swig_fcast_psi_struct_iCorrThreshold_set', self, s_iCorrThreshold, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iCorrThreshold_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_iCorrThreshold_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_iCorrThreshold_set`) = c("SWIGFunction", class('fcast_psi_struct_iCorrThreshold_set'))

# Start of fcast_psi_struct_iCorrThreshold_get

`fcast_psi_struct_iCorrThreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_iCorrThreshold_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iCorrThreshold_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_iCorrThreshold_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_iCorrThreshold_get`) = c("SWIGFunction", class('fcast_psi_struct_iCorrThreshold_get'))

# Start of fcast_psi_struct_iDataThreshold_set

`fcast_psi_struct_iDataThreshold_set` = function(self, s_iDataThreshold)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_iDataThreshold = as.integer(s_iDataThreshold) 
  
  if(length(s_iDataThreshold) > 1) {
    Rf_warning("using only the first element of s_iDataThreshold")
  }
  
  .Call('R_swig_fcast_psi_struct_iDataThreshold_set', self, s_iDataThreshold, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iDataThreshold_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_iDataThreshold_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_iDataThreshold_set`) = c("SWIGFunction", class('fcast_psi_struct_iDataThreshold_set'))

# Start of fcast_psi_struct_iDataThreshold_get

`fcast_psi_struct_iDataThreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_iDataThreshold_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iDataThreshold_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_iDataThreshold_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_iDataThreshold_get`) = c("SWIGFunction", class('fcast_psi_struct_iDataThreshold_get'))

# Start of fcast_psi_struct_iMeanSpeed_set

`fcast_psi_struct_iMeanSpeed_set` = function(self, s_iMeanSpeed)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_iMeanSpeed = as.integer(s_iMeanSpeed) 
  
  if(length(s_iMeanSpeed) > 1) {
    Rf_warning("using only the first element of s_iMeanSpeed")
  }
  
  .Call('R_swig_fcast_psi_struct_iMeanSpeed_set', self, s_iMeanSpeed, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iMeanSpeed_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_iMeanSpeed_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_iMeanSpeed_set`) = c("SWIGFunction", class('fcast_psi_struct_iMeanSpeed_set'))

# Start of fcast_psi_struct_iMeanSpeed_get

`fcast_psi_struct_iMeanSpeed_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_iMeanSpeed_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iMeanSpeed_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_iMeanSpeed_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_iMeanSpeed_get`) = c("SWIGFunction", class('fcast_psi_struct_iMeanSpeed_get'))

# Start of fcast_psi_struct_iMeanDirection_set

`fcast_psi_struct_iMeanDirection_set` = function(self, s_iMeanDirection)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_iMeanDirection = as.numeric(s_iMeanDirection) 
  
  assert(length(s_iMeanDirection) == 1 && s_iMeanDirection >= 0, "All values must be non-negative")
  
  .Call('R_swig_fcast_psi_struct_iMeanDirection_set', self, s_iMeanDirection, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iMeanDirection_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_iMeanDirection_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_iMeanDirection_set`) = c("SWIGFunction", class('fcast_psi_struct_iMeanDirection_set'))

# Start of fcast_psi_struct_iMeanDirection_get

`fcast_psi_struct_iMeanDirection_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_iMeanDirection_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iMeanDirection_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_iMeanDirection_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_iMeanDirection_get`) = c("SWIGFunction", class('fcast_psi_struct_iMeanDirection_get'))

# Start of fcast_psi_struct_imax_time_step_set

`fcast_psi_struct_imax_time_step_set` = function(self, s_imax_time_step)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_imax_time_step = as.numeric(s_imax_time_step) 
  
  assert(length(s_imax_time_step) == 1 && s_imax_time_step >= 0, "All values must be non-negative")
  
  .Call('R_swig_fcast_psi_struct_imax_time_step_set', self, s_imax_time_step, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_imax_time_step_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_imax_time_step_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_imax_time_step_set`) = c("SWIGFunction", class('fcast_psi_struct_imax_time_step_set'))

# Start of fcast_psi_struct_imax_time_step_get

`fcast_psi_struct_imax_time_step_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_imax_time_step_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_imax_time_step_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_imax_time_step_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_imax_time_step_get`) = c("SWIGFunction", class('fcast_psi_struct_imax_time_step_get'))

# Start of fcast_psi_struct_imax_velocity_set

`fcast_psi_struct_imax_velocity_set` = function(self, s_imax_velocity)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_imax_velocity = as.integer(s_imax_velocity) 
  
  if(length(s_imax_velocity) > 1) {
    Rf_warning("using only the first element of s_imax_velocity")
  }
  
  .Call('R_swig_fcast_psi_struct_imax_velocity_set', self, s_imax_velocity, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_imax_velocity_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_imax_velocity_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_imax_velocity_set`) = c("SWIGFunction", class('fcast_psi_struct_imax_velocity_set'))

# Start of fcast_psi_struct_imax_velocity_get

`fcast_psi_struct_imax_velocity_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_imax_velocity_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_imax_velocity_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_imax_velocity_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_imax_velocity_get`) = c("SWIGFunction", class('fcast_psi_struct_imax_velocity_get'))

# Start of fcast_psi_struct_iflags_set

`fcast_psi_struct_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_fcast_psi_struct_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iflags_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_iflags_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_iflags_set`) = c("SWIGFunction", class('fcast_psi_struct_iflags_set'))

# Start of fcast_psi_struct_iflags_get

`fcast_psi_struct_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iflags_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_iflags_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_iflags_get`) = c("SWIGFunction", class('fcast_psi_struct_iflags_get'))

# Start of fcast_psi_struct_iOutputResolution_set

`fcast_psi_struct_iOutputResolution_set` = function(self, s_iOutputResolution)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_iOutputResolution = as.integer(s_iOutputResolution) 
  
  if(length(s_iOutputResolution) > 1) {
    Rf_warning("using only the first element of s_iOutputResolution")
  }
  
  .Call('R_swig_fcast_psi_struct_iOutputResolution_set', self, s_iOutputResolution, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iOutputResolution_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_iOutputResolution_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_iOutputResolution_set`) = c("SWIGFunction", class('fcast_psi_struct_iOutputResolution_set'))

# Start of fcast_psi_struct_iOutputResolution_get

`fcast_psi_struct_iOutputResolution_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_iOutputResolution_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iOutputResolution_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_iOutputResolution_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_iOutputResolution_get`) = c("SWIGFunction", class('fcast_psi_struct_iOutputResolution_get'))

# Start of fcast_psi_struct_iptype_set

`fcast_psi_struct_iptype_set` = function(self, s_iptype)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  s_iptype = as.numeric(s_iptype) 
  
  assert(length(s_iptype) == 1 && s_iptype >= 0, "All values must be non-negative")
  
  .Call('R_swig_fcast_psi_struct_iptype_set', self, s_iptype, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iptype_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_iptype_set`, "inputTypes") = c('_p_fcast_psi_struct', 'numeric')
class(`fcast_psi_struct_iptype_set`) = c("SWIGFunction", class('fcast_psi_struct_iptype_set'))

# Start of fcast_psi_struct_iptype_get

`fcast_psi_struct_iptype_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_fcast_psi_struct_iptype_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`fcast_psi_struct_iptype_get`, 'returnType') = 'numeric'
attr(`fcast_psi_struct_iptype_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_iptype_get`) = c("SWIGFunction", class('fcast_psi_struct_iptype_get'))

# Start of fcast_psi_struct_spname_set

`fcast_psi_struct_spname_set` = function(self, s_spname)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  
  if(is.list(s_spname))
  assert(all(sapply(s_spname, class) == "_p_char"))     
  
  
#  assert(length(s_spname) >= 12)
  
  .Call('R_swig_fcast_psi_struct_spname_set', self, s_spname, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_spname_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_spname_set`, "inputTypes") = c('_p_fcast_psi_struct', '_p_char')
class(`fcast_psi_struct_spname_set`) = c("SWIGFunction", class('fcast_psi_struct_spname_set'))

# Start of fcast_psi_struct_spname_get

`fcast_psi_struct_spname_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  ans = .Call('R_swig_fcast_psi_struct_spname_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`fcast_psi_struct_spname_get`, 'returnType') = '_p_char'
attr(`fcast_psi_struct_spname_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_spname_get`) = c("SWIGFunction", class('fcast_psi_struct_spname_get'))

# Start of fcast_psi_struct_ipad_end_set

`fcast_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -48)
  
  .Call('R_swig_fcast_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`fcast_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`fcast_psi_struct_ipad_end_set`, "inputTypes") = c('_p_fcast_psi_struct', '_p_char')
class(`fcast_psi_struct_ipad_end_set`) = c("SWIGFunction", class('fcast_psi_struct_ipad_end_set'))

# Start of fcast_psi_struct_ipad_end_get

`fcast_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  ans = .Call('R_swig_fcast_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`fcast_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`fcast_psi_struct_ipad_end_get`, "inputTypes") = c('_p_fcast_psi_struct')
class(`fcast_psi_struct_ipad_end_get`) = c("SWIGFunction", class('fcast_psi_struct_ipad_end_get'))

# Start of new_fcast_psi_struct

`fcast_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_fcast_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_fcast_psi_struct"
  
  ans
  
}

attr(`fcast_psi_struct`, 'returnType') = '_p_fcast_psi_struct'
class(`fcast_psi_struct`) = c("SWIGFunction", class('fcast_psi_struct'))

# Start of delete_fcast_psi_struct

`delete_fcast_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_fcast_psi_struct") 
  .Call('R_swig_delete_fcast_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_fcast_psi_struct`, 'returnType') = 'void'
attr(`delete_fcast_psi_struct`, "inputTypes") = c('_p_fcast_psi_struct')
class(`delete_fcast_psi_struct`) = c("SWIGFunction", class('delete_fcast_psi_struct'))

# Start of accessor method for fcast_psi_struct
setMethod('$', '_p_fcast_psi_struct', function(x, name)

{
  accessorFuns = list('iCorrThreshold' = fcast_psi_struct_iCorrThreshold_get, 'iDataThreshold' = fcast_psi_struct_iDataThreshold_get, 'iMeanSpeed' = fcast_psi_struct_iMeanSpeed_get, 'iMeanDirection' = fcast_psi_struct_iMeanDirection_get, 'imax_time_step' = fcast_psi_struct_imax_time_step_get, 'imax_velocity' = fcast_psi_struct_imax_velocity_get, 'iflags' = fcast_psi_struct_iflags_get, 'iOutputResolution' = fcast_psi_struct_iOutputResolution_get, 'iptype' = fcast_psi_struct_iptype_get, 'spname' = fcast_psi_struct_spname_get, 'ipad_end' = fcast_psi_struct_ipad_end_get)
  vaccessors = c('iCorrThreshold', 'iDataThreshold', 'iMeanSpeed', 'iMeanDirection', 'imax_time_step', 'imax_velocity', 'iflags', 'iOutputResolution', 'iptype', 'spname', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for fcast_psi_struct
# Start of accessor method for fcast_psi_struct
setMethod('$<-', '_p_fcast_psi_struct', function(x, name, value)

{
  accessorFuns = list('iCorrThreshold' = fcast_psi_struct_iCorrThreshold_set, 'iDataThreshold' = fcast_psi_struct_iDataThreshold_set, 'iMeanSpeed' = fcast_psi_struct_iMeanSpeed_set, 'iMeanDirection' = fcast_psi_struct_iMeanDirection_set, 'imax_time_step' = fcast_psi_struct_imax_time_step_set, 'imax_velocity' = fcast_psi_struct_imax_velocity_set, 'iflags' = fcast_psi_struct_iflags_set, 'iOutputResolution' = fcast_psi_struct_iOutputResolution_set, 'iptype' = fcast_psi_struct_iptype_set, 'spname' = fcast_psi_struct_spname_set, 'ipad_end' = fcast_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_fcast_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iCorrThreshold' = fcast_psi_struct_iCorrThreshold_set, 'iDataThreshold' = fcast_psi_struct_iDataThreshold_set, 'iMeanSpeed' = fcast_psi_struct_iMeanSpeed_set, 'iMeanDirection' = fcast_psi_struct_iMeanDirection_set, 'imax_time_step' = fcast_psi_struct_imax_time_step_set, 'imax_velocity' = fcast_psi_struct_imax_velocity_set, 'iflags' = fcast_psi_struct_iflags_set, 'iOutputResolution' = fcast_psi_struct_iOutputResolution_set, 'iptype' = fcast_psi_struct_iptype_set, 'spname' = fcast_psi_struct_spname_set, 'ipad_end' = fcast_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for fcast_psi_struct
setMethod('delete', '_p_fcast_psi_struct', function(obj) {delete_fcast_psi_struct(obj)})
# Start definition of copy functions & methods for fcast_psi_struct
CopyToR_fcast_psi_struct = function(value, obj = new("fcast_psi_struct"))
{
  obj@iCorrThreshold = value$iCorrThreshold
  obj@iDataThreshold = value$iDataThreshold
  obj@iMeanSpeed = value$iMeanSpeed
  obj@iMeanDirection = value$iMeanDirection
  obj@imax_time_step = value$imax_time_step
  obj@imax_velocity = value$imax_velocity
  obj@iflags = value$iflags
  obj@iOutputResolution = value$iOutputResolution
  obj@iptype = value$iptype
  obj@spname = value$spname
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_fcast_psi_struct = function(value, obj)
{
  obj$iCorrThreshold = value@iCorrThreshold
  obj$iDataThreshold = value@iDataThreshold
  obj$iMeanSpeed = value@iMeanSpeed
  obj$iMeanDirection = value@iMeanDirection
  obj$imax_time_step = value@imax_time_step
  obj$imax_velocity = value@imax_velocity
  obj$iflags = value@iflags
  obj$iOutputResolution = value@iOutputResolution
  obj$iptype = value@iptype
  obj$spname = value@spname
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for fcast_psi_struct
setMethod('copyToR', '_p_fcast_psi_struct', CopyToR_fcast_psi_struct)
setMethod('copyToC', 'fcast_psi_struct', CopyToC_fcast_psi_struct)

# End definition of copy methods for fcast_psi_struct
# End definition of copy functions & methods for fcast_psi_struct
# Start of gage_psi_struct_iSpan_set

`gage_psi_struct_iSpan_set` = function(self, s_iSpan)
{
  self = coerceIfNotSubclass(self, "_p_gage_psi_struct") 
  s_iSpan = as.numeric(s_iSpan) 
  
  assert(length(s_iSpan) == 1 && s_iSpan >= 0, "All values must be non-negative")
  
  .Call('R_swig_gage_psi_struct_iSpan_set', self, s_iSpan, PACKAGE='iris')
  
}

attr(`gage_psi_struct_iSpan_set`, 'returnType') = 'void'
attr(`gage_psi_struct_iSpan_set`, "inputTypes") = c('_p_gage_psi_struct', 'numeric')
class(`gage_psi_struct_iSpan_set`) = c("SWIGFunction", class('gage_psi_struct_iSpan_set'))

# Start of gage_psi_struct_iSpan_get

`gage_psi_struct_iSpan_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gage_psi_struct") 
  .Call('R_swig_gage_psi_struct_iSpan_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`gage_psi_struct_iSpan_get`, 'returnType') = 'numeric'
attr(`gage_psi_struct_iSpan_get`, "inputTypes") = c('_p_gage_psi_struct')
class(`gage_psi_struct_iSpan_get`) = c("SWIGFunction", class('gage_psi_struct_iSpan_get'))

# Start of gage_psi_struct_iFlag_set

`gage_psi_struct_iFlag_set` = function(self, s_iFlag)
{
  self = coerceIfNotSubclass(self, "_p_gage_psi_struct") 
  s_iFlag = as.numeric(s_iFlag) 
  
  assert(length(s_iFlag) == 1 && s_iFlag >= 0, "All values must be non-negative")
  
  .Call('R_swig_gage_psi_struct_iFlag_set', self, s_iFlag, PACKAGE='iris')
  
}

attr(`gage_psi_struct_iFlag_set`, 'returnType') = 'void'
attr(`gage_psi_struct_iFlag_set`, "inputTypes") = c('_p_gage_psi_struct', 'numeric')
class(`gage_psi_struct_iFlag_set`) = c("SWIGFunction", class('gage_psi_struct_iFlag_set'))

# Start of gage_psi_struct_iFlag_get

`gage_psi_struct_iFlag_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gage_psi_struct") 
  .Call('R_swig_gage_psi_struct_iFlag_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`gage_psi_struct_iFlag_get`, 'returnType') = 'numeric'
attr(`gage_psi_struct_iFlag_get`, "inputTypes") = c('_p_gage_psi_struct')
class(`gage_psi_struct_iFlag_get`) = c("SWIGFunction", class('gage_psi_struct_iFlag_get'))

# Start of gage_psi_struct_ipad_end_set

`gage_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_gage_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -8)
  
  .Call('R_swig_gage_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`gage_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`gage_psi_struct_ipad_end_set`, "inputTypes") = c('_p_gage_psi_struct', '_p_char')
class(`gage_psi_struct_ipad_end_set`) = c("SWIGFunction", class('gage_psi_struct_ipad_end_set'))

# Start of gage_psi_struct_ipad_end_get

`gage_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gage_psi_struct") 
  ans = .Call('R_swig_gage_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`gage_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`gage_psi_struct_ipad_end_get`, "inputTypes") = c('_p_gage_psi_struct')
class(`gage_psi_struct_ipad_end_get`) = c("SWIGFunction", class('gage_psi_struct_ipad_end_get'))

# Start of new_gage_psi_struct

`gage_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_gage_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_gage_psi_struct"
  
  ans
  
}

attr(`gage_psi_struct`, 'returnType') = '_p_gage_psi_struct'
class(`gage_psi_struct`) = c("SWIGFunction", class('gage_psi_struct'))

# Start of delete_gage_psi_struct

`delete_gage_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_gage_psi_struct") 
  .Call('R_swig_delete_gage_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_gage_psi_struct`, 'returnType') = 'void'
attr(`delete_gage_psi_struct`, "inputTypes") = c('_p_gage_psi_struct')
class(`delete_gage_psi_struct`) = c("SWIGFunction", class('delete_gage_psi_struct'))

# Start of accessor method for gage_psi_struct
setMethod('$', '_p_gage_psi_struct', function(x, name)

{
  accessorFuns = list('iSpan' = gage_psi_struct_iSpan_get, 'iFlag' = gage_psi_struct_iFlag_get, 'ipad_end' = gage_psi_struct_ipad_end_get)
  vaccessors = c('iSpan', 'iFlag', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for gage_psi_struct
# Start of accessor method for gage_psi_struct
setMethod('$<-', '_p_gage_psi_struct', function(x, name, value)

{
  accessorFuns = list('iSpan' = gage_psi_struct_iSpan_set, 'iFlag' = gage_psi_struct_iFlag_set, 'ipad_end' = gage_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_gage_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iSpan' = gage_psi_struct_iSpan_set, 'iFlag' = gage_psi_struct_iFlag_set, 'ipad_end' = gage_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for gage_psi_struct
setMethod('delete', '_p_gage_psi_struct', function(obj) {delete_gage_psi_struct(obj)})
# Start definition of copy functions & methods for gage_psi_struct
CopyToR_gage_psi_struct = function(value, obj = new("gage_psi_struct"))
{
  obj@iSpan = value$iSpan
  obj@iFlag = value$iFlag
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_gage_psi_struct = function(value, obj)
{
  obj$iSpan = value@iSpan
  obj$iFlag = value@iFlag
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for gage_psi_struct
setMethod('copyToR', '_p_gage_psi_struct', CopyToR_gage_psi_struct)
setMethod('copyToC', 'gage_psi_struct', CopyToC_gage_psi_struct)

# End definition of copy methods for gage_psi_struct
# End definition of copy functions & methods for gage_psi_struct
# Start of maximum_psi_struct_ipad0x4_set

`maximum_psi_struct_ipad0x4_set` = function(self, s_ipad0x4)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  
  if(is.list(s_ipad0x4))
  assert(all(sapply(s_ipad0x4, class) == "_p_char"))     
  
  
#  assert(length(s_ipad0x4) >= 4)
  
  .Call('R_swig_maximum_psi_struct_ipad0x4_set', self, s_ipad0x4, PACKAGE='iris')
  
}

attr(`maximum_psi_struct_ipad0x4_set`, 'returnType') = 'void'
attr(`maximum_psi_struct_ipad0x4_set`, "inputTypes") = c('_p_maximum_psi_struct', '_p_char')
class(`maximum_psi_struct_ipad0x4_set`) = c("SWIGFunction", class('maximum_psi_struct_ipad0x4_set'))

# Start of maximum_psi_struct_ipad0x4_get

`maximum_psi_struct_ipad0x4_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  ans = .Call('R_swig_maximum_psi_struct_ipad0x4_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`maximum_psi_struct_ipad0x4_get`, 'returnType') = '_p_char'
attr(`maximum_psi_struct_ipad0x4_get`, "inputTypes") = c('_p_maximum_psi_struct')
class(`maximum_psi_struct_ipad0x4_get`) = c("SWIGFunction", class('maximum_psi_struct_ipad0x4_get'))

# Start of maximum_psi_struct_ibottom_set

`maximum_psi_struct_ibottom_set` = function(self, s_ibottom)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  s_ibottom = as.integer(s_ibottom) 
  
  if(length(s_ibottom) > 1) {
    Rf_warning("using only the first element of s_ibottom")
  }
  
  .Call('R_swig_maximum_psi_struct_ibottom_set', self, s_ibottom, PACKAGE='iris')
  
}

attr(`maximum_psi_struct_ibottom_set`, 'returnType') = 'void'
attr(`maximum_psi_struct_ibottom_set`, "inputTypes") = c('_p_maximum_psi_struct', 'numeric')
class(`maximum_psi_struct_ibottom_set`) = c("SWIGFunction", class('maximum_psi_struct_ibottom_set'))

# Start of maximum_psi_struct_ibottom_get

`maximum_psi_struct_ibottom_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  .Call('R_swig_maximum_psi_struct_ibottom_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`maximum_psi_struct_ibottom_get`, 'returnType') = 'numeric'
attr(`maximum_psi_struct_ibottom_get`, "inputTypes") = c('_p_maximum_psi_struct')
class(`maximum_psi_struct_ibottom_get`) = c("SWIGFunction", class('maximum_psi_struct_ibottom_get'))

# Start of maximum_psi_struct_itop_set

`maximum_psi_struct_itop_set` = function(self, s_itop)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  s_itop = as.integer(s_itop) 
  
  if(length(s_itop) > 1) {
    Rf_warning("using only the first element of s_itop")
  }
  
  .Call('R_swig_maximum_psi_struct_itop_set', self, s_itop, PACKAGE='iris')
  
}

attr(`maximum_psi_struct_itop_set`, 'returnType') = 'void'
attr(`maximum_psi_struct_itop_set`, "inputTypes") = c('_p_maximum_psi_struct', 'numeric')
class(`maximum_psi_struct_itop_set`) = c("SWIGFunction", class('maximum_psi_struct_itop_set'))

# Start of maximum_psi_struct_itop_get

`maximum_psi_struct_itop_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  .Call('R_swig_maximum_psi_struct_itop_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`maximum_psi_struct_itop_get`, 'returnType') = 'numeric'
attr(`maximum_psi_struct_itop_get`, "inputTypes") = c('_p_maximum_psi_struct')
class(`maximum_psi_struct_itop_get`) = c("SWIGFunction", class('maximum_psi_struct_itop_get'))

# Start of maximum_psi_struct_iside_size_set

`maximum_psi_struct_iside_size_set` = function(self, s_iside_size)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  s_iside_size = as.integer(s_iside_size) 
  
  if(length(s_iside_size) > 1) {
    Rf_warning("using only the first element of s_iside_size")
  }
  
  .Call('R_swig_maximum_psi_struct_iside_size_set', self, s_iside_size, PACKAGE='iris')
  
}

attr(`maximum_psi_struct_iside_size_set`, 'returnType') = 'void'
attr(`maximum_psi_struct_iside_size_set`, "inputTypes") = c('_p_maximum_psi_struct', 'numeric')
class(`maximum_psi_struct_iside_size_set`) = c("SWIGFunction", class('maximum_psi_struct_iside_size_set'))

# Start of maximum_psi_struct_iside_size_get

`maximum_psi_struct_iside_size_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  .Call('R_swig_maximum_psi_struct_iside_size_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`maximum_psi_struct_iside_size_get`, 'returnType') = 'numeric'
attr(`maximum_psi_struct_iside_size_get`, "inputTypes") = c('_p_maximum_psi_struct')
class(`maximum_psi_struct_iside_size_get`) = c("SWIGFunction", class('maximum_psi_struct_iside_size_get'))

# Start of maximum_psi_struct_ihorz_smooth_set

`maximum_psi_struct_ihorz_smooth_set` = function(self, s_ihorz_smooth)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  s_ihorz_smooth = coerceIfNotSubclass(s_ihorz_smooth, "_p_short") 
  .Call('R_swig_maximum_psi_struct_ihorz_smooth_set', self, s_ihorz_smooth, PACKAGE='iris')
  
}

attr(`maximum_psi_struct_ihorz_smooth_set`, 'returnType') = 'void'
attr(`maximum_psi_struct_ihorz_smooth_set`, "inputTypes") = c('_p_maximum_psi_struct', '_p_short')
class(`maximum_psi_struct_ihorz_smooth_set`) = c("SWIGFunction", class('maximum_psi_struct_ihorz_smooth_set'))

# Start of maximum_psi_struct_ihorz_smooth_get

`maximum_psi_struct_ihorz_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  ans = .Call('R_swig_maximum_psi_struct_ihorz_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`maximum_psi_struct_ihorz_smooth_get`, 'returnType') = '_p_short'
attr(`maximum_psi_struct_ihorz_smooth_get`, "inputTypes") = c('_p_maximum_psi_struct')
class(`maximum_psi_struct_ihorz_smooth_get`) = c("SWIGFunction", class('maximum_psi_struct_ihorz_smooth_get'))

# Start of maximum_psi_struct_ivert_smooth_set

`maximum_psi_struct_ivert_smooth_set` = function(self, s_ivert_smooth)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  s_ivert_smooth = coerceIfNotSubclass(s_ivert_smooth, "_p_short") 
  .Call('R_swig_maximum_psi_struct_ivert_smooth_set', self, s_ivert_smooth, PACKAGE='iris')
  
}

attr(`maximum_psi_struct_ivert_smooth_set`, 'returnType') = 'void'
attr(`maximum_psi_struct_ivert_smooth_set`, "inputTypes") = c('_p_maximum_psi_struct', '_p_short')
class(`maximum_psi_struct_ivert_smooth_set`) = c("SWIGFunction", class('maximum_psi_struct_ivert_smooth_set'))

# Start of maximum_psi_struct_ivert_smooth_get

`maximum_psi_struct_ivert_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  ans = .Call('R_swig_maximum_psi_struct_ivert_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`maximum_psi_struct_ivert_smooth_get`, 'returnType') = '_p_short'
attr(`maximum_psi_struct_ivert_smooth_get`, "inputTypes") = c('_p_maximum_psi_struct')
class(`maximum_psi_struct_ivert_smooth_get`) = c("SWIGFunction", class('maximum_psi_struct_ivert_smooth_get'))

# Start of maximum_psi_struct_ipad_end_set

`maximum_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -20)
  
  .Call('R_swig_maximum_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`maximum_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`maximum_psi_struct_ipad_end_set`, "inputTypes") = c('_p_maximum_psi_struct', '_p_char')
class(`maximum_psi_struct_ipad_end_set`) = c("SWIGFunction", class('maximum_psi_struct_ipad_end_set'))

# Start of maximum_psi_struct_ipad_end_get

`maximum_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  ans = .Call('R_swig_maximum_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`maximum_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`maximum_psi_struct_ipad_end_get`, "inputTypes") = c('_p_maximum_psi_struct')
class(`maximum_psi_struct_ipad_end_get`) = c("SWIGFunction", class('maximum_psi_struct_ipad_end_get'))

# Start of new_maximum_psi_struct

`maximum_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_maximum_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_maximum_psi_struct"
  
  ans
  
}

attr(`maximum_psi_struct`, 'returnType') = '_p_maximum_psi_struct'
class(`maximum_psi_struct`) = c("SWIGFunction", class('maximum_psi_struct'))

# Start of delete_maximum_psi_struct

`delete_maximum_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_maximum_psi_struct") 
  .Call('R_swig_delete_maximum_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_maximum_psi_struct`, 'returnType') = 'void'
attr(`delete_maximum_psi_struct`, "inputTypes") = c('_p_maximum_psi_struct')
class(`delete_maximum_psi_struct`) = c("SWIGFunction", class('delete_maximum_psi_struct'))

# Start of accessor method for maximum_psi_struct
setMethod('$', '_p_maximum_psi_struct', function(x, name)

{
  accessorFuns = list('ipad0x4' = maximum_psi_struct_ipad0x4_get, 'ibottom' = maximum_psi_struct_ibottom_get, 'itop' = maximum_psi_struct_itop_get, 'iside_size' = maximum_psi_struct_iside_size_get, 'ihorz_smooth' = maximum_psi_struct_ihorz_smooth_get, 'ivert_smooth' = maximum_psi_struct_ivert_smooth_get, 'ipad_end' = maximum_psi_struct_ipad_end_get)
  vaccessors = c('ipad0x4', 'ibottom', 'itop', 'iside_size', 'ihorz_smooth', 'ivert_smooth', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for maximum_psi_struct
# Start of accessor method for maximum_psi_struct
setMethod('$<-', '_p_maximum_psi_struct', function(x, name, value)

{
  accessorFuns = list('ipad0x4' = maximum_psi_struct_ipad0x4_set, 'ibottom' = maximum_psi_struct_ibottom_set, 'itop' = maximum_psi_struct_itop_set, 'iside_size' = maximum_psi_struct_iside_size_set, 'ihorz_smooth' = maximum_psi_struct_ihorz_smooth_set, 'ivert_smooth' = maximum_psi_struct_ivert_smooth_set, 'ipad_end' = maximum_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_maximum_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ipad0x4' = maximum_psi_struct_ipad0x4_set, 'ibottom' = maximum_psi_struct_ibottom_set, 'itop' = maximum_psi_struct_itop_set, 'iside_size' = maximum_psi_struct_iside_size_set, 'ihorz_smooth' = maximum_psi_struct_ihorz_smooth_set, 'ivert_smooth' = maximum_psi_struct_ivert_smooth_set, 'ipad_end' = maximum_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for maximum_psi_struct
setMethod('delete', '_p_maximum_psi_struct', function(obj) {delete_maximum_psi_struct(obj)})
# Start definition of copy functions & methods for maximum_psi_struct
CopyToR_maximum_psi_struct = function(value, obj = new("maximum_psi_struct"))
{
  obj@ipad0x4 = value$ipad0x4
  obj@ibottom = value$ibottom
  obj@itop = value$itop
  obj@iside_size = value$iside_size
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_maximum_psi_struct = function(value, obj)
{
  obj$ipad0x4 = value@ipad0x4
  obj$ibottom = value@ibottom
  obj$itop = value@itop
  obj$iside_size = value@iside_size
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for maximum_psi_struct
setMethod('copyToR', '_p_maximum_psi_struct', CopyToR_maximum_psi_struct)
setMethod('copyToC', 'maximum_psi_struct', CopyToC_maximum_psi_struct)

# End definition of copy methods for maximum_psi_struct
# End definition of copy functions & methods for maximum_psi_struct
# Start of ndop_input_sTName_set

`ndop_input_sTName_set` = function(self, s_sTName)
{
  self = coerceIfNotSubclass(self, "_p_ndop_input") 
  
  if(is.list(s_sTName))
  assert(all(sapply(s_sTName, class) == "_p_char"))     
  
  
#  assert(length(s_sTName) >= 12)
  
  .Call('R_swig_ndop_input_sTName_set', self, s_sTName, PACKAGE='iris')
  
}

attr(`ndop_input_sTName_set`, 'returnType') = 'void'
attr(`ndop_input_sTName_set`, "inputTypes") = c('_p_ndop_input', '_p_char')
class(`ndop_input_sTName_set`) = c("SWIGFunction", class('ndop_input_sTName_set'))

# Start of ndop_input_sTName_get

`ndop_input_sTName_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_input") 
  ans = .Call('R_swig_ndop_input_sTName_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ndop_input_sTName_get`, 'returnType') = '_p_char'
attr(`ndop_input_sTName_get`, "inputTypes") = c('_p_ndop_input')
class(`ndop_input_sTName_get`) = c("SWIGFunction", class('ndop_input_sTName_get'))

# Start of ndop_input_sSiteId_set

`ndop_input_sSiteId_set` = function(self, s_sSiteId)
{
  self = coerceIfNotSubclass(self, "_p_ndop_input") 
  
  if(is.list(s_sSiteId))
  assert(all(sapply(s_sSiteId, class) == "_p_char"))     
  
  
#  assert(length(s_sSiteId) >= 3)
  
  .Call('R_swig_ndop_input_sSiteId_set', self, s_sSiteId, PACKAGE='iris')
  
}

attr(`ndop_input_sSiteId_set`, 'returnType') = 'void'
attr(`ndop_input_sSiteId_set`, "inputTypes") = c('_p_ndop_input', '_p_char')
class(`ndop_input_sSiteId_set`) = c("SWIGFunction", class('ndop_input_sSiteId_set'))

# Start of ndop_input_sSiteId_get

`ndop_input_sSiteId_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_input") 
  ans = .Call('R_swig_ndop_input_sSiteId_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ndop_input_sSiteId_get`, 'returnType') = '_p_char'
attr(`ndop_input_sSiteId_get`, "inputTypes") = c('_p_ndop_input')
class(`ndop_input_sSiteId_get`) = c("SWIGFunction", class('ndop_input_sSiteId_get'))

# Start of ndop_input_iflags_set

`ndop_input_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_ndop_input") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_unsigned_char") 
  .Call('R_swig_ndop_input_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`ndop_input_iflags_set`, 'returnType') = 'void'
attr(`ndop_input_iflags_set`, "inputTypes") = c('_p_ndop_input', '_p_unsigned_char')
class(`ndop_input_iflags_set`) = c("SWIGFunction", class('ndop_input_iflags_set'))

# Start of ndop_input_iflags_get

`ndop_input_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_input") 
  ans = .Call('R_swig_ndop_input_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`ndop_input_iflags_get`, 'returnType') = '_p_unsigned_char'
attr(`ndop_input_iflags_get`, "inputTypes") = c('_p_ndop_input')
class(`ndop_input_iflags_get`) = c("SWIGFunction", class('ndop_input_iflags_get'))

# Start of new_ndop_input

`ndop_input` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ndop_input', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ndop_input"
  
  ans
  
}

attr(`ndop_input`, 'returnType') = '_p_ndop_input'
class(`ndop_input`) = c("SWIGFunction", class('ndop_input'))

# Start of delete_ndop_input

`delete_ndop_input` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ndop_input") 
  .Call('R_swig_delete_ndop_input', self, PACKAGE='iris')
  
}

attr(`delete_ndop_input`, 'returnType') = 'void'
attr(`delete_ndop_input`, "inputTypes") = c('_p_ndop_input')
class(`delete_ndop_input`) = c("SWIGFunction", class('delete_ndop_input'))

# Start of accessor method for ndop_input
setMethod('$', '_p_ndop_input', function(x, name)

{
  accessorFuns = list('sTName' = ndop_input_sTName_get, 'sSiteId' = ndop_input_sSiteId_get, 'iflags' = ndop_input_iflags_get)
  vaccessors = c('sTName', 'sSiteId', 'iflags')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ndop_input
# Start of accessor method for ndop_input
setMethod('$<-', '_p_ndop_input', function(x, name, value)

{
  accessorFuns = list('sTName' = ndop_input_sTName_set, 'sSiteId' = ndop_input_sSiteId_set, 'iflags' = ndop_input_iflags_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ndop_input', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('sTName' = ndop_input_sTName_set, 'sSiteId' = ndop_input_sSiteId_set, 'iflags' = ndop_input_iflags_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ndop_input
setMethod('delete', '_p_ndop_input', function(obj) {delete_ndop_input(obj)})
# Start definition of copy functions & methods for ndop_input
CopyToR_ndop_input = function(value, obj = new("ndop_input"))
{
  obj@sTName = value$sTName
  obj@sSiteId = value$sSiteId
  obj
}



CopyToC_ndop_input = function(value, obj)
{
  obj$sTName = value@sTName
  obj$sSiteId = value@sSiteId
  obj
}



# Start definition of copy methods for ndop_input
setMethod('copyToR', '_p_ndop_input', CopyToR_ndop_input)
setMethod('copyToC', 'ndop_input', CopyToC_ndop_input)

# End definition of copy methods for ndop_input
# End definition of copy functions & methods for ndop_input
# Start of ndop_psi_struct_Inputs_set

`ndop_psi_struct_Inputs_set` = function(self, s_Inputs)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  
  if(is.list(s_Inputs))
  assert(all(sapply(s_Inputs, class) == "_p_ndop_input"))     
  
  
#  assert(length(s_Inputs) >= 3)
  
  .Call('R_swig_ndop_psi_struct_Inputs_set', self, s_Inputs, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_Inputs_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_Inputs_set`, "inputTypes") = c('_p_ndop_psi_struct', '_p_ndop_input')
class(`ndop_psi_struct_Inputs_set`) = c("SWIGFunction", class('ndop_psi_struct_Inputs_set'))

# Start of ndop_psi_struct_Inputs_get

`ndop_psi_struct_Inputs_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  ans = .Call('R_swig_ndop_psi_struct_Inputs_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ndop_input"
  
  ans
  
}

attr(`ndop_psi_struct_Inputs_get`, 'returnType') = '_p_ndop_input'
attr(`ndop_psi_struct_Inputs_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_Inputs_get`) = c("SWIGFunction", class('ndop_psi_struct_Inputs_get'))

# Start of ndop_psi_struct_iTimeWindow_set

`ndop_psi_struct_iTimeWindow_set` = function(self, s_iTimeWindow)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  s_iTimeWindow = as.integer(s_iTimeWindow) 
  
  if(length(s_iTimeWindow) > 1) {
    Rf_warning("using only the first element of s_iTimeWindow")
  }
  
  .Call('R_swig_ndop_psi_struct_iTimeWindow_set', self, s_iTimeWindow, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iTimeWindow_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_iTimeWindow_set`, "inputTypes") = c('_p_ndop_psi_struct', 'numeric')
class(`ndop_psi_struct_iTimeWindow_set`) = c("SWIGFunction", class('ndop_psi_struct_iTimeWindow_set'))

# Start of ndop_psi_struct_iTimeWindow_get

`ndop_psi_struct_iTimeWindow_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  .Call('R_swig_ndop_psi_struct_iTimeWindow_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iTimeWindow_get`, 'returnType') = 'numeric'
attr(`ndop_psi_struct_iTimeWindow_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_iTimeWindow_get`) = c("SWIGFunction", class('ndop_psi_struct_iTimeWindow_get'))

# Start of ndop_psi_struct_iCappiHeight_set

`ndop_psi_struct_iCappiHeight_set` = function(self, s_iCappiHeight)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  s_iCappiHeight = as.integer(s_iCappiHeight) 
  
  if(length(s_iCappiHeight) > 1) {
    Rf_warning("using only the first element of s_iCappiHeight")
  }
  
  .Call('R_swig_ndop_psi_struct_iCappiHeight_set', self, s_iCappiHeight, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iCappiHeight_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_iCappiHeight_set`, "inputTypes") = c('_p_ndop_psi_struct', 'numeric')
class(`ndop_psi_struct_iCappiHeight_set`) = c("SWIGFunction", class('ndop_psi_struct_iCappiHeight_set'))

# Start of ndop_psi_struct_iCappiHeight_get

`ndop_psi_struct_iCappiHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  .Call('R_swig_ndop_psi_struct_iCappiHeight_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iCappiHeight_get`, 'returnType') = 'numeric'
attr(`ndop_psi_struct_iCappiHeight_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_iCappiHeight_get`) = c("SWIGFunction", class('ndop_psi_struct_iCappiHeight_get'))

# Start of ndop_psi_struct_iOutputResolution_set

`ndop_psi_struct_iOutputResolution_set` = function(self, s_iOutputResolution)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  s_iOutputResolution = as.integer(s_iOutputResolution) 
  
  if(length(s_iOutputResolution) > 1) {
    Rf_warning("using only the first element of s_iOutputResolution")
  }
  
  .Call('R_swig_ndop_psi_struct_iOutputResolution_set', self, s_iOutputResolution, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iOutputResolution_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_iOutputResolution_set`, "inputTypes") = c('_p_ndop_psi_struct', 'numeric')
class(`ndop_psi_struct_iOutputResolution_set`) = c("SWIGFunction", class('ndop_psi_struct_iOutputResolution_set'))

# Start of ndop_psi_struct_iOutputResolution_get

`ndop_psi_struct_iOutputResolution_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  .Call('R_swig_ndop_psi_struct_iOutputResolution_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iOutputResolution_get`, 'returnType') = 'numeric'
attr(`ndop_psi_struct_iOutputResolution_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_iOutputResolution_get`) = c("SWIGFunction", class('ndop_psi_struct_iOutputResolution_get'))

# Start of ndop_psi_struct_iMinCrossingAngle_set

`ndop_psi_struct_iMinCrossingAngle_set` = function(self, s_iMinCrossingAngle)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  s_iMinCrossingAngle = as.numeric(s_iMinCrossingAngle) 
  
  assert(length(s_iMinCrossingAngle) == 1 && s_iMinCrossingAngle >= 0, "All values must be non-negative")
  
  .Call('R_swig_ndop_psi_struct_iMinCrossingAngle_set', self, s_iMinCrossingAngle, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iMinCrossingAngle_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_iMinCrossingAngle_set`, "inputTypes") = c('_p_ndop_psi_struct', 'numeric')
class(`ndop_psi_struct_iMinCrossingAngle_set`) = c("SWIGFunction", class('ndop_psi_struct_iMinCrossingAngle_set'))

# Start of ndop_psi_struct_iMinCrossingAngle_get

`ndop_psi_struct_iMinCrossingAngle_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  .Call('R_swig_ndop_psi_struct_iMinCrossingAngle_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iMinCrossingAngle_get`, 'returnType') = 'numeric'
attr(`ndop_psi_struct_iMinCrossingAngle_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_iMinCrossingAngle_get`) = c("SWIGFunction", class('ndop_psi_struct_iMinCrossingAngle_get'))

# Start of ndop_psi_struct_iFlags_set

`ndop_psi_struct_iFlags_set` = function(self, s_iFlags)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  s_iFlags = as.numeric(s_iFlags) 
  
  assert(length(s_iFlags) == 1 && s_iFlags >= 0, "All values must be non-negative")
  
  .Call('R_swig_ndop_psi_struct_iFlags_set', self, s_iFlags, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iFlags_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_iFlags_set`, "inputTypes") = c('_p_ndop_psi_struct', 'numeric')
class(`ndop_psi_struct_iFlags_set`) = c("SWIGFunction", class('ndop_psi_struct_iFlags_set'))

# Start of ndop_psi_struct_iFlags_get

`ndop_psi_struct_iFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  .Call('R_swig_ndop_psi_struct_iFlags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ndop_psi_struct_iFlags_get`, 'returnType') = 'numeric'
attr(`ndop_psi_struct_iFlags_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_iFlags_get`) = c("SWIGFunction", class('ndop_psi_struct_iFlags_get'))

# Start of ndop_psi_struct_sSiteOut_set

`ndop_psi_struct_sSiteOut_set` = function(self, s_sSiteOut)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  
  if(is.list(s_sSiteOut))
  assert(all(sapply(s_sSiteOut, class) == "_p_char"))     
  
  
#  assert(length(s_sSiteOut) >= 4)
  
  .Call('R_swig_ndop_psi_struct_sSiteOut_set', self, s_sSiteOut, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_sSiteOut_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_sSiteOut_set`, "inputTypes") = c('_p_ndop_psi_struct', '_p_char')
class(`ndop_psi_struct_sSiteOut_set`) = c("SWIGFunction", class('ndop_psi_struct_sSiteOut_set'))

# Start of ndop_psi_struct_sSiteOut_get

`ndop_psi_struct_sSiteOut_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  ans = .Call('R_swig_ndop_psi_struct_sSiteOut_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ndop_psi_struct_sSiteOut_get`, 'returnType') = '_p_char'
attr(`ndop_psi_struct_sSiteOut_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_sSiteOut_get`) = c("SWIGFunction", class('ndop_psi_struct_sSiteOut_get'))

# Start of ndop_psi_struct_ipad_end_set

`ndop_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -72)
  
  .Call('R_swig_ndop_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`ndop_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`ndop_psi_struct_ipad_end_set`, "inputTypes") = c('_p_ndop_psi_struct', '_p_char')
class(`ndop_psi_struct_ipad_end_set`) = c("SWIGFunction", class('ndop_psi_struct_ipad_end_set'))

# Start of ndop_psi_struct_ipad_end_get

`ndop_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  ans = .Call('R_swig_ndop_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ndop_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`ndop_psi_struct_ipad_end_get`, "inputTypes") = c('_p_ndop_psi_struct')
class(`ndop_psi_struct_ipad_end_get`) = c("SWIGFunction", class('ndop_psi_struct_ipad_end_get'))

# Start of new_ndop_psi_struct

`ndop_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ndop_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ndop_psi_struct"
  
  ans
  
}

attr(`ndop_psi_struct`, 'returnType') = '_p_ndop_psi_struct'
class(`ndop_psi_struct`) = c("SWIGFunction", class('ndop_psi_struct'))

# Start of delete_ndop_psi_struct

`delete_ndop_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ndop_psi_struct") 
  .Call('R_swig_delete_ndop_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_ndop_psi_struct`, 'returnType') = 'void'
attr(`delete_ndop_psi_struct`, "inputTypes") = c('_p_ndop_psi_struct')
class(`delete_ndop_psi_struct`) = c("SWIGFunction", class('delete_ndop_psi_struct'))

# Start of accessor method for ndop_psi_struct
setMethod('$', '_p_ndop_psi_struct', function(x, name)

{
  accessorFuns = list('Inputs' = ndop_psi_struct_Inputs_get, 'iTimeWindow' = ndop_psi_struct_iTimeWindow_get, 'iCappiHeight' = ndop_psi_struct_iCappiHeight_get, 'iOutputResolution' = ndop_psi_struct_iOutputResolution_get, 'iMinCrossingAngle' = ndop_psi_struct_iMinCrossingAngle_get, 'iFlags' = ndop_psi_struct_iFlags_get, 'sSiteOut' = ndop_psi_struct_sSiteOut_get, 'ipad_end' = ndop_psi_struct_ipad_end_get)
  vaccessors = c('Inputs', 'iTimeWindow', 'iCappiHeight', 'iOutputResolution', 'iMinCrossingAngle', 'iFlags', 'sSiteOut', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ndop_psi_struct
# Start of accessor method for ndop_psi_struct
setMethod('$<-', '_p_ndop_psi_struct', function(x, name, value)

{
  accessorFuns = list('Inputs' = ndop_psi_struct_Inputs_set, 'iTimeWindow' = ndop_psi_struct_iTimeWindow_set, 'iCappiHeight' = ndop_psi_struct_iCappiHeight_set, 'iOutputResolution' = ndop_psi_struct_iOutputResolution_set, 'iMinCrossingAngle' = ndop_psi_struct_iMinCrossingAngle_set, 'iFlags' = ndop_psi_struct_iFlags_set, 'sSiteOut' = ndop_psi_struct_sSiteOut_set, 'ipad_end' = ndop_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ndop_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('Inputs' = ndop_psi_struct_Inputs_set, 'iTimeWindow' = ndop_psi_struct_iTimeWindow_set, 'iCappiHeight' = ndop_psi_struct_iCappiHeight_set, 'iOutputResolution' = ndop_psi_struct_iOutputResolution_set, 'iMinCrossingAngle' = ndop_psi_struct_iMinCrossingAngle_set, 'iFlags' = ndop_psi_struct_iFlags_set, 'sSiteOut' = ndop_psi_struct_sSiteOut_set, 'ipad_end' = ndop_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ndop_psi_struct
setMethod('delete', '_p_ndop_psi_struct', function(obj) {delete_ndop_psi_struct(obj)})
# Start definition of copy functions & methods for ndop_psi_struct
CopyToR_ndop_psi_struct = function(value, obj = new("ndop_psi_struct"))
{
  obj@iTimeWindow = value$iTimeWindow
  obj@iCappiHeight = value$iCappiHeight
  obj@iOutputResolution = value$iOutputResolution
  obj@iMinCrossingAngle = value$iMinCrossingAngle
  obj@iFlags = value$iFlags
  obj@sSiteOut = value$sSiteOut
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_ndop_psi_struct = function(value, obj)
{
  obj$iTimeWindow = value@iTimeWindow
  obj$iCappiHeight = value@iCappiHeight
  obj$iOutputResolution = value@iOutputResolution
  obj$iMinCrossingAngle = value@iMinCrossingAngle
  obj$iFlags = value@iFlags
  obj$sSiteOut = value@sSiteOut
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for ndop_psi_struct
setMethod('copyToR', '_p_ndop_psi_struct', CopyToR_ndop_psi_struct)
setMethod('copyToC', 'ndop_psi_struct', CopyToC_ndop_psi_struct)

# End definition of copy methods for ndop_psi_struct
# End definition of copy functions & methods for ndop_psi_struct
# Start of ppi_psi_struct_ippi_el_set

`ppi_psi_struct_ippi_el_set` = function(self, s_ippi_el)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  s_ippi_el = coerceIfNotSubclass(s_ippi_el, "_p_unsigned_short") 
  .Call('R_swig_ppi_psi_struct_ippi_el_set', self, s_ippi_el, PACKAGE='iris')
  
}

attr(`ppi_psi_struct_ippi_el_set`, 'returnType') = 'void'
attr(`ppi_psi_struct_ippi_el_set`, "inputTypes") = c('_p_ppi_psi_struct', '_p_unsigned_short')
class(`ppi_psi_struct_ippi_el_set`) = c("SWIGFunction", class('ppi_psi_struct_ippi_el_set'))

# Start of ppi_psi_struct_ippi_el_get

`ppi_psi_struct_ippi_el_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  ans = .Call('R_swig_ppi_psi_struct_ippi_el_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ppi_psi_struct_ippi_el_get`, 'returnType') = '_p_unsigned_short'
attr(`ppi_psi_struct_ippi_el_get`, "inputTypes") = c('_p_ppi_psi_struct')
class(`ppi_psi_struct_ippi_el_get`) = c("SWIGFunction", class('ppi_psi_struct_ippi_el_get'))

# Start of ppi_psi_struct_ipad2x2_set

`ppi_psi_struct_ipad2x2_set` = function(self, s_ipad2x2)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  
  if(is.list(s_ipad2x2))
  assert(all(sapply(s_ipad2x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad2x2) >= 2)
  
  .Call('R_swig_ppi_psi_struct_ipad2x2_set', self, s_ipad2x2, PACKAGE='iris')
  
}

attr(`ppi_psi_struct_ipad2x2_set`, 'returnType') = 'void'
attr(`ppi_psi_struct_ipad2x2_set`, "inputTypes") = c('_p_ppi_psi_struct', '_p_char')
class(`ppi_psi_struct_ipad2x2_set`) = c("SWIGFunction", class('ppi_psi_struct_ipad2x2_set'))

# Start of ppi_psi_struct_ipad2x2_get

`ppi_psi_struct_ipad2x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  ans = .Call('R_swig_ppi_psi_struct_ipad2x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ppi_psi_struct_ipad2x2_get`, 'returnType') = '_p_char'
attr(`ppi_psi_struct_ipad2x2_get`, "inputTypes") = c('_p_ppi_psi_struct')
class(`ppi_psi_struct_ipad2x2_get`) = c("SWIGFunction", class('ppi_psi_struct_ipad2x2_get'))

# Start of ppi_psi_struct_iMaxRange_set

`ppi_psi_struct_iMaxRange_set` = function(self, s_iMaxRange)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  s_iMaxRange = as.integer(s_iMaxRange) 
  
  if(length(s_iMaxRange) > 1) {
    Rf_warning("using only the first element of s_iMaxRange")
  }
  
  .Call('R_swig_ppi_psi_struct_iMaxRange_set', self, s_iMaxRange, PACKAGE='iris')
  
}

attr(`ppi_psi_struct_iMaxRange_set`, 'returnType') = 'void'
attr(`ppi_psi_struct_iMaxRange_set`, "inputTypes") = c('_p_ppi_psi_struct', 'numeric')
class(`ppi_psi_struct_iMaxRange_set`) = c("SWIGFunction", class('ppi_psi_struct_iMaxRange_set'))

# Start of ppi_psi_struct_iMaxRange_get

`ppi_psi_struct_iMaxRange_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  .Call('R_swig_ppi_psi_struct_iMaxRange_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ppi_psi_struct_iMaxRange_get`, 'returnType') = 'numeric'
attr(`ppi_psi_struct_iMaxRange_get`, "inputTypes") = c('_p_ppi_psi_struct')
class(`ppi_psi_struct_iMaxRange_get`) = c("SWIGFunction", class('ppi_psi_struct_iMaxRange_get'))

# Start of ppi_psi_struct_iMaxHeight_set

`ppi_psi_struct_iMaxHeight_set` = function(self, s_iMaxHeight)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  s_iMaxHeight = as.integer(s_iMaxHeight) 
  
  if(length(s_iMaxHeight) > 1) {
    Rf_warning("using only the first element of s_iMaxHeight")
  }
  
  .Call('R_swig_ppi_psi_struct_iMaxHeight_set', self, s_iMaxHeight, PACKAGE='iris')
  
}

attr(`ppi_psi_struct_iMaxHeight_set`, 'returnType') = 'void'
attr(`ppi_psi_struct_iMaxHeight_set`, "inputTypes") = c('_p_ppi_psi_struct', 'numeric')
class(`ppi_psi_struct_iMaxHeight_set`) = c("SWIGFunction", class('ppi_psi_struct_iMaxHeight_set'))

# Start of ppi_psi_struct_iMaxHeight_get

`ppi_psi_struct_iMaxHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  .Call('R_swig_ppi_psi_struct_iMaxHeight_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ppi_psi_struct_iMaxHeight_get`, 'returnType') = 'numeric'
attr(`ppi_psi_struct_iMaxHeight_get`, "inputTypes") = c('_p_ppi_psi_struct')
class(`ppi_psi_struct_iMaxHeight_get`) = c("SWIGFunction", class('ppi_psi_struct_iMaxHeight_get'))

# Start of ppi_psi_struct_ipad_end_set

`ppi_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -12)
  
  .Call('R_swig_ppi_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`ppi_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`ppi_psi_struct_ipad_end_set`, "inputTypes") = c('_p_ppi_psi_struct', '_p_char')
class(`ppi_psi_struct_ipad_end_set`) = c("SWIGFunction", class('ppi_psi_struct_ipad_end_set'))

# Start of ppi_psi_struct_ipad_end_get

`ppi_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  ans = .Call('R_swig_ppi_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ppi_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`ppi_psi_struct_ipad_end_get`, "inputTypes") = c('_p_ppi_psi_struct')
class(`ppi_psi_struct_ipad_end_get`) = c("SWIGFunction", class('ppi_psi_struct_ipad_end_get'))

# Start of new_ppi_psi_struct

`ppi_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ppi_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ppi_psi_struct"
  
  ans
  
}

attr(`ppi_psi_struct`, 'returnType') = '_p_ppi_psi_struct'
class(`ppi_psi_struct`) = c("SWIGFunction", class('ppi_psi_struct'))

# Start of delete_ppi_psi_struct

`delete_ppi_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ppi_psi_struct") 
  .Call('R_swig_delete_ppi_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_ppi_psi_struct`, 'returnType') = 'void'
attr(`delete_ppi_psi_struct`, "inputTypes") = c('_p_ppi_psi_struct')
class(`delete_ppi_psi_struct`) = c("SWIGFunction", class('delete_ppi_psi_struct'))

# Start of accessor method for ppi_psi_struct
setMethod('$', '_p_ppi_psi_struct', function(x, name)

{
  accessorFuns = list('ippi_el' = ppi_psi_struct_ippi_el_get, 'ipad2x2' = ppi_psi_struct_ipad2x2_get, 'iMaxRange' = ppi_psi_struct_iMaxRange_get, 'iMaxHeight' = ppi_psi_struct_iMaxHeight_get, 'ipad_end' = ppi_psi_struct_ipad_end_get)
  vaccessors = c('ippi_el', 'ipad2x2', 'iMaxRange', 'iMaxHeight', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ppi_psi_struct
# Start of accessor method for ppi_psi_struct
setMethod('$<-', '_p_ppi_psi_struct', function(x, name, value)

{
  accessorFuns = list('ippi_el' = ppi_psi_struct_ippi_el_set, 'ipad2x2' = ppi_psi_struct_ipad2x2_set, 'iMaxRange' = ppi_psi_struct_iMaxRange_set, 'iMaxHeight' = ppi_psi_struct_iMaxHeight_set, 'ipad_end' = ppi_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ppi_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ippi_el' = ppi_psi_struct_ippi_el_set, 'ipad2x2' = ppi_psi_struct_ipad2x2_set, 'iMaxRange' = ppi_psi_struct_iMaxRange_set, 'iMaxHeight' = ppi_psi_struct_iMaxHeight_set, 'ipad_end' = ppi_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ppi_psi_struct
setMethod('delete', '_p_ppi_psi_struct', function(obj) {delete_ppi_psi_struct(obj)})
# Start definition of copy functions & methods for ppi_psi_struct
CopyToR_ppi_psi_struct = function(value, obj = new("ppi_psi_struct"))
{
  obj@ipad2x2 = value$ipad2x2
  obj@iMaxRange = value$iMaxRange
  obj@iMaxHeight = value$iMaxHeight
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_ppi_psi_struct = function(value, obj)
{
  obj$ipad2x2 = value@ipad2x2
  obj$iMaxRange = value@iMaxRange
  obj$iMaxHeight = value@iMaxHeight
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for ppi_psi_struct
setMethod('copyToR', '_p_ppi_psi_struct', CopyToR_ppi_psi_struct)
setMethod('copyToC', 'ppi_psi_struct', CopyToC_ppi_psi_struct)

# End definition of copy methods for ppi_psi_struct
# End definition of copy functions & methods for ppi_psi_struct
# Start of rain_psi_struct_irain1_minz_set

`rain_psi_struct_irain1_minz_set` = function(self, s_irain1_minz)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  s_irain1_minz = as.numeric(s_irain1_minz) 
  
  assert(length(s_irain1_minz) == 1 && s_irain1_minz >= 0, "All values must be non-negative")
  
  .Call('R_swig_rain_psi_struct_irain1_minz_set', self, s_irain1_minz, PACKAGE='iris')
  
}

attr(`rain_psi_struct_irain1_minz_set`, 'returnType') = 'void'
attr(`rain_psi_struct_irain1_minz_set`, "inputTypes") = c('_p_rain_psi_struct', 'numeric')
class(`rain_psi_struct_irain1_minz_set`) = c("SWIGFunction", class('rain_psi_struct_irain1_minz_set'))

# Start of rain_psi_struct_irain1_minz_get

`rain_psi_struct_irain1_minz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  .Call('R_swig_rain_psi_struct_irain1_minz_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`rain_psi_struct_irain1_minz_get`, 'returnType') = 'numeric'
attr(`rain_psi_struct_irain1_minz_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_irain1_minz_get`) = c("SWIGFunction", class('rain_psi_struct_irain1_minz_get'))

# Start of rain_psi_struct_iAverageGageFactor_set

`rain_psi_struct_iAverageGageFactor_set` = function(self, s_iAverageGageFactor)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  s_iAverageGageFactor = coerceIfNotSubclass(s_iAverageGageFactor, "_p_unsigned_short") 
  .Call('R_swig_rain_psi_struct_iAverageGageFactor_set', self, s_iAverageGageFactor, PACKAGE='iris')
  
}

attr(`rain_psi_struct_iAverageGageFactor_set`, 'returnType') = 'void'
attr(`rain_psi_struct_iAverageGageFactor_set`, "inputTypes") = c('_p_rain_psi_struct', '_p_unsigned_short')
class(`rain_psi_struct_iAverageGageFactor_set`) = c("SWIGFunction", class('rain_psi_struct_iAverageGageFactor_set'))

# Start of rain_psi_struct_iAverageGageFactor_get

`rain_psi_struct_iAverageGageFactor_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  ans = .Call('R_swig_rain_psi_struct_iAverageGageFactor_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`rain_psi_struct_iAverageGageFactor_get`, 'returnType') = '_p_unsigned_short'
attr(`rain_psi_struct_iAverageGageFactor_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_iAverageGageFactor_get`) = c("SWIGFunction", class('rain_psi_struct_iAverageGageFactor_get'))

# Start of rain_psi_struct_iSeconds_set

`rain_psi_struct_iSeconds_set` = function(self, s_iSeconds)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  s_iSeconds = coerceIfNotSubclass(s_iSeconds, "_p_unsigned_short") 
  .Call('R_swig_rain_psi_struct_iSeconds_set', self, s_iSeconds, PACKAGE='iris')
  
}

attr(`rain_psi_struct_iSeconds_set`, 'returnType') = 'void'
attr(`rain_psi_struct_iSeconds_set`, "inputTypes") = c('_p_rain_psi_struct', '_p_unsigned_short')
class(`rain_psi_struct_iSeconds_set`) = c("SWIGFunction", class('rain_psi_struct_iSeconds_set'))

# Start of rain_psi_struct_iSeconds_get

`rain_psi_struct_iSeconds_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  ans = .Call('R_swig_rain_psi_struct_iSeconds_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`rain_psi_struct_iSeconds_get`, 'returnType') = '_p_unsigned_short'
attr(`rain_psi_struct_iSeconds_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_iSeconds_get`) = c("SWIGFunction", class('rain_psi_struct_iSeconds_get'))

# Start of rain_psi_struct_irain_flags_set

`rain_psi_struct_irain_flags_set` = function(self, s_irain_flags)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  s_irain_flags = coerceIfNotSubclass(s_irain_flags, "_p_unsigned_short") 
  .Call('R_swig_rain_psi_struct_irain_flags_set', self, s_irain_flags, PACKAGE='iris')
  
}

attr(`rain_psi_struct_irain_flags_set`, 'returnType') = 'void'
attr(`rain_psi_struct_irain_flags_set`, "inputTypes") = c('_p_rain_psi_struct', '_p_unsigned_short')
class(`rain_psi_struct_irain_flags_set`) = c("SWIGFunction", class('rain_psi_struct_irain_flags_set'))

# Start of rain_psi_struct_irain_flags_get

`rain_psi_struct_irain_flags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  ans = .Call('R_swig_rain_psi_struct_irain_flags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`rain_psi_struct_irain_flags_get`, 'returnType') = '_p_unsigned_short'
attr(`rain_psi_struct_irain_flags_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_irain_flags_get`) = c("SWIGFunction", class('rain_psi_struct_irain_flags_get'))

# Start of rain_psi_struct_irainn_hours_set

`rain_psi_struct_irainn_hours_set` = function(self, s_irainn_hours)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  s_irainn_hours = coerceIfNotSubclass(s_irainn_hours, "_p_short") 
  .Call('R_swig_rain_psi_struct_irainn_hours_set', self, s_irainn_hours, PACKAGE='iris')
  
}

attr(`rain_psi_struct_irainn_hours_set`, 'returnType') = 'void'
attr(`rain_psi_struct_irainn_hours_set`, "inputTypes") = c('_p_rain_psi_struct', '_p_short')
class(`rain_psi_struct_irainn_hours_set`) = c("SWIGFunction", class('rain_psi_struct_irainn_hours_set'))

# Start of rain_psi_struct_irainn_hours_get

`rain_psi_struct_irainn_hours_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  ans = .Call('R_swig_rain_psi_struct_irainn_hours_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`rain_psi_struct_irainn_hours_get`, 'returnType') = '_p_short'
attr(`rain_psi_struct_irainn_hours_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_irainn_hours_get`) = c("SWIGFunction", class('rain_psi_struct_irainn_hours_get'))

# Start of rain_psi_struct_sproduct_set

`rain_psi_struct_sproduct_set` = function(self, s_sproduct)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  
  if(is.list(s_sproduct))
  assert(all(sapply(s_sproduct, class) == "_p_char"))     
  
  
#  assert(length(s_sproduct) >= 12)
  
  .Call('R_swig_rain_psi_struct_sproduct_set', self, s_sproduct, PACKAGE='iris')
  
}

attr(`rain_psi_struct_sproduct_set`, 'returnType') = 'void'
attr(`rain_psi_struct_sproduct_set`, "inputTypes") = c('_p_rain_psi_struct', '_p_char')
class(`rain_psi_struct_sproduct_set`) = c("SWIGFunction", class('rain_psi_struct_sproduct_set'))

# Start of rain_psi_struct_sproduct_get

`rain_psi_struct_sproduct_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  ans = .Call('R_swig_rain_psi_struct_sproduct_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`rain_psi_struct_sproduct_get`, 'returnType') = '_p_char'
attr(`rain_psi_struct_sproduct_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_sproduct_get`) = c("SWIGFunction", class('rain_psi_struct_sproduct_get'))

# Start of rain_psi_struct_iRain1Span_set

`rain_psi_struct_iRain1Span_set` = function(self, s_iRain1Span)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  s_iRain1Span = as.numeric(s_iRain1Span) 
  
  assert(length(s_iRain1Span) == 1 && s_iRain1Span >= 0, "All values must be non-negative")
  
  .Call('R_swig_rain_psi_struct_iRain1Span_set', self, s_iRain1Span, PACKAGE='iris')
  
}

attr(`rain_psi_struct_iRain1Span_set`, 'returnType') = 'void'
attr(`rain_psi_struct_iRain1Span_set`, "inputTypes") = c('_p_rain_psi_struct', 'numeric')
class(`rain_psi_struct_iRain1Span_set`) = c("SWIGFunction", class('rain_psi_struct_iRain1Span_set'))

# Start of rain_psi_struct_iRain1Span_get

`rain_psi_struct_iRain1Span_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  .Call('R_swig_rain_psi_struct_iRain1Span_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`rain_psi_struct_iRain1Span_get`, 'returnType') = 'numeric'
attr(`rain_psi_struct_iRain1Span_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_iRain1Span_get`) = c("SWIGFunction", class('rain_psi_struct_iRain1Span_get'))

# Start of rain_psi_struct_ipad_end_set

`rain_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -28)
  
  .Call('R_swig_rain_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`rain_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`rain_psi_struct_ipad_end_set`, "inputTypes") = c('_p_rain_psi_struct', '_p_char')
class(`rain_psi_struct_ipad_end_set`) = c("SWIGFunction", class('rain_psi_struct_ipad_end_set'))

# Start of rain_psi_struct_ipad_end_get

`rain_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  ans = .Call('R_swig_rain_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`rain_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`rain_psi_struct_ipad_end_get`, "inputTypes") = c('_p_rain_psi_struct')
class(`rain_psi_struct_ipad_end_get`) = c("SWIGFunction", class('rain_psi_struct_ipad_end_get'))

# Start of new_rain_psi_struct

`rain_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_rain_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_rain_psi_struct"
  
  ans
  
}

attr(`rain_psi_struct`, 'returnType') = '_p_rain_psi_struct'
class(`rain_psi_struct`) = c("SWIGFunction", class('rain_psi_struct'))

# Start of delete_rain_psi_struct

`delete_rain_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_rain_psi_struct") 
  .Call('R_swig_delete_rain_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_rain_psi_struct`, 'returnType') = 'void'
attr(`delete_rain_psi_struct`, "inputTypes") = c('_p_rain_psi_struct')
class(`delete_rain_psi_struct`) = c("SWIGFunction", class('delete_rain_psi_struct'))

# Start of accessor method for rain_psi_struct
setMethod('$', '_p_rain_psi_struct', function(x, name)

{
  accessorFuns = list('irain1_minz' = rain_psi_struct_irain1_minz_get, 'iAverageGageFactor' = rain_psi_struct_iAverageGageFactor_get, 'iSeconds' = rain_psi_struct_iSeconds_get, 'irain_flags' = rain_psi_struct_irain_flags_get, 'irainn_hours' = rain_psi_struct_irainn_hours_get, 'sproduct' = rain_psi_struct_sproduct_get, 'iRain1Span' = rain_psi_struct_iRain1Span_get, 'ipad_end' = rain_psi_struct_ipad_end_get)
  vaccessors = c('irain1_minz', 'iAverageGageFactor', 'iSeconds', 'irain_flags', 'irainn_hours', 'sproduct', 'iRain1Span', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for rain_psi_struct
# Start of accessor method for rain_psi_struct
setMethod('$<-', '_p_rain_psi_struct', function(x, name, value)

{
  accessorFuns = list('irain1_minz' = rain_psi_struct_irain1_minz_set, 'iAverageGageFactor' = rain_psi_struct_iAverageGageFactor_set, 'iSeconds' = rain_psi_struct_iSeconds_set, 'irain_flags' = rain_psi_struct_irain_flags_set, 'irainn_hours' = rain_psi_struct_irainn_hours_set, 'sproduct' = rain_psi_struct_sproduct_set, 'iRain1Span' = rain_psi_struct_iRain1Span_set, 'ipad_end' = rain_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_rain_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('irain1_minz' = rain_psi_struct_irain1_minz_set, 'iAverageGageFactor' = rain_psi_struct_iAverageGageFactor_set, 'iSeconds' = rain_psi_struct_iSeconds_set, 'irain_flags' = rain_psi_struct_irain_flags_set, 'irainn_hours' = rain_psi_struct_irainn_hours_set, 'sproduct' = rain_psi_struct_sproduct_set, 'iRain1Span' = rain_psi_struct_iRain1Span_set, 'ipad_end' = rain_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for rain_psi_struct
setMethod('delete', '_p_rain_psi_struct', function(obj) {delete_rain_psi_struct(obj)})
# Start definition of copy functions & methods for rain_psi_struct
CopyToR_rain_psi_struct = function(value, obj = new("rain_psi_struct"))
{
  obj@irain1_minz = value$irain1_minz
  obj@sproduct = value$sproduct
  obj@iRain1Span = value$iRain1Span
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_rain_psi_struct = function(value, obj)
{
  obj$irain1_minz = value@irain1_minz
  obj$sproduct = value@sproduct
  obj$iRain1Span = value@iRain1Span
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for rain_psi_struct
setMethod('copyToR', '_p_rain_psi_struct', CopyToR_rain_psi_struct)
setMethod('copyToC', 'rain_psi_struct', CopyToC_rain_psi_struct)

# End definition of copy methods for rain_psi_struct
# End definition of copy functions & methods for rain_psi_struct
# Start of raw_psi_struct_iDataMask0_set

`raw_psi_struct_iDataMask0_set` = function(self, s_iDataMask0)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iDataMask0 = as.numeric(s_iDataMask0) 
  
  assert(length(s_iDataMask0) == 1 && s_iDataMask0 >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iDataMask0_set', self, s_iDataMask0, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask0_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iDataMask0_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iDataMask0_set`) = c("SWIGFunction", class('raw_psi_struct_iDataMask0_set'))

# Start of raw_psi_struct_iDataMask0_get

`raw_psi_struct_iDataMask0_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iDataMask0_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask0_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iDataMask0_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iDataMask0_get`) = c("SWIGFunction", class('raw_psi_struct_iDataMask0_get'))

# Start of raw_psi_struct_iraw_bin_last_set

`raw_psi_struct_iraw_bin_last_set` = function(self, s_iraw_bin_last)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iraw_bin_last = as.integer(s_iraw_bin_last) 
  
  if(length(s_iraw_bin_last) > 1) {
    Rf_warning("using only the first element of s_iraw_bin_last")
  }
  
  .Call('R_swig_raw_psi_struct_iraw_bin_last_set', self, s_iraw_bin_last, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iraw_bin_last_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iraw_bin_last_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iraw_bin_last_set`) = c("SWIGFunction", class('raw_psi_struct_iraw_bin_last_set'))

# Start of raw_psi_struct_iraw_bin_last_get

`raw_psi_struct_iraw_bin_last_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iraw_bin_last_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iraw_bin_last_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iraw_bin_last_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iraw_bin_last_get`) = c("SWIGFunction", class('raw_psi_struct_iraw_bin_last_get'))

# Start of raw_psi_struct_iraw_convert_set

`raw_psi_struct_iraw_convert_set` = function(self, s_iraw_convert)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iraw_convert = as.numeric(s_iraw_convert) 
  
  assert(length(s_iraw_convert) == 1 && s_iraw_convert >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iraw_convert_set', self, s_iraw_convert, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iraw_convert_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iraw_convert_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iraw_convert_set`) = c("SWIGFunction", class('raw_psi_struct_iraw_convert_set'))

# Start of raw_psi_struct_iraw_convert_get

`raw_psi_struct_iraw_convert_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iraw_convert_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iraw_convert_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iraw_convert_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iraw_convert_get`) = c("SWIGFunction", class('raw_psi_struct_iraw_convert_get'))

# Start of raw_psi_struct_iflags_set

`raw_psi_struct_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iflags_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iflags_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iflags_set`) = c("SWIGFunction", class('raw_psi_struct_iflags_set'))

# Start of raw_psi_struct_iflags_get

`raw_psi_struct_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iflags_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iflags_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iflags_get`) = c("SWIGFunction", class('raw_psi_struct_iflags_get'))

# Start of raw_psi_struct_isweep_set

`raw_psi_struct_isweep_set` = function(self, s_isweep)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_isweep = as.integer(s_isweep) 
  
  if(length(s_isweep) > 1) {
    Rf_warning("using only the first element of s_isweep")
  }
  
  .Call('R_swig_raw_psi_struct_isweep_set', self, s_isweep, PACKAGE='iris')
  
}

attr(`raw_psi_struct_isweep_set`, 'returnType') = 'void'
attr(`raw_psi_struct_isweep_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_isweep_set`) = c("SWIGFunction", class('raw_psi_struct_isweep_set'))

# Start of raw_psi_struct_isweep_get

`raw_psi_struct_isweep_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_isweep_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_isweep_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_isweep_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_isweep_get`) = c("SWIGFunction", class('raw_psi_struct_isweep_get'))

# Start of raw_psi_struct_iXhdrType_set

`raw_psi_struct_iXhdrType_set` = function(self, s_iXhdrType)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iXhdrType = as.numeric(s_iXhdrType) 
  
  assert(length(s_iXhdrType) == 1 && s_iXhdrType >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iXhdrType_set', self, s_iXhdrType, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iXhdrType_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iXhdrType_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iXhdrType_set`) = c("SWIGFunction", class('raw_psi_struct_iXhdrType_set'))

# Start of raw_psi_struct_iXhdrType_get

`raw_psi_struct_iXhdrType_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iXhdrType_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iXhdrType_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iXhdrType_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iXhdrType_get`) = c("SWIGFunction", class('raw_psi_struct_iXhdrType_get'))

# Start of raw_psi_struct_iDataMask1_set

`raw_psi_struct_iDataMask1_set` = function(self, s_iDataMask1)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iDataMask1 = as.numeric(s_iDataMask1) 
  
  assert(length(s_iDataMask1) == 1 && s_iDataMask1 >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iDataMask1_set', self, s_iDataMask1, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask1_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iDataMask1_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iDataMask1_set`) = c("SWIGFunction", class('raw_psi_struct_iDataMask1_set'))

# Start of raw_psi_struct_iDataMask1_get

`raw_psi_struct_iDataMask1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iDataMask1_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask1_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iDataMask1_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iDataMask1_get`) = c("SWIGFunction", class('raw_psi_struct_iDataMask1_get'))

# Start of raw_psi_struct_iDataMask2_set

`raw_psi_struct_iDataMask2_set` = function(self, s_iDataMask2)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iDataMask2 = as.numeric(s_iDataMask2) 
  
  assert(length(s_iDataMask2) == 1 && s_iDataMask2 >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iDataMask2_set', self, s_iDataMask2, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask2_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iDataMask2_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iDataMask2_set`) = c("SWIGFunction", class('raw_psi_struct_iDataMask2_set'))

# Start of raw_psi_struct_iDataMask2_get

`raw_psi_struct_iDataMask2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iDataMask2_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask2_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iDataMask2_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iDataMask2_get`) = c("SWIGFunction", class('raw_psi_struct_iDataMask2_get'))

# Start of raw_psi_struct_iDataMask3_set

`raw_psi_struct_iDataMask3_set` = function(self, s_iDataMask3)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iDataMask3 = as.numeric(s_iDataMask3) 
  
  assert(length(s_iDataMask3) == 1 && s_iDataMask3 >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iDataMask3_set', self, s_iDataMask3, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask3_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iDataMask3_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iDataMask3_set`) = c("SWIGFunction", class('raw_psi_struct_iDataMask3_set'))

# Start of raw_psi_struct_iDataMask3_get

`raw_psi_struct_iDataMask3_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iDataMask3_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask3_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iDataMask3_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iDataMask3_get`) = c("SWIGFunction", class('raw_psi_struct_iDataMask3_get'))

# Start of raw_psi_struct_iDataMask4_set

`raw_psi_struct_iDataMask4_set` = function(self, s_iDataMask4)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iDataMask4 = as.numeric(s_iDataMask4) 
  
  assert(length(s_iDataMask4) == 1 && s_iDataMask4 >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iDataMask4_set', self, s_iDataMask4, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask4_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iDataMask4_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iDataMask4_set`) = c("SWIGFunction", class('raw_psi_struct_iDataMask4_set'))

# Start of raw_psi_struct_iDataMask4_get

`raw_psi_struct_iDataMask4_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iDataMask4_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iDataMask4_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iDataMask4_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iDataMask4_get`) = c("SWIGFunction", class('raw_psi_struct_iDataMask4_get'))

# Start of raw_psi_struct_iPlayback_set

`raw_psi_struct_iPlayback_set` = function(self, s_iPlayback)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  s_iPlayback = as.numeric(s_iPlayback) 
  
  assert(length(s_iPlayback) == 1 && s_iPlayback >= 0, "All values must be non-negative")
  
  .Call('R_swig_raw_psi_struct_iPlayback_set', self, s_iPlayback, PACKAGE='iris')
  
}

attr(`raw_psi_struct_iPlayback_set`, 'returnType') = 'void'
attr(`raw_psi_struct_iPlayback_set`, "inputTypes") = c('_p_raw_psi_struct', 'numeric')
class(`raw_psi_struct_iPlayback_set`) = c("SWIGFunction", class('raw_psi_struct_iPlayback_set'))

# Start of raw_psi_struct_iPlayback_get

`raw_psi_struct_iPlayback_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_raw_psi_struct_iPlayback_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`raw_psi_struct_iPlayback_get`, 'returnType') = 'numeric'
attr(`raw_psi_struct_iPlayback_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_iPlayback_get`) = c("SWIGFunction", class('raw_psi_struct_iPlayback_get'))

# Start of raw_psi_struct_ipad_end_set

`raw_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -44)
  
  .Call('R_swig_raw_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`raw_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`raw_psi_struct_ipad_end_set`, "inputTypes") = c('_p_raw_psi_struct', '_p_char')
class(`raw_psi_struct_ipad_end_set`) = c("SWIGFunction", class('raw_psi_struct_ipad_end_set'))

# Start of raw_psi_struct_ipad_end_get

`raw_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  ans = .Call('R_swig_raw_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`raw_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`raw_psi_struct_ipad_end_get`, "inputTypes") = c('_p_raw_psi_struct')
class(`raw_psi_struct_ipad_end_get`) = c("SWIGFunction", class('raw_psi_struct_ipad_end_get'))

# Start of new_raw_psi_struct

`raw_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_raw_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_raw_psi_struct"
  
  ans
  
}

attr(`raw_psi_struct`, 'returnType') = '_p_raw_psi_struct'
class(`raw_psi_struct`) = c("SWIGFunction", class('raw_psi_struct'))

# Start of delete_raw_psi_struct

`delete_raw_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_raw_psi_struct") 
  .Call('R_swig_delete_raw_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_raw_psi_struct`, 'returnType') = 'void'
attr(`delete_raw_psi_struct`, "inputTypes") = c('_p_raw_psi_struct')
class(`delete_raw_psi_struct`) = c("SWIGFunction", class('delete_raw_psi_struct'))

# Start of accessor method for raw_psi_struct
setMethod('$', '_p_raw_psi_struct', function(x, name)

{
  accessorFuns = list('iDataMask0' = raw_psi_struct_iDataMask0_get, 'iraw_bin_last' = raw_psi_struct_iraw_bin_last_get, 'iraw_convert' = raw_psi_struct_iraw_convert_get, 'iflags' = raw_psi_struct_iflags_get, 'isweep' = raw_psi_struct_isweep_get, 'iXhdrType' = raw_psi_struct_iXhdrType_get, 'iDataMask1' = raw_psi_struct_iDataMask1_get, 'iDataMask2' = raw_psi_struct_iDataMask2_get, 'iDataMask3' = raw_psi_struct_iDataMask3_get, 'iDataMask4' = raw_psi_struct_iDataMask4_get, 'iPlayback' = raw_psi_struct_iPlayback_get, 'ipad_end' = raw_psi_struct_ipad_end_get)
  vaccessors = c('iDataMask0', 'iraw_bin_last', 'iraw_convert', 'iflags', 'isweep', 'iXhdrType', 'iDataMask1', 'iDataMask2', 'iDataMask3', 'iDataMask4', 'iPlayback', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for raw_psi_struct
# Start of accessor method for raw_psi_struct
setMethod('$<-', '_p_raw_psi_struct', function(x, name, value)

{
  accessorFuns = list('iDataMask0' = raw_psi_struct_iDataMask0_set, 'iraw_bin_last' = raw_psi_struct_iraw_bin_last_set, 'iraw_convert' = raw_psi_struct_iraw_convert_set, 'iflags' = raw_psi_struct_iflags_set, 'isweep' = raw_psi_struct_isweep_set, 'iXhdrType' = raw_psi_struct_iXhdrType_set, 'iDataMask1' = raw_psi_struct_iDataMask1_set, 'iDataMask2' = raw_psi_struct_iDataMask2_set, 'iDataMask3' = raw_psi_struct_iDataMask3_set, 'iDataMask4' = raw_psi_struct_iDataMask4_set, 'iPlayback' = raw_psi_struct_iPlayback_set, 'ipad_end' = raw_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_raw_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iDataMask0' = raw_psi_struct_iDataMask0_set, 'iraw_bin_last' = raw_psi_struct_iraw_bin_last_set, 'iraw_convert' = raw_psi_struct_iraw_convert_set, 'iflags' = raw_psi_struct_iflags_set, 'isweep' = raw_psi_struct_isweep_set, 'iXhdrType' = raw_psi_struct_iXhdrType_set, 'iDataMask1' = raw_psi_struct_iDataMask1_set, 'iDataMask2' = raw_psi_struct_iDataMask2_set, 'iDataMask3' = raw_psi_struct_iDataMask3_set, 'iDataMask4' = raw_psi_struct_iDataMask4_set, 'iPlayback' = raw_psi_struct_iPlayback_set, 'ipad_end' = raw_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for raw_psi_struct
setMethod('delete', '_p_raw_psi_struct', function(obj) {delete_raw_psi_struct(obj)})
# Start definition of copy functions & methods for raw_psi_struct
CopyToR_raw_psi_struct = function(value, obj = new("raw_psi_struct"))
{
  obj@iDataMask0 = value$iDataMask0
  obj@iraw_bin_last = value$iraw_bin_last
  obj@iraw_convert = value$iraw_convert
  obj@iflags = value$iflags
  obj@isweep = value$isweep
  obj@iXhdrType = value$iXhdrType
  obj@iDataMask1 = value$iDataMask1
  obj@iDataMask2 = value$iDataMask2
  obj@iDataMask3 = value$iDataMask3
  obj@iDataMask4 = value$iDataMask4
  obj@iPlayback = value$iPlayback
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_raw_psi_struct = function(value, obj)
{
  obj$iDataMask0 = value@iDataMask0
  obj$iraw_bin_last = value@iraw_bin_last
  obj$iraw_convert = value@iraw_convert
  obj$iflags = value@iflags
  obj$isweep = value@isweep
  obj$iXhdrType = value@iXhdrType
  obj$iDataMask1 = value@iDataMask1
  obj$iDataMask2 = value@iDataMask2
  obj$iDataMask3 = value@iDataMask3
  obj$iDataMask4 = value@iDataMask4
  obj$iPlayback = value@iPlayback
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for raw_psi_struct
setMethod('copyToR', '_p_raw_psi_struct', CopyToR_raw_psi_struct)
setMethod('copyToC', 'raw_psi_struct', CopyToC_raw_psi_struct)

# End definition of copy methods for raw_psi_struct
# End definition of copy functions & methods for raw_psi_struct
# Start of rhi_psi_struct_irhi_az_set

`rhi_psi_struct_irhi_az_set` = function(self, s_irhi_az)
{
  self = coerceIfNotSubclass(self, "_p_rhi_psi_struct") 
  s_irhi_az = coerceIfNotSubclass(s_irhi_az, "_p_unsigned_short") 
  .Call('R_swig_rhi_psi_struct_irhi_az_set', self, s_irhi_az, PACKAGE='iris')
  
}

attr(`rhi_psi_struct_irhi_az_set`, 'returnType') = 'void'
attr(`rhi_psi_struct_irhi_az_set`, "inputTypes") = c('_p_rhi_psi_struct', '_p_unsigned_short')
class(`rhi_psi_struct_irhi_az_set`) = c("SWIGFunction", class('rhi_psi_struct_irhi_az_set'))

# Start of rhi_psi_struct_irhi_az_get

`rhi_psi_struct_irhi_az_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rhi_psi_struct") 
  ans = .Call('R_swig_rhi_psi_struct_irhi_az_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`rhi_psi_struct_irhi_az_get`, 'returnType') = '_p_unsigned_short'
attr(`rhi_psi_struct_irhi_az_get`, "inputTypes") = c('_p_rhi_psi_struct')
class(`rhi_psi_struct_irhi_az_get`) = c("SWIGFunction", class('rhi_psi_struct_irhi_az_get'))

# Start of rhi_psi_struct_ipad_end_set

`rhi_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_rhi_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -2)
  
  .Call('R_swig_rhi_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`rhi_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`rhi_psi_struct_ipad_end_set`, "inputTypes") = c('_p_rhi_psi_struct', '_p_char')
class(`rhi_psi_struct_ipad_end_set`) = c("SWIGFunction", class('rhi_psi_struct_ipad_end_set'))

# Start of rhi_psi_struct_ipad_end_get

`rhi_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rhi_psi_struct") 
  ans = .Call('R_swig_rhi_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`rhi_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`rhi_psi_struct_ipad_end_get`, "inputTypes") = c('_p_rhi_psi_struct')
class(`rhi_psi_struct_ipad_end_get`) = c("SWIGFunction", class('rhi_psi_struct_ipad_end_get'))

# Start of new_rhi_psi_struct

`rhi_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_rhi_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_rhi_psi_struct"
  
  ans
  
}

attr(`rhi_psi_struct`, 'returnType') = '_p_rhi_psi_struct'
class(`rhi_psi_struct`) = c("SWIGFunction", class('rhi_psi_struct'))

# Start of delete_rhi_psi_struct

`delete_rhi_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_rhi_psi_struct") 
  .Call('R_swig_delete_rhi_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_rhi_psi_struct`, 'returnType') = 'void'
attr(`delete_rhi_psi_struct`, "inputTypes") = c('_p_rhi_psi_struct')
class(`delete_rhi_psi_struct`) = c("SWIGFunction", class('delete_rhi_psi_struct'))

# Start of accessor method for rhi_psi_struct
setMethod('$', '_p_rhi_psi_struct', function(x, name)

{
  accessorFuns = list('irhi_az' = rhi_psi_struct_irhi_az_get, 'ipad_end' = rhi_psi_struct_ipad_end_get)
  vaccessors = c('irhi_az', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for rhi_psi_struct
# Start of accessor method for rhi_psi_struct
setMethod('$<-', '_p_rhi_psi_struct', function(x, name, value)

{
  accessorFuns = list('irhi_az' = rhi_psi_struct_irhi_az_set, 'ipad_end' = rhi_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_rhi_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('irhi_az' = rhi_psi_struct_irhi_az_set, 'ipad_end' = rhi_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for rhi_psi_struct
setMethod('delete', '_p_rhi_psi_struct', function(obj) {delete_rhi_psi_struct(obj)})
# Start definition of copy functions & methods for rhi_psi_struct
CopyToR_rhi_psi_struct = function(value, obj = new("rhi_psi_struct"))
{
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_rhi_psi_struct = function(value, obj)
{
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for rhi_psi_struct
setMethod('copyToR', '_p_rhi_psi_struct', CopyToR_rhi_psi_struct)
setMethod('copyToC', 'rhi_psi_struct', CopyToC_rhi_psi_struct)

# End definition of copy methods for rhi_psi_struct
# End definition of copy functions & methods for rhi_psi_struct
# Start of rti_psi_struct_iSweepAngle_set

`rti_psi_struct_iSweepAngle_set` = function(self, s_iSweepAngle)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  s_iSweepAngle = as.numeric(s_iSweepAngle) 
  
  assert(length(s_iSweepAngle) == 1 && s_iSweepAngle >= 0, "All values must be non-negative")
  
  .Call('R_swig_rti_psi_struct_iSweepAngle_set', self, s_iSweepAngle, PACKAGE='iris')
  
}

attr(`rti_psi_struct_iSweepAngle_set`, 'returnType') = 'void'
attr(`rti_psi_struct_iSweepAngle_set`, "inputTypes") = c('_p_rti_psi_struct', 'numeric')
class(`rti_psi_struct_iSweepAngle_set`) = c("SWIGFunction", class('rti_psi_struct_iSweepAngle_set'))

# Start of rti_psi_struct_iSweepAngle_get

`rti_psi_struct_iSweepAngle_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  .Call('R_swig_rti_psi_struct_iSweepAngle_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`rti_psi_struct_iSweepAngle_get`, 'returnType') = 'numeric'
attr(`rti_psi_struct_iSweepAngle_get`, "inputTypes") = c('_p_rti_psi_struct')
class(`rti_psi_struct_iSweepAngle_get`) = c("SWIGFunction", class('rti_psi_struct_iSweepAngle_get'))

# Start of rti_psi_struct_iStartOffset_set

`rti_psi_struct_iStartOffset_set` = function(self, s_iStartOffset)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  s_iStartOffset = as.numeric(s_iStartOffset) 
  
  assert(length(s_iStartOffset) == 1 && s_iStartOffset >= 0, "All values must be non-negative")
  
  .Call('R_swig_rti_psi_struct_iStartOffset_set', self, s_iStartOffset, PACKAGE='iris')
  
}

attr(`rti_psi_struct_iStartOffset_set`, 'returnType') = 'void'
attr(`rti_psi_struct_iStartOffset_set`, "inputTypes") = c('_p_rti_psi_struct', 'numeric')
class(`rti_psi_struct_iStartOffset_set`) = c("SWIGFunction", class('rti_psi_struct_iStartOffset_set'))

# Start of rti_psi_struct_iStartOffset_get

`rti_psi_struct_iStartOffset_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  .Call('R_swig_rti_psi_struct_iStartOffset_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`rti_psi_struct_iStartOffset_get`, 'returnType') = 'numeric'
attr(`rti_psi_struct_iStartOffset_get`, "inputTypes") = c('_p_rti_psi_struct')
class(`rti_psi_struct_iStartOffset_get`) = c("SWIGFunction", class('rti_psi_struct_iStartOffset_get'))

# Start of rti_psi_struct_iEndOffset_set

`rti_psi_struct_iEndOffset_set` = function(self, s_iEndOffset)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  s_iEndOffset = as.numeric(s_iEndOffset) 
  
  assert(length(s_iEndOffset) == 1 && s_iEndOffset >= 0, "All values must be non-negative")
  
  .Call('R_swig_rti_psi_struct_iEndOffset_set', self, s_iEndOffset, PACKAGE='iris')
  
}

attr(`rti_psi_struct_iEndOffset_set`, 'returnType') = 'void'
attr(`rti_psi_struct_iEndOffset_set`, "inputTypes") = c('_p_rti_psi_struct', 'numeric')
class(`rti_psi_struct_iEndOffset_set`) = c("SWIGFunction", class('rti_psi_struct_iEndOffset_set'))

# Start of rti_psi_struct_iEndOffset_get

`rti_psi_struct_iEndOffset_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  .Call('R_swig_rti_psi_struct_iEndOffset_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`rti_psi_struct_iEndOffset_get`, 'returnType') = 'numeric'
attr(`rti_psi_struct_iEndOffset_get`, "inputTypes") = c('_p_rti_psi_struct')
class(`rti_psi_struct_iEndOffset_get`) = c("SWIGFunction", class('rti_psi_struct_iEndOffset_get'))

# Start of rti_psi_struct_iStartAzimuth_set

`rti_psi_struct_iStartAzimuth_set` = function(self, s_iStartAzimuth)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  s_iStartAzimuth = as.numeric(s_iStartAzimuth) 
  
  assert(length(s_iStartAzimuth) == 1 && s_iStartAzimuth >= 0, "All values must be non-negative")
  
  .Call('R_swig_rti_psi_struct_iStartAzimuth_set', self, s_iStartAzimuth, PACKAGE='iris')
  
}

attr(`rti_psi_struct_iStartAzimuth_set`, 'returnType') = 'void'
attr(`rti_psi_struct_iStartAzimuth_set`, "inputTypes") = c('_p_rti_psi_struct', 'numeric')
class(`rti_psi_struct_iStartAzimuth_set`) = c("SWIGFunction", class('rti_psi_struct_iStartAzimuth_set'))

# Start of rti_psi_struct_iStartAzimuth_get

`rti_psi_struct_iStartAzimuth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  .Call('R_swig_rti_psi_struct_iStartAzimuth_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`rti_psi_struct_iStartAzimuth_get`, 'returnType') = 'numeric'
attr(`rti_psi_struct_iStartAzimuth_get`, "inputTypes") = c('_p_rti_psi_struct')
class(`rti_psi_struct_iStartAzimuth_get`) = c("SWIGFunction", class('rti_psi_struct_iStartAzimuth_get'))

# Start of rti_psi_struct_iStartElevation_set

`rti_psi_struct_iStartElevation_set` = function(self, s_iStartElevation)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  s_iStartElevation = as.numeric(s_iStartElevation) 
  
  assert(length(s_iStartElevation) == 1 && s_iStartElevation >= 0, "All values must be non-negative")
  
  .Call('R_swig_rti_psi_struct_iStartElevation_set', self, s_iStartElevation, PACKAGE='iris')
  
}

attr(`rti_psi_struct_iStartElevation_set`, 'returnType') = 'void'
attr(`rti_psi_struct_iStartElevation_set`, "inputTypes") = c('_p_rti_psi_struct', 'numeric')
class(`rti_psi_struct_iStartElevation_set`) = c("SWIGFunction", class('rti_psi_struct_iStartElevation_set'))

# Start of rti_psi_struct_iStartElevation_get

`rti_psi_struct_iStartElevation_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  .Call('R_swig_rti_psi_struct_iStartElevation_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`rti_psi_struct_iStartElevation_get`, 'returnType') = 'numeric'
attr(`rti_psi_struct_iStartElevation_get`, "inputTypes") = c('_p_rti_psi_struct')
class(`rti_psi_struct_iStartElevation_get`) = c("SWIGFunction", class('rti_psi_struct_iStartElevation_get'))

# Start of rti_psi_struct_ipad_end_set

`rti_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -20)
  
  .Call('R_swig_rti_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`rti_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`rti_psi_struct_ipad_end_set`, "inputTypes") = c('_p_rti_psi_struct', '_p_char')
class(`rti_psi_struct_ipad_end_set`) = c("SWIGFunction", class('rti_psi_struct_ipad_end_set'))

# Start of rti_psi_struct_ipad_end_get

`rti_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  ans = .Call('R_swig_rti_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`rti_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`rti_psi_struct_ipad_end_get`, "inputTypes") = c('_p_rti_psi_struct')
class(`rti_psi_struct_ipad_end_get`) = c("SWIGFunction", class('rti_psi_struct_ipad_end_get'))

# Start of new_rti_psi_struct

`rti_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_rti_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_rti_psi_struct"
  
  ans
  
}

attr(`rti_psi_struct`, 'returnType') = '_p_rti_psi_struct'
class(`rti_psi_struct`) = c("SWIGFunction", class('rti_psi_struct'))

# Start of delete_rti_psi_struct

`delete_rti_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_rti_psi_struct") 
  .Call('R_swig_delete_rti_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_rti_psi_struct`, 'returnType') = 'void'
attr(`delete_rti_psi_struct`, "inputTypes") = c('_p_rti_psi_struct')
class(`delete_rti_psi_struct`) = c("SWIGFunction", class('delete_rti_psi_struct'))

# Start of accessor method for rti_psi_struct
setMethod('$', '_p_rti_psi_struct', function(x, name)

{
  accessorFuns = list('iSweepAngle' = rti_psi_struct_iSweepAngle_get, 'iStartOffset' = rti_psi_struct_iStartOffset_get, 'iEndOffset' = rti_psi_struct_iEndOffset_get, 'iStartAzimuth' = rti_psi_struct_iStartAzimuth_get, 'iStartElevation' = rti_psi_struct_iStartElevation_get, 'ipad_end' = rti_psi_struct_ipad_end_get)
  vaccessors = c('iSweepAngle', 'iStartOffset', 'iEndOffset', 'iStartAzimuth', 'iStartElevation', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for rti_psi_struct
# Start of accessor method for rti_psi_struct
setMethod('$<-', '_p_rti_psi_struct', function(x, name, value)

{
  accessorFuns = list('iSweepAngle' = rti_psi_struct_iSweepAngle_set, 'iStartOffset' = rti_psi_struct_iStartOffset_set, 'iEndOffset' = rti_psi_struct_iEndOffset_set, 'iStartAzimuth' = rti_psi_struct_iStartAzimuth_set, 'iStartElevation' = rti_psi_struct_iStartElevation_set, 'ipad_end' = rti_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_rti_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iSweepAngle' = rti_psi_struct_iSweepAngle_set, 'iStartOffset' = rti_psi_struct_iStartOffset_set, 'iEndOffset' = rti_psi_struct_iEndOffset_set, 'iStartAzimuth' = rti_psi_struct_iStartAzimuth_set, 'iStartElevation' = rti_psi_struct_iStartElevation_set, 'ipad_end' = rti_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for rti_psi_struct
setMethod('delete', '_p_rti_psi_struct', function(obj) {delete_rti_psi_struct(obj)})
# Start definition of copy functions & methods for rti_psi_struct
CopyToR_rti_psi_struct = function(value, obj = new("rti_psi_struct"))
{
  obj@iSweepAngle = value$iSweepAngle
  obj@iStartOffset = value$iStartOffset
  obj@iEndOffset = value$iEndOffset
  obj@iStartAzimuth = value$iStartAzimuth
  obj@iStartElevation = value$iStartElevation
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_rti_psi_struct = function(value, obj)
{
  obj$iSweepAngle = value@iSweepAngle
  obj$iStartOffset = value@iStartOffset
  obj$iEndOffset = value@iEndOffset
  obj$iStartAzimuth = value@iStartAzimuth
  obj$iStartElevation = value@iStartElevation
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for rti_psi_struct
setMethod('copyToR', '_p_rti_psi_struct', CopyToR_rti_psi_struct)
setMethod('copyToC', 'rti_psi_struct', CopyToC_rti_psi_struct)

# End definition of copy methods for rti_psi_struct
# End definition of copy functions & methods for rti_psi_struct
# Start of shear_psi_struct_iaz_smooth_set

`shear_psi_struct_iaz_smooth_set` = function(self, s_iaz_smooth)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  s_iaz_smooth = as.numeric(s_iaz_smooth) 
  
  assert(length(s_iaz_smooth) == 1 && s_iaz_smooth >= 0, "All values must be non-negative")
  
  .Call('R_swig_shear_psi_struct_iaz_smooth_set', self, s_iaz_smooth, PACKAGE='iris')
  
}

attr(`shear_psi_struct_iaz_smooth_set`, 'returnType') = 'void'
attr(`shear_psi_struct_iaz_smooth_set`, "inputTypes") = c('_p_shear_psi_struct', 'numeric')
class(`shear_psi_struct_iaz_smooth_set`) = c("SWIGFunction", class('shear_psi_struct_iaz_smooth_set'))

# Start of shear_psi_struct_iaz_smooth_get

`shear_psi_struct_iaz_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  .Call('R_swig_shear_psi_struct_iaz_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`shear_psi_struct_iaz_smooth_get`, 'returnType') = 'numeric'
attr(`shear_psi_struct_iaz_smooth_get`, "inputTypes") = c('_p_shear_psi_struct')
class(`shear_psi_struct_iaz_smooth_get`) = c("SWIGFunction", class('shear_psi_struct_iaz_smooth_get'))

# Start of shear_psi_struct_ishear_el_set

`shear_psi_struct_ishear_el_set` = function(self, s_ishear_el)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  s_ishear_el = coerceIfNotSubclass(s_ishear_el, "_p_unsigned_short") 
  .Call('R_swig_shear_psi_struct_ishear_el_set', self, s_ishear_el, PACKAGE='iris')
  
}

attr(`shear_psi_struct_ishear_el_set`, 'returnType') = 'void'
attr(`shear_psi_struct_ishear_el_set`, "inputTypes") = c('_p_shear_psi_struct', '_p_unsigned_short')
class(`shear_psi_struct_ishear_el_set`) = c("SWIGFunction", class('shear_psi_struct_ishear_el_set'))

# Start of shear_psi_struct_ishear_el_get

`shear_psi_struct_ishear_el_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  ans = .Call('R_swig_shear_psi_struct_ishear_el_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`shear_psi_struct_ishear_el_get`, 'returnType') = '_p_unsigned_short'
attr(`shear_psi_struct_ishear_el_get`, "inputTypes") = c('_p_shear_psi_struct')
class(`shear_psi_struct_ishear_el_get`) = c("SWIGFunction", class('shear_psi_struct_ishear_el_get'))

# Start of shear_psi_struct_ipad6x2_set

`shear_psi_struct_ipad6x2_set` = function(self, s_ipad6x2)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  
  if(is.list(s_ipad6x2))
  assert(all(sapply(s_ipad6x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad6x2) >= 2)
  
  .Call('R_swig_shear_psi_struct_ipad6x2_set', self, s_ipad6x2, PACKAGE='iris')
  
}

attr(`shear_psi_struct_ipad6x2_set`, 'returnType') = 'void'
attr(`shear_psi_struct_ipad6x2_set`, "inputTypes") = c('_p_shear_psi_struct', '_p_char')
class(`shear_psi_struct_ipad6x2_set`) = c("SWIGFunction", class('shear_psi_struct_ipad6x2_set'))

# Start of shear_psi_struct_ipad6x2_get

`shear_psi_struct_ipad6x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  ans = .Call('R_swig_shear_psi_struct_ipad6x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`shear_psi_struct_ipad6x2_get`, 'returnType') = '_p_char'
attr(`shear_psi_struct_ipad6x2_get`, "inputTypes") = c('_p_shear_psi_struct')
class(`shear_psi_struct_ipad6x2_get`) = c("SWIGFunction", class('shear_psi_struct_ipad6x2_get'))

# Start of shear_psi_struct_iflags_set

`shear_psi_struct_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_shear_psi_struct_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`shear_psi_struct_iflags_set`, 'returnType') = 'void'
attr(`shear_psi_struct_iflags_set`, "inputTypes") = c('_p_shear_psi_struct', 'numeric')
class(`shear_psi_struct_iflags_set`) = c("SWIGFunction", class('shear_psi_struct_iflags_set'))

# Start of shear_psi_struct_iflags_get

`shear_psi_struct_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  .Call('R_swig_shear_psi_struct_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`shear_psi_struct_iflags_get`, 'returnType') = 'numeric'
attr(`shear_psi_struct_iflags_get`, "inputTypes") = c('_p_shear_psi_struct')
class(`shear_psi_struct_iflags_get`) = c("SWIGFunction", class('shear_psi_struct_iflags_get'))

# Start of shear_psi_struct_svvp_name_set

`shear_psi_struct_svvp_name_set` = function(self, s_svvp_name)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  
  if(is.list(s_svvp_name))
  assert(all(sapply(s_svvp_name, class) == "_p_char"))     
  
  
#  assert(length(s_svvp_name) >= 12)
  
  .Call('R_swig_shear_psi_struct_svvp_name_set', self, s_svvp_name, PACKAGE='iris')
  
}

attr(`shear_psi_struct_svvp_name_set`, 'returnType') = 'void'
attr(`shear_psi_struct_svvp_name_set`, "inputTypes") = c('_p_shear_psi_struct', '_p_char')
class(`shear_psi_struct_svvp_name_set`) = c("SWIGFunction", class('shear_psi_struct_svvp_name_set'))

# Start of shear_psi_struct_svvp_name_get

`shear_psi_struct_svvp_name_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  ans = .Call('R_swig_shear_psi_struct_svvp_name_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`shear_psi_struct_svvp_name_get`, 'returnType') = '_p_char'
attr(`shear_psi_struct_svvp_name_get`, "inputTypes") = c('_p_shear_psi_struct')
class(`shear_psi_struct_svvp_name_get`) = c("SWIGFunction", class('shear_psi_struct_svvp_name_get'))

# Start of shear_psi_struct_ivvp_max_age_set

`shear_psi_struct_ivvp_max_age_set` = function(self, s_ivvp_max_age)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  s_ivvp_max_age = as.numeric(s_ivvp_max_age) 
  
  assert(length(s_ivvp_max_age) == 1 && s_ivvp_max_age >= 0, "All values must be non-negative")
  
  .Call('R_swig_shear_psi_struct_ivvp_max_age_set', self, s_ivvp_max_age, PACKAGE='iris')
  
}

attr(`shear_psi_struct_ivvp_max_age_set`, 'returnType') = 'void'
attr(`shear_psi_struct_ivvp_max_age_set`, "inputTypes") = c('_p_shear_psi_struct', 'numeric')
class(`shear_psi_struct_ivvp_max_age_set`) = c("SWIGFunction", class('shear_psi_struct_ivvp_max_age_set'))

# Start of shear_psi_struct_ivvp_max_age_get

`shear_psi_struct_ivvp_max_age_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  .Call('R_swig_shear_psi_struct_ivvp_max_age_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`shear_psi_struct_ivvp_max_age_get`, 'returnType') = 'numeric'
attr(`shear_psi_struct_ivvp_max_age_get`, "inputTypes") = c('_p_shear_psi_struct')
class(`shear_psi_struct_ivvp_max_age_get`) = c("SWIGFunction", class('shear_psi_struct_ivvp_max_age_get'))

# Start of shear_psi_struct_ipad_end_set

`shear_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -28)
  
  .Call('R_swig_shear_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`shear_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`shear_psi_struct_ipad_end_set`, "inputTypes") = c('_p_shear_psi_struct', '_p_char')
class(`shear_psi_struct_ipad_end_set`) = c("SWIGFunction", class('shear_psi_struct_ipad_end_set'))

# Start of shear_psi_struct_ipad_end_get

`shear_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  ans = .Call('R_swig_shear_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`shear_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`shear_psi_struct_ipad_end_get`, "inputTypes") = c('_p_shear_psi_struct')
class(`shear_psi_struct_ipad_end_get`) = c("SWIGFunction", class('shear_psi_struct_ipad_end_get'))

# Start of new_shear_psi_struct

`shear_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_shear_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_shear_psi_struct"
  
  ans
  
}

attr(`shear_psi_struct`, 'returnType') = '_p_shear_psi_struct'
class(`shear_psi_struct`) = c("SWIGFunction", class('shear_psi_struct'))

# Start of delete_shear_psi_struct

`delete_shear_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_shear_psi_struct") 
  .Call('R_swig_delete_shear_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_shear_psi_struct`, 'returnType') = 'void'
attr(`delete_shear_psi_struct`, "inputTypes") = c('_p_shear_psi_struct')
class(`delete_shear_psi_struct`) = c("SWIGFunction", class('delete_shear_psi_struct'))

# Start of accessor method for shear_psi_struct
setMethod('$', '_p_shear_psi_struct', function(x, name)

{
  accessorFuns = list('iaz_smooth' = shear_psi_struct_iaz_smooth_get, 'ishear_el' = shear_psi_struct_ishear_el_get, 'ipad6x2' = shear_psi_struct_ipad6x2_get, 'iflags' = shear_psi_struct_iflags_get, 'svvp_name' = shear_psi_struct_svvp_name_get, 'ivvp_max_age' = shear_psi_struct_ivvp_max_age_get, 'ipad_end' = shear_psi_struct_ipad_end_get)
  vaccessors = c('iaz_smooth', 'ishear_el', 'ipad6x2', 'iflags', 'svvp_name', 'ivvp_max_age', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for shear_psi_struct
# Start of accessor method for shear_psi_struct
setMethod('$<-', '_p_shear_psi_struct', function(x, name, value)

{
  accessorFuns = list('iaz_smooth' = shear_psi_struct_iaz_smooth_set, 'ishear_el' = shear_psi_struct_ishear_el_set, 'ipad6x2' = shear_psi_struct_ipad6x2_set, 'iflags' = shear_psi_struct_iflags_set, 'svvp_name' = shear_psi_struct_svvp_name_set, 'ivvp_max_age' = shear_psi_struct_ivvp_max_age_set, 'ipad_end' = shear_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_shear_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iaz_smooth' = shear_psi_struct_iaz_smooth_set, 'ishear_el' = shear_psi_struct_ishear_el_set, 'ipad6x2' = shear_psi_struct_ipad6x2_set, 'iflags' = shear_psi_struct_iflags_set, 'svvp_name' = shear_psi_struct_svvp_name_set, 'ivvp_max_age' = shear_psi_struct_ivvp_max_age_set, 'ipad_end' = shear_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for shear_psi_struct
setMethod('delete', '_p_shear_psi_struct', function(obj) {delete_shear_psi_struct(obj)})
# Start definition of copy functions & methods for shear_psi_struct
CopyToR_shear_psi_struct = function(value, obj = new("shear_psi_struct"))
{
  obj@iaz_smooth = value$iaz_smooth
  obj@ipad6x2 = value$ipad6x2
  obj@iflags = value$iflags
  obj@svvp_name = value$svvp_name
  obj@ivvp_max_age = value$ivvp_max_age
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_shear_psi_struct = function(value, obj)
{
  obj$iaz_smooth = value@iaz_smooth
  obj$ipad6x2 = value@ipad6x2
  obj$iflags = value@iflags
  obj$svvp_name = value@svvp_name
  obj$ivvp_max_age = value@ivvp_max_age
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for shear_psi_struct
setMethod('copyToR', '_p_shear_psi_struct', CopyToR_shear_psi_struct)
setMethod('copyToC', 'shear_psi_struct', CopyToC_shear_psi_struct)

# End definition of copy methods for shear_psi_struct
# End definition of copy functions & methods for shear_psi_struct
# Start of sline_psi_struct_iarea_set

`sline_psi_struct_iarea_set` = function(self, s_iarea)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iarea = as.integer(s_iarea) 
  
  if(length(s_iarea) > 1) {
    Rf_warning("using only the first element of s_iarea")
  }
  
  .Call('R_swig_sline_psi_struct_iarea_set', self, s_iarea, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iarea_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iarea_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iarea_set`) = c("SWIGFunction", class('sline_psi_struct_iarea_set'))

# Start of sline_psi_struct_iarea_get

`sline_psi_struct_iarea_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iarea_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iarea_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iarea_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iarea_get`) = c("SWIGFunction", class('sline_psi_struct_iarea_get'))

# Start of sline_psi_struct_ishear_threshold_set

`sline_psi_struct_ishear_threshold_set` = function(self, s_ishear_threshold)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_ishear_threshold = as.integer(s_ishear_threshold) 
  
  if(length(s_ishear_threshold) > 1) {
    Rf_warning("using only the first element of s_ishear_threshold")
  }
  
  .Call('R_swig_sline_psi_struct_ishear_threshold_set', self, s_ishear_threshold, PACKAGE='iris')
  
}

attr(`sline_psi_struct_ishear_threshold_set`, 'returnType') = 'void'
attr(`sline_psi_struct_ishear_threshold_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_ishear_threshold_set`) = c("SWIGFunction", class('sline_psi_struct_ishear_threshold_set'))

# Start of sline_psi_struct_ishear_threshold_get

`sline_psi_struct_ishear_threshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_ishear_threshold_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_ishear_threshold_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_ishear_threshold_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_ishear_threshold_get`) = c("SWIGFunction", class('sline_psi_struct_ishear_threshold_get'))

# Start of sline_psi_struct_iprotect_mask_set

`sline_psi_struct_iprotect_mask_set` = function(self, s_iprotect_mask)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iprotect_mask = as.numeric(s_iprotect_mask) 
  
  assert(length(s_iprotect_mask) == 1 && s_iprotect_mask >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_iprotect_mask_set', self, s_iprotect_mask, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iprotect_mask_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iprotect_mask_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iprotect_mask_set`) = c("SWIGFunction", class('sline_psi_struct_iprotect_mask_set'))

# Start of sline_psi_struct_iprotect_mask_get

`sline_psi_struct_iprotect_mask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iprotect_mask_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iprotect_mask_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iprotect_mask_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iprotect_mask_get`) = c("SWIGFunction", class('sline_psi_struct_iprotect_mask_get'))

# Start of sline_psi_struct_iforecast_time_set

`sline_psi_struct_iforecast_time_set` = function(self, s_iforecast_time)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iforecast_time = as.integer(s_iforecast_time) 
  
  if(length(s_iforecast_time) > 1) {
    Rf_warning("using only the first element of s_iforecast_time")
  }
  
  .Call('R_swig_sline_psi_struct_iforecast_time_set', self, s_iforecast_time, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iforecast_time_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iforecast_time_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iforecast_time_set`) = c("SWIGFunction", class('sline_psi_struct_iforecast_time_set'))

# Start of sline_psi_struct_iforecast_time_get

`sline_psi_struct_iforecast_time_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iforecast_time_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iforecast_time_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iforecast_time_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iforecast_time_get`) = c("SWIGFunction", class('sline_psi_struct_iforecast_time_get'))

# Start of sline_psi_struct_imax_time_step_set

`sline_psi_struct_imax_time_step_set` = function(self, s_imax_time_step)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_imax_time_step = as.numeric(s_imax_time_step) 
  
  assert(length(s_imax_time_step) == 1 && s_imax_time_step >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_imax_time_step_set', self, s_imax_time_step, PACKAGE='iris')
  
}

attr(`sline_psi_struct_imax_time_step_set`, 'returnType') = 'void'
attr(`sline_psi_struct_imax_time_step_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_imax_time_step_set`) = c("SWIGFunction", class('sline_psi_struct_imax_time_step_set'))

# Start of sline_psi_struct_imax_time_step_get

`sline_psi_struct_imax_time_step_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_imax_time_step_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_imax_time_step_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_imax_time_step_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_imax_time_step_get`) = c("SWIGFunction", class('sline_psi_struct_imax_time_step_get'))

# Start of sline_psi_struct_imax_velocity_set

`sline_psi_struct_imax_velocity_set` = function(self, s_imax_velocity)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_imax_velocity = as.integer(s_imax_velocity) 
  
  if(length(s_imax_velocity) > 1) {
    Rf_warning("using only the first element of s_imax_velocity")
  }
  
  .Call('R_swig_sline_psi_struct_imax_velocity_set', self, s_imax_velocity, PACKAGE='iris')
  
}

attr(`sline_psi_struct_imax_velocity_set`, 'returnType') = 'void'
attr(`sline_psi_struct_imax_velocity_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_imax_velocity_set`) = c("SWIGFunction", class('sline_psi_struct_imax_velocity_set'))

# Start of sline_psi_struct_imax_velocity_get

`sline_psi_struct_imax_velocity_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_imax_velocity_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_imax_velocity_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_imax_velocity_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_imax_velocity_get`) = c("SWIGFunction", class('sline_psi_struct_imax_velocity_get'))

# Start of sline_psi_struct_iflags_set

`sline_psi_struct_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iflags_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iflags_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iflags_set`) = c("SWIGFunction", class('sline_psi_struct_iflags_set'))

# Start of sline_psi_struct_iflags_get

`sline_psi_struct_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iflags_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iflags_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iflags_get`) = c("SWIGFunction", class('sline_psi_struct_iflags_get'))

# Start of sline_psi_struct_iaz_smooth_set

`sline_psi_struct_iaz_smooth_set` = function(self, s_iaz_smooth)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iaz_smooth = as.numeric(s_iaz_smooth) 
  
  assert(length(s_iaz_smooth) == 1 && s_iaz_smooth >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_iaz_smooth_set', self, s_iaz_smooth, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iaz_smooth_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iaz_smooth_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iaz_smooth_set`) = c("SWIGFunction", class('sline_psi_struct_iaz_smooth_set'))

# Start of sline_psi_struct_iaz_smooth_get

`sline_psi_struct_iaz_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iaz_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iaz_smooth_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iaz_smooth_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iaz_smooth_get`) = c("SWIGFunction", class('sline_psi_struct_iaz_smooth_get'))

# Start of sline_psi_struct_iel1_set

`sline_psi_struct_iel1_set` = function(self, s_iel1)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iel1 = as.numeric(s_iel1) 
  
  assert(length(s_iel1) == 1 && s_iel1 >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_iel1_set', self, s_iel1, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iel1_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iel1_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iel1_set`) = c("SWIGFunction", class('sline_psi_struct_iel1_set'))

# Start of sline_psi_struct_iel1_get

`sline_psi_struct_iel1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iel1_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iel1_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iel1_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iel1_get`) = c("SWIGFunction", class('sline_psi_struct_iel1_get'))

# Start of sline_psi_struct_iel2_set

`sline_psi_struct_iel2_set` = function(self, s_iel2)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iel2 = as.numeric(s_iel2) 
  
  assert(length(s_iel2) == 1 && s_iel2 >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_iel2_set', self, s_iel2, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iel2_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iel2_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iel2_set`) = c("SWIGFunction", class('sline_psi_struct_iel2_set'))

# Start of sline_psi_struct_iel2_get

`sline_psi_struct_iel2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iel2_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iel2_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iel2_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iel2_get`) = c("SWIGFunction", class('sline_psi_struct_iel2_get'))

# Start of sline_psi_struct_svvp_name_set

`sline_psi_struct_svvp_name_set` = function(self, s_svvp_name)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  
  if(is.list(s_svvp_name))
  assert(all(sapply(s_svvp_name, class) == "_p_char"))     
  
  
#  assert(length(s_svvp_name) >= 12)
  
  .Call('R_swig_sline_psi_struct_svvp_name_set', self, s_svvp_name, PACKAGE='iris')
  
}

attr(`sline_psi_struct_svvp_name_set`, 'returnType') = 'void'
attr(`sline_psi_struct_svvp_name_set`, "inputTypes") = c('_p_sline_psi_struct', '_p_char')
class(`sline_psi_struct_svvp_name_set`) = c("SWIGFunction", class('sline_psi_struct_svvp_name_set'))

# Start of sline_psi_struct_svvp_name_get

`sline_psi_struct_svvp_name_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  ans = .Call('R_swig_sline_psi_struct_svvp_name_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`sline_psi_struct_svvp_name_get`, 'returnType') = '_p_char'
attr(`sline_psi_struct_svvp_name_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_svvp_name_get`) = c("SWIGFunction", class('sline_psi_struct_svvp_name_get'))

# Start of sline_psi_struct_ivvp_max_age_set

`sline_psi_struct_ivvp_max_age_set` = function(self, s_ivvp_max_age)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_ivvp_max_age = as.numeric(s_ivvp_max_age) 
  
  assert(length(s_ivvp_max_age) == 1 && s_ivvp_max_age >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_ivvp_max_age_set', self, s_ivvp_max_age, PACKAGE='iris')
  
}

attr(`sline_psi_struct_ivvp_max_age_set`, 'returnType') = 'void'
attr(`sline_psi_struct_ivvp_max_age_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_ivvp_max_age_set`) = c("SWIGFunction", class('sline_psi_struct_ivvp_max_age_set'))

# Start of sline_psi_struct_ivvp_max_age_get

`sline_psi_struct_ivvp_max_age_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_ivvp_max_age_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_ivvp_max_age_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_ivvp_max_age_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_ivvp_max_age_get`) = c("SWIGFunction", class('sline_psi_struct_ivvp_max_age_get'))

# Start of sline_psi_struct_ifit_threshold_set

`sline_psi_struct_ifit_threshold_set` = function(self, s_ifit_threshold)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_ifit_threshold = as.integer(s_ifit_threshold) 
  
  if(length(s_ifit_threshold) > 1) {
    Rf_warning("using only the first element of s_ifit_threshold")
  }
  
  .Call('R_swig_sline_psi_struct_ifit_threshold_set', self, s_ifit_threshold, PACKAGE='iris')
  
}

attr(`sline_psi_struct_ifit_threshold_set`, 'returnType') = 'void'
attr(`sline_psi_struct_ifit_threshold_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_ifit_threshold_set`) = c("SWIGFunction", class('sline_psi_struct_ifit_threshold_set'))

# Start of sline_psi_struct_ifit_threshold_get

`sline_psi_struct_ifit_threshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_ifit_threshold_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_ifit_threshold_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_ifit_threshold_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_ifit_threshold_get`) = c("SWIGFunction", class('sline_psi_struct_ifit_threshold_get'))

# Start of sline_psi_struct_iMaxs_set

`sline_psi_struct_iMaxs_set` = function(self, s_iMaxs)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  s_iMaxs = as.numeric(s_iMaxs) 
  
  assert(length(s_iMaxs) == 1 && s_iMaxs >= 0, "All values must be non-negative")
  
  .Call('R_swig_sline_psi_struct_iMaxs_set', self, s_iMaxs, PACKAGE='iris')
  
}

attr(`sline_psi_struct_iMaxs_set`, 'returnType') = 'void'
attr(`sline_psi_struct_iMaxs_set`, "inputTypes") = c('_p_sline_psi_struct', 'numeric')
class(`sline_psi_struct_iMaxs_set`) = c("SWIGFunction", class('sline_psi_struct_iMaxs_set'))

# Start of sline_psi_struct_iMaxs_get

`sline_psi_struct_iMaxs_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_sline_psi_struct_iMaxs_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sline_psi_struct_iMaxs_get`, 'returnType') = 'numeric'
attr(`sline_psi_struct_iMaxs_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_iMaxs_get`) = c("SWIGFunction", class('sline_psi_struct_iMaxs_get'))

# Start of sline_psi_struct_ipad_end_set

`sline_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -64)
  
  .Call('R_swig_sline_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`sline_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`sline_psi_struct_ipad_end_set`, "inputTypes") = c('_p_sline_psi_struct', '_p_char')
class(`sline_psi_struct_ipad_end_set`) = c("SWIGFunction", class('sline_psi_struct_ipad_end_set'))

# Start of sline_psi_struct_ipad_end_get

`sline_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  ans = .Call('R_swig_sline_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`sline_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`sline_psi_struct_ipad_end_get`, "inputTypes") = c('_p_sline_psi_struct')
class(`sline_psi_struct_ipad_end_get`) = c("SWIGFunction", class('sline_psi_struct_ipad_end_get'))

# Start of new_sline_psi_struct

`sline_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_sline_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_sline_psi_struct"
  
  ans
  
}

attr(`sline_psi_struct`, 'returnType') = '_p_sline_psi_struct'
class(`sline_psi_struct`) = c("SWIGFunction", class('sline_psi_struct'))

# Start of delete_sline_psi_struct

`delete_sline_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_sline_psi_struct") 
  .Call('R_swig_delete_sline_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_sline_psi_struct`, 'returnType') = 'void'
attr(`delete_sline_psi_struct`, "inputTypes") = c('_p_sline_psi_struct')
class(`delete_sline_psi_struct`) = c("SWIGFunction", class('delete_sline_psi_struct'))

# Start of accessor method for sline_psi_struct
setMethod('$', '_p_sline_psi_struct', function(x, name)

{
  accessorFuns = list('iarea' = sline_psi_struct_iarea_get, 'ishear_threshold' = sline_psi_struct_ishear_threshold_get, 'iprotect_mask' = sline_psi_struct_iprotect_mask_get, 'iforecast_time' = sline_psi_struct_iforecast_time_get, 'imax_time_step' = sline_psi_struct_imax_time_step_get, 'imax_velocity' = sline_psi_struct_imax_velocity_get, 'iflags' = sline_psi_struct_iflags_get, 'iaz_smooth' = sline_psi_struct_iaz_smooth_get, 'iel1' = sline_psi_struct_iel1_get, 'iel2' = sline_psi_struct_iel2_get, 'svvp_name' = sline_psi_struct_svvp_name_get, 'ivvp_max_age' = sline_psi_struct_ivvp_max_age_get, 'ifit_threshold' = sline_psi_struct_ifit_threshold_get, 'iMaxs' = sline_psi_struct_iMaxs_get, 'ipad_end' = sline_psi_struct_ipad_end_get)
  vaccessors = c('iarea', 'ishear_threshold', 'iprotect_mask', 'iforecast_time', 'imax_time_step', 'imax_velocity', 'iflags', 'iaz_smooth', 'iel1', 'iel2', 'svvp_name', 'ivvp_max_age', 'ifit_threshold', 'iMaxs', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for sline_psi_struct
# Start of accessor method for sline_psi_struct
setMethod('$<-', '_p_sline_psi_struct', function(x, name, value)

{
  accessorFuns = list('iarea' = sline_psi_struct_iarea_set, 'ishear_threshold' = sline_psi_struct_ishear_threshold_set, 'iprotect_mask' = sline_psi_struct_iprotect_mask_set, 'iforecast_time' = sline_psi_struct_iforecast_time_set, 'imax_time_step' = sline_psi_struct_imax_time_step_set, 'imax_velocity' = sline_psi_struct_imax_velocity_set, 'iflags' = sline_psi_struct_iflags_set, 'iaz_smooth' = sline_psi_struct_iaz_smooth_set, 'iel1' = sline_psi_struct_iel1_set, 'iel2' = sline_psi_struct_iel2_set, 'svvp_name' = sline_psi_struct_svvp_name_set, 'ivvp_max_age' = sline_psi_struct_ivvp_max_age_set, 'ifit_threshold' = sline_psi_struct_ifit_threshold_set, 'iMaxs' = sline_psi_struct_iMaxs_set, 'ipad_end' = sline_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_sline_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iarea' = sline_psi_struct_iarea_set, 'ishear_threshold' = sline_psi_struct_ishear_threshold_set, 'iprotect_mask' = sline_psi_struct_iprotect_mask_set, 'iforecast_time' = sline_psi_struct_iforecast_time_set, 'imax_time_step' = sline_psi_struct_imax_time_step_set, 'imax_velocity' = sline_psi_struct_imax_velocity_set, 'iflags' = sline_psi_struct_iflags_set, 'iaz_smooth' = sline_psi_struct_iaz_smooth_set, 'iel1' = sline_psi_struct_iel1_set, 'iel2' = sline_psi_struct_iel2_set, 'svvp_name' = sline_psi_struct_svvp_name_set, 'ivvp_max_age' = sline_psi_struct_ivvp_max_age_set, 'ifit_threshold' = sline_psi_struct_ifit_threshold_set, 'iMaxs' = sline_psi_struct_iMaxs_set, 'ipad_end' = sline_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for sline_psi_struct
setMethod('delete', '_p_sline_psi_struct', function(obj) {delete_sline_psi_struct(obj)})
# Start definition of copy functions & methods for sline_psi_struct
CopyToR_sline_psi_struct = function(value, obj = new("sline_psi_struct"))
{
  obj@iarea = value$iarea
  obj@ishear_threshold = value$ishear_threshold
  obj@iprotect_mask = value$iprotect_mask
  obj@iforecast_time = value$iforecast_time
  obj@imax_time_step = value$imax_time_step
  obj@imax_velocity = value$imax_velocity
  obj@iflags = value$iflags
  obj@iaz_smooth = value$iaz_smooth
  obj@iel1 = value$iel1
  obj@iel2 = value$iel2
  obj@svvp_name = value$svvp_name
  obj@ivvp_max_age = value$ivvp_max_age
  obj@ifit_threshold = value$ifit_threshold
  obj@iMaxs = value$iMaxs
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_sline_psi_struct = function(value, obj)
{
  obj$iarea = value@iarea
  obj$ishear_threshold = value@ishear_threshold
  obj$iprotect_mask = value@iprotect_mask
  obj$iforecast_time = value@iforecast_time
  obj$imax_time_step = value@imax_time_step
  obj$imax_velocity = value@imax_velocity
  obj$iflags = value@iflags
  obj$iaz_smooth = value@iaz_smooth
  obj$iel1 = value@iel1
  obj$iel2 = value@iel2
  obj$svvp_name = value@svvp_name
  obj$ivvp_max_age = value@ivvp_max_age
  obj$ifit_threshold = value@ifit_threshold
  obj$iMaxs = value@iMaxs
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for sline_psi_struct
setMethod('copyToR', '_p_sline_psi_struct', CopyToR_sline_psi_struct)
setMethod('copyToC', 'sline_psi_struct', CopyToC_sline_psi_struct)

# End definition of copy methods for sline_psi_struct
# End definition of copy functions & methods for sline_psi_struct
# Start of sri_psi_struct_iPsiFlags_set

`sri_psi_struct_iPsiFlags_set` = function(self, s_iPsiFlags)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iPsiFlags = as.numeric(s_iPsiFlags) 
  
  assert(length(s_iPsiFlags) == 1 && s_iPsiFlags >= 0, "All values must be non-negative")
  
  .Call('R_swig_sri_psi_struct_iPsiFlags_set', self, s_iPsiFlags, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iPsiFlags_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iPsiFlags_set`, "inputTypes") = c('_p_sri_psi_struct', 'numeric')
class(`sri_psi_struct_iPsiFlags_set`) = c("SWIGFunction", class('sri_psi_struct_iPsiFlags_set'))

# Start of sri_psi_struct_iPsiFlags_get

`sri_psi_struct_iPsiFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  .Call('R_swig_sri_psi_struct_iPsiFlags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sri_psi_struct_iPsiFlags_get`, 'returnType') = 'numeric'
attr(`sri_psi_struct_iPsiFlags_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iPsiFlags_get`) = c("SWIGFunction", class('sri_psi_struct_iPsiFlags_get'))

# Start of sri_psi_struct_iBinCount_set

`sri_psi_struct_iBinCount_set` = function(self, s_iBinCount)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iBinCount = as.integer(s_iBinCount) 
  
  if(length(s_iBinCount) > 1) {
    Rf_warning("using only the first element of s_iBinCount")
  }
  
  .Call('R_swig_sri_psi_struct_iBinCount_set', self, s_iBinCount, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iBinCount_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iBinCount_set`, "inputTypes") = c('_p_sri_psi_struct', 'numeric')
class(`sri_psi_struct_iBinCount_set`) = c("SWIGFunction", class('sri_psi_struct_iBinCount_set'))

# Start of sri_psi_struct_iBinCount_get

`sri_psi_struct_iBinCount_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  .Call('R_swig_sri_psi_struct_iBinCount_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sri_psi_struct_iBinCount_get`, 'returnType') = 'numeric'
attr(`sri_psi_struct_iBinCount_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iBinCount_get`) = c("SWIGFunction", class('sri_psi_struct_iBinCount_get'))

# Start of sri_psi_struct_iDataCount_set

`sri_psi_struct_iDataCount_set` = function(self, s_iDataCount)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iDataCount = as.integer(s_iDataCount) 
  
  if(length(s_iDataCount) > 1) {
    Rf_warning("using only the first element of s_iDataCount")
  }
  
  .Call('R_swig_sri_psi_struct_iDataCount_set', self, s_iDataCount, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iDataCount_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iDataCount_set`, "inputTypes") = c('_p_sri_psi_struct', 'numeric')
class(`sri_psi_struct_iDataCount_set`) = c("SWIGFunction", class('sri_psi_struct_iDataCount_set'))

# Start of sri_psi_struct_iDataCount_get

`sri_psi_struct_iDataCount_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  .Call('R_swig_sri_psi_struct_iDataCount_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sri_psi_struct_iDataCount_get`, 'returnType') = 'numeric'
attr(`sri_psi_struct_iDataCount_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iDataCount_get`) = c("SWIGFunction", class('sri_psi_struct_iDataCount_get'))

# Start of sri_psi_struct_iCorrCount_set

`sri_psi_struct_iCorrCount_set` = function(self, s_iCorrCount)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iCorrCount = as.integer(s_iCorrCount) 
  
  if(length(s_iCorrCount) > 1) {
    Rf_warning("using only the first element of s_iCorrCount")
  }
  
  .Call('R_swig_sri_psi_struct_iCorrCount_set', self, s_iCorrCount, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iCorrCount_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iCorrCount_set`, "inputTypes") = c('_p_sri_psi_struct', 'numeric')
class(`sri_psi_struct_iCorrCount_set`) = c("SWIGFunction", class('sri_psi_struct_iCorrCount_set'))

# Start of sri_psi_struct_iCorrCount_get

`sri_psi_struct_iCorrCount_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  .Call('R_swig_sri_psi_struct_iCorrCount_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`sri_psi_struct_iCorrCount_get`, 'returnType') = 'numeric'
attr(`sri_psi_struct_iCorrCount_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iCorrCount_get`) = c("SWIGFunction", class('sri_psi_struct_iCorrCount_get'))

# Start of sri_psi_struct_iSurfaceHeight_set

`sri_psi_struct_iSurfaceHeight_set` = function(self, s_iSurfaceHeight)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iSurfaceHeight = coerceIfNotSubclass(s_iSurfaceHeight, "_p_short") 
  .Call('R_swig_sri_psi_struct_iSurfaceHeight_set', self, s_iSurfaceHeight, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iSurfaceHeight_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iSurfaceHeight_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iSurfaceHeight_set`) = c("SWIGFunction", class('sri_psi_struct_iSurfaceHeight_set'))

# Start of sri_psi_struct_iSurfaceHeight_get

`sri_psi_struct_iSurfaceHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iSurfaceHeight_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iSurfaceHeight_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iSurfaceHeight_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iSurfaceHeight_get`) = c("SWIGFunction", class('sri_psi_struct_iSurfaceHeight_get'))

# Start of sri_psi_struct_iMaxHeight_set

`sri_psi_struct_iMaxHeight_set` = function(self, s_iMaxHeight)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iMaxHeight = coerceIfNotSubclass(s_iMaxHeight, "_p_short") 
  .Call('R_swig_sri_psi_struct_iMaxHeight_set', self, s_iMaxHeight, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iMaxHeight_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iMaxHeight_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iMaxHeight_set`) = c("SWIGFunction", class('sri_psi_struct_iMaxHeight_set'))

# Start of sri_psi_struct_iMaxHeight_get

`sri_psi_struct_iMaxHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iMaxHeight_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iMaxHeight_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iMaxHeight_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iMaxHeight_get`) = c("SWIGFunction", class('sri_psi_struct_iMaxHeight_get'))

# Start of sri_psi_struct_iMeltHeight_set

`sri_psi_struct_iMeltHeight_set` = function(self, s_iMeltHeight)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iMeltHeight = coerceIfNotSubclass(s_iMeltHeight, "_p_short") 
  .Call('R_swig_sri_psi_struct_iMeltHeight_set', self, s_iMeltHeight, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iMeltHeight_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iMeltHeight_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iMeltHeight_set`) = c("SWIGFunction", class('sri_psi_struct_iMeltHeight_set'))

# Start of sri_psi_struct_iMeltHeight_get

`sri_psi_struct_iMeltHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iMeltHeight_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iMeltHeight_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iMeltHeight_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iMeltHeight_get`) = c("SWIGFunction", class('sri_psi_struct_iMeltHeight_get'))

# Start of sri_psi_struct_iMeltThickness_set

`sri_psi_struct_iMeltThickness_set` = function(self, s_iMeltThickness)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iMeltThickness = coerceIfNotSubclass(s_iMeltThickness, "_p_short") 
  .Call('R_swig_sri_psi_struct_iMeltThickness_set', self, s_iMeltThickness, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iMeltThickness_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iMeltThickness_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iMeltThickness_set`) = c("SWIGFunction", class('sri_psi_struct_iMeltThickness_set'))

# Start of sri_psi_struct_iMeltThickness_get

`sri_psi_struct_iMeltThickness_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iMeltThickness_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iMeltThickness_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iMeltThickness_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iMeltThickness_get`) = c("SWIGFunction", class('sri_psi_struct_iMeltThickness_get'))

# Start of sri_psi_struct_iMeltIntensity_set

`sri_psi_struct_iMeltIntensity_set` = function(self, s_iMeltIntensity)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iMeltIntensity = coerceIfNotSubclass(s_iMeltIntensity, "_p_short") 
  .Call('R_swig_sri_psi_struct_iMeltIntensity_set', self, s_iMeltIntensity, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iMeltIntensity_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iMeltIntensity_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iMeltIntensity_set`) = c("SWIGFunction", class('sri_psi_struct_iMeltIntensity_set'))

# Start of sri_psi_struct_iMeltIntensity_get

`sri_psi_struct_iMeltIntensity_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iMeltIntensity_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iMeltIntensity_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iMeltIntensity_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iMeltIntensity_get`) = c("SWIGFunction", class('sri_psi_struct_iMeltIntensity_get'))

# Start of sri_psi_struct_iGradientAbove_set

`sri_psi_struct_iGradientAbove_set` = function(self, s_iGradientAbove)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iGradientAbove = coerceIfNotSubclass(s_iGradientAbove, "_p_short") 
  .Call('R_swig_sri_psi_struct_iGradientAbove_set', self, s_iGradientAbove, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iGradientAbove_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iGradientAbove_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iGradientAbove_set`) = c("SWIGFunction", class('sri_psi_struct_iGradientAbove_set'))

# Start of sri_psi_struct_iGradientAbove_get

`sri_psi_struct_iGradientAbove_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iGradientAbove_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iGradientAbove_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iGradientAbove_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iGradientAbove_get`) = c("SWIGFunction", class('sri_psi_struct_iGradientAbove_get'))

# Start of sri_psi_struct_iGradientBelow_set

`sri_psi_struct_iGradientBelow_set` = function(self, s_iGradientBelow)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iGradientBelow = coerceIfNotSubclass(s_iGradientBelow, "_p_short") 
  .Call('R_swig_sri_psi_struct_iGradientBelow_set', self, s_iGradientBelow, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iGradientBelow_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iGradientBelow_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iGradientBelow_set`) = c("SWIGFunction", class('sri_psi_struct_iGradientBelow_set'))

# Start of sri_psi_struct_iGradientBelow_get

`sri_psi_struct_iGradientBelow_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iGradientBelow_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iGradientBelow_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iGradientBelow_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iGradientBelow_get`) = c("SWIGFunction", class('sri_psi_struct_iGradientBelow_get'))

# Start of sri_psi_struct_iConvectiveHeight_set

`sri_psi_struct_iConvectiveHeight_set` = function(self, s_iConvectiveHeight)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iConvectiveHeight = coerceIfNotSubclass(s_iConvectiveHeight, "_p_short") 
  .Call('R_swig_sri_psi_struct_iConvectiveHeight_set', self, s_iConvectiveHeight, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iConvectiveHeight_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iConvectiveHeight_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_short')
class(`sri_psi_struct_iConvectiveHeight_set`) = c("SWIGFunction", class('sri_psi_struct_iConvectiveHeight_set'))

# Start of sri_psi_struct_iConvectiveHeight_get

`sri_psi_struct_iConvectiveHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iConvectiveHeight_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`sri_psi_struct_iConvectiveHeight_get`, 'returnType') = '_p_short'
attr(`sri_psi_struct_iConvectiveHeight_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iConvectiveHeight_get`) = c("SWIGFunction", class('sri_psi_struct_iConvectiveHeight_get'))

# Start of sri_psi_struct_iConvectiveZ_set

`sri_psi_struct_iConvectiveZ_set` = function(self, s_iConvectiveZ)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  s_iConvectiveZ = coerceIfNotSubclass(s_iConvectiveZ, "_p_unsigned_short") 
  .Call('R_swig_sri_psi_struct_iConvectiveZ_set', self, s_iConvectiveZ, PACKAGE='iris')
  
}

attr(`sri_psi_struct_iConvectiveZ_set`, 'returnType') = 'void'
attr(`sri_psi_struct_iConvectiveZ_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_unsigned_short')
class(`sri_psi_struct_iConvectiveZ_set`) = c("SWIGFunction", class('sri_psi_struct_iConvectiveZ_set'))

# Start of sri_psi_struct_iConvectiveZ_get

`sri_psi_struct_iConvectiveZ_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_iConvectiveZ_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`sri_psi_struct_iConvectiveZ_get`, 'returnType') = '_p_unsigned_short'
attr(`sri_psi_struct_iConvectiveZ_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_iConvectiveZ_get`) = c("SWIGFunction", class('sri_psi_struct_iConvectiveZ_get'))

# Start of sri_psi_struct_ipad_end_set

`sri_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -34)
  
  .Call('R_swig_sri_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`sri_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`sri_psi_struct_ipad_end_set`, "inputTypes") = c('_p_sri_psi_struct', '_p_char')
class(`sri_psi_struct_ipad_end_set`) = c("SWIGFunction", class('sri_psi_struct_ipad_end_set'))

# Start of sri_psi_struct_ipad_end_get

`sri_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  ans = .Call('R_swig_sri_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`sri_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`sri_psi_struct_ipad_end_get`, "inputTypes") = c('_p_sri_psi_struct')
class(`sri_psi_struct_ipad_end_get`) = c("SWIGFunction", class('sri_psi_struct_ipad_end_get'))

# Start of new_sri_psi_struct

`sri_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_sri_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_sri_psi_struct"
  
  ans
  
}

attr(`sri_psi_struct`, 'returnType') = '_p_sri_psi_struct'
class(`sri_psi_struct`) = c("SWIGFunction", class('sri_psi_struct'))

# Start of delete_sri_psi_struct

`delete_sri_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_sri_psi_struct") 
  .Call('R_swig_delete_sri_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_sri_psi_struct`, 'returnType') = 'void'
attr(`delete_sri_psi_struct`, "inputTypes") = c('_p_sri_psi_struct')
class(`delete_sri_psi_struct`) = c("SWIGFunction", class('delete_sri_psi_struct'))

# Start of accessor method for sri_psi_struct
setMethod('$', '_p_sri_psi_struct', function(x, name)

{
  accessorFuns = list('iPsiFlags' = sri_psi_struct_iPsiFlags_get, 'iBinCount' = sri_psi_struct_iBinCount_get, 'iDataCount' = sri_psi_struct_iDataCount_get, 'iCorrCount' = sri_psi_struct_iCorrCount_get, 'iSurfaceHeight' = sri_psi_struct_iSurfaceHeight_get, 'iMaxHeight' = sri_psi_struct_iMaxHeight_get, 'iMeltHeight' = sri_psi_struct_iMeltHeight_get, 'iMeltThickness' = sri_psi_struct_iMeltThickness_get, 'iMeltIntensity' = sri_psi_struct_iMeltIntensity_get, 'iGradientAbove' = sri_psi_struct_iGradientAbove_get, 'iGradientBelow' = sri_psi_struct_iGradientBelow_get, 'iConvectiveHeight' = sri_psi_struct_iConvectiveHeight_get, 'iConvectiveZ' = sri_psi_struct_iConvectiveZ_get, 'ipad_end' = sri_psi_struct_ipad_end_get)
  vaccessors = c('iPsiFlags', 'iBinCount', 'iDataCount', 'iCorrCount', 'iSurfaceHeight', 'iMaxHeight', 'iMeltHeight', 'iMeltThickness', 'iMeltIntensity', 'iGradientAbove', 'iGradientBelow', 'iConvectiveHeight', 'iConvectiveZ', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for sri_psi_struct
# Start of accessor method for sri_psi_struct
setMethod('$<-', '_p_sri_psi_struct', function(x, name, value)

{
  accessorFuns = list('iPsiFlags' = sri_psi_struct_iPsiFlags_set, 'iBinCount' = sri_psi_struct_iBinCount_set, 'iDataCount' = sri_psi_struct_iDataCount_set, 'iCorrCount' = sri_psi_struct_iCorrCount_set, 'iSurfaceHeight' = sri_psi_struct_iSurfaceHeight_set, 'iMaxHeight' = sri_psi_struct_iMaxHeight_set, 'iMeltHeight' = sri_psi_struct_iMeltHeight_set, 'iMeltThickness' = sri_psi_struct_iMeltThickness_set, 'iMeltIntensity' = sri_psi_struct_iMeltIntensity_set, 'iGradientAbove' = sri_psi_struct_iGradientAbove_set, 'iGradientBelow' = sri_psi_struct_iGradientBelow_set, 'iConvectiveHeight' = sri_psi_struct_iConvectiveHeight_set, 'iConvectiveZ' = sri_psi_struct_iConvectiveZ_set, 'ipad_end' = sri_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_sri_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iPsiFlags' = sri_psi_struct_iPsiFlags_set, 'iBinCount' = sri_psi_struct_iBinCount_set, 'iDataCount' = sri_psi_struct_iDataCount_set, 'iCorrCount' = sri_psi_struct_iCorrCount_set, 'iSurfaceHeight' = sri_psi_struct_iSurfaceHeight_set, 'iMaxHeight' = sri_psi_struct_iMaxHeight_set, 'iMeltHeight' = sri_psi_struct_iMeltHeight_set, 'iMeltThickness' = sri_psi_struct_iMeltThickness_set, 'iMeltIntensity' = sri_psi_struct_iMeltIntensity_set, 'iGradientAbove' = sri_psi_struct_iGradientAbove_set, 'iGradientBelow' = sri_psi_struct_iGradientBelow_set, 'iConvectiveHeight' = sri_psi_struct_iConvectiveHeight_set, 'iConvectiveZ' = sri_psi_struct_iConvectiveZ_set, 'ipad_end' = sri_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for sri_psi_struct
setMethod('delete', '_p_sri_psi_struct', function(obj) {delete_sri_psi_struct(obj)})
# Start definition of copy functions & methods for sri_psi_struct
CopyToR_sri_psi_struct = function(value, obj = new("sri_psi_struct"))
{
  obj@iPsiFlags = value$iPsiFlags
  obj@iBinCount = value$iBinCount
  obj@iDataCount = value$iDataCount
  obj@iCorrCount = value$iCorrCount
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_sri_psi_struct = function(value, obj)
{
  obj$iPsiFlags = value@iPsiFlags
  obj$iBinCount = value@iBinCount
  obj$iDataCount = value@iDataCount
  obj$iCorrCount = value@iCorrCount
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for sri_psi_struct
setMethod('copyToR', '_p_sri_psi_struct', CopyToR_sri_psi_struct)
setMethod('copyToC', 'sri_psi_struct', CopyToC_sri_psi_struct)

# End definition of copy methods for sri_psi_struct
# End definition of copy functions & methods for sri_psi_struct
# Start of tdwr_psi_struct_iFlags_set

`tdwr_psi_struct_iFlags_set` = function(self, s_iFlags)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  s_iFlags = as.numeric(s_iFlags) 
  
  assert(length(s_iFlags) == 1 && s_iFlags >= 0, "All values must be non-negative")
  
  .Call('R_swig_tdwr_psi_struct_iFlags_set', self, s_iFlags, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iFlags_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_iFlags_set`, "inputTypes") = c('_p_tdwr_psi_struct', 'numeric')
class(`tdwr_psi_struct_iFlags_set`) = c("SWIGFunction", class('tdwr_psi_struct_iFlags_set'))

# Start of tdwr_psi_struct_iFlags_get

`tdwr_psi_struct_iFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  .Call('R_swig_tdwr_psi_struct_iFlags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iFlags_get`, 'returnType') = 'numeric'
attr(`tdwr_psi_struct_iFlags_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_iFlags_get`) = c("SWIGFunction", class('tdwr_psi_struct_iFlags_get'))

# Start of tdwr_psi_struct_iRMax_set

`tdwr_psi_struct_iRMax_set` = function(self, s_iRMax)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  s_iRMax = as.numeric(s_iRMax) 
  
  assert(length(s_iRMax) == 1 && s_iRMax >= 0, "All values must be non-negative")
  
  .Call('R_swig_tdwr_psi_struct_iRMax_set', self, s_iRMax, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iRMax_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_iRMax_set`, "inputTypes") = c('_p_tdwr_psi_struct', 'numeric')
class(`tdwr_psi_struct_iRMax_set`) = c("SWIGFunction", class('tdwr_psi_struct_iRMax_set'))

# Start of tdwr_psi_struct_iRMax_get

`tdwr_psi_struct_iRMax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  .Call('R_swig_tdwr_psi_struct_iRMax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iRMax_get`, 'returnType') = 'numeric'
attr(`tdwr_psi_struct_iRMax_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_iRMax_get`) = c("SWIGFunction", class('tdwr_psi_struct_iRMax_get'))

# Start of tdwr_psi_struct_sSourceID_set

`tdwr_psi_struct_sSourceID_set` = function(self, s_sSourceID)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  
  if(is.list(s_sSourceID))
  assert(all(sapply(s_sSourceID, class) == "_p_char"))     
  
  
#  assert(length(s_sSourceID) >= 4)
  
  .Call('R_swig_tdwr_psi_struct_sSourceID_set', self, s_sSourceID, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_sSourceID_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_sSourceID_set`, "inputTypes") = c('_p_tdwr_psi_struct', '_p_char')
class(`tdwr_psi_struct_sSourceID_set`) = c("SWIGFunction", class('tdwr_psi_struct_sSourceID_set'))

# Start of tdwr_psi_struct_sSourceID_get

`tdwr_psi_struct_sSourceID_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  ans = .Call('R_swig_tdwr_psi_struct_sSourceID_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`tdwr_psi_struct_sSourceID_get`, 'returnType') = '_p_char'
attr(`tdwr_psi_struct_sSourceID_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_sSourceID_get`) = c("SWIGFunction", class('tdwr_psi_struct_sSourceID_get'))

# Start of tdwr_psi_struct_sCFDirection_set

`tdwr_psi_struct_sCFDirection_set` = function(self, s_sCFDirection)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  
  if(is.list(s_sCFDirection))
  assert(all(sapply(s_sCFDirection, class) == "_p_char"))     
  
  
#  assert(length(s_sCFDirection) >= 3)
  
  .Call('R_swig_tdwr_psi_struct_sCFDirection_set', self, s_sCFDirection, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_sCFDirection_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_sCFDirection_set`, "inputTypes") = c('_p_tdwr_psi_struct', '_p_char')
class(`tdwr_psi_struct_sCFDirection_set`) = c("SWIGFunction", class('tdwr_psi_struct_sCFDirection_set'))

# Start of tdwr_psi_struct_sCFDirection_get

`tdwr_psi_struct_sCFDirection_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  ans = .Call('R_swig_tdwr_psi_struct_sCFDirection_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`tdwr_psi_struct_sCFDirection_get`, 'returnType') = '_p_char'
attr(`tdwr_psi_struct_sCFDirection_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_sCFDirection_get`) = c("SWIGFunction", class('tdwr_psi_struct_sCFDirection_get'))

# Start of tdwr_psi_struct_ipad7x1_set

`tdwr_psi_struct_ipad7x1_set` = function(self, s_ipad7x1)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  s_ipad7x1 = coerceIfNotSubclass(s_ipad7x1, "_p_unsigned_char") 
  .Call('R_swig_tdwr_psi_struct_ipad7x1_set', self, s_ipad7x1, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_ipad7x1_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_ipad7x1_set`, "inputTypes") = c('_p_tdwr_psi_struct', '_p_unsigned_char')
class(`tdwr_psi_struct_ipad7x1_set`) = c("SWIGFunction", class('tdwr_psi_struct_ipad7x1_set'))

# Start of tdwr_psi_struct_ipad7x1_get

`tdwr_psi_struct_ipad7x1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  ans = .Call('R_swig_tdwr_psi_struct_ipad7x1_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`tdwr_psi_struct_ipad7x1_get`, 'returnType') = '_p_unsigned_char'
attr(`tdwr_psi_struct_ipad7x1_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_ipad7x1_get`) = c("SWIGFunction", class('tdwr_psi_struct_ipad7x1_get'))

# Start of tdwr_psi_struct_sCFSpeed_set

`tdwr_psi_struct_sCFSpeed_set` = function(self, s_sCFSpeed)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  
  if(is.list(s_sCFSpeed))
  assert(all(sapply(s_sCFSpeed, class) == "_p_char"))     
  
  
#  assert(length(s_sCFSpeed) >= 2)
  
  .Call('R_swig_tdwr_psi_struct_sCFSpeed_set', self, s_sCFSpeed, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_sCFSpeed_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_sCFSpeed_set`, "inputTypes") = c('_p_tdwr_psi_struct', '_p_char')
class(`tdwr_psi_struct_sCFSpeed_set`) = c("SWIGFunction", class('tdwr_psi_struct_sCFSpeed_set'))

# Start of tdwr_psi_struct_sCFSpeed_get

`tdwr_psi_struct_sCFSpeed_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  ans = .Call('R_swig_tdwr_psi_struct_sCFSpeed_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`tdwr_psi_struct_sCFSpeed_get`, 'returnType') = '_p_char'
attr(`tdwr_psi_struct_sCFSpeed_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_sCFSpeed_get`) = c("SWIGFunction", class('tdwr_psi_struct_sCFSpeed_get'))

# Start of tdwr_psi_struct_sCFGustSpeed_set

`tdwr_psi_struct_sCFGustSpeed_set` = function(self, s_sCFGustSpeed)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  
  if(is.list(s_sCFGustSpeed))
  assert(all(sapply(s_sCFGustSpeed, class) == "_p_char"))     
  
  
#  assert(length(s_sCFGustSpeed) >= 2)
  
  .Call('R_swig_tdwr_psi_struct_sCFGustSpeed_set', self, s_sCFGustSpeed, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_sCFGustSpeed_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_sCFGustSpeed_set`, "inputTypes") = c('_p_tdwr_psi_struct', '_p_char')
class(`tdwr_psi_struct_sCFGustSpeed_set`) = c("SWIGFunction", class('tdwr_psi_struct_sCFGustSpeed_set'))

# Start of tdwr_psi_struct_sCFGustSpeed_get

`tdwr_psi_struct_sCFGustSpeed_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  ans = .Call('R_swig_tdwr_psi_struct_sCFGustSpeed_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`tdwr_psi_struct_sCFGustSpeed_get`, 'returnType') = '_p_char'
attr(`tdwr_psi_struct_sCFGustSpeed_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_sCFGustSpeed_get`) = c("SWIGFunction", class('tdwr_psi_struct_sCFGustSpeed_get'))

# Start of tdwr_psi_struct_iprotect_mask_set

`tdwr_psi_struct_iprotect_mask_set` = function(self, s_iprotect_mask)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  s_iprotect_mask = as.numeric(s_iprotect_mask) 
  
  assert(length(s_iprotect_mask) == 1 && s_iprotect_mask >= 0, "All values must be non-negative")
  
  .Call('R_swig_tdwr_psi_struct_iprotect_mask_set', self, s_iprotect_mask, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iprotect_mask_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_iprotect_mask_set`, "inputTypes") = c('_p_tdwr_psi_struct', 'numeric')
class(`tdwr_psi_struct_iprotect_mask_set`) = c("SWIGFunction", class('tdwr_psi_struct_iprotect_mask_set'))

# Start of tdwr_psi_struct_iprotect_mask_get

`tdwr_psi_struct_iprotect_mask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  .Call('R_swig_tdwr_psi_struct_iprotect_mask_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iprotect_mask_get`, 'returnType') = 'numeric'
attr(`tdwr_psi_struct_iprotect_mask_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_iprotect_mask_get`) = c("SWIGFunction", class('tdwr_psi_struct_iprotect_mask_get'))

# Start of tdwr_psi_struct_iCentroidCount_set

`tdwr_psi_struct_iCentroidCount_set` = function(self, s_iCentroidCount)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  s_iCentroidCount = as.numeric(s_iCentroidCount) 
  
  assert(length(s_iCentroidCount) == 1 && s_iCentroidCount >= 0, "All values must be non-negative")
  
  .Call('R_swig_tdwr_psi_struct_iCentroidCount_set', self, s_iCentroidCount, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iCentroidCount_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_iCentroidCount_set`, "inputTypes") = c('_p_tdwr_psi_struct', 'numeric')
class(`tdwr_psi_struct_iCentroidCount_set`) = c("SWIGFunction", class('tdwr_psi_struct_iCentroidCount_set'))

# Start of tdwr_psi_struct_iCentroidCount_get

`tdwr_psi_struct_iCentroidCount_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  .Call('R_swig_tdwr_psi_struct_iCentroidCount_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iCentroidCount_get`, 'returnType') = 'numeric'
attr(`tdwr_psi_struct_iCentroidCount_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_iCentroidCount_get`) = c("SWIGFunction", class('tdwr_psi_struct_iCentroidCount_get'))

# Start of tdwr_psi_struct_iSlineCount_set

`tdwr_psi_struct_iSlineCount_set` = function(self, s_iSlineCount)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  s_iSlineCount = as.numeric(s_iSlineCount) 
  
  assert(length(s_iSlineCount) == 1 && s_iSlineCount >= 0, "All values must be non-negative")
  
  .Call('R_swig_tdwr_psi_struct_iSlineCount_set', self, s_iSlineCount, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iSlineCount_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_iSlineCount_set`, "inputTypes") = c('_p_tdwr_psi_struct', 'numeric')
class(`tdwr_psi_struct_iSlineCount_set`) = c("SWIGFunction", class('tdwr_psi_struct_iSlineCount_set'))

# Start of tdwr_psi_struct_iSlineCount_get

`tdwr_psi_struct_iSlineCount_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  .Call('R_swig_tdwr_psi_struct_iSlineCount_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iSlineCount_get`, 'returnType') = 'numeric'
attr(`tdwr_psi_struct_iSlineCount_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_iSlineCount_get`) = c("SWIGFunction", class('tdwr_psi_struct_iSlineCount_get'))

# Start of tdwr_psi_struct_iForecastTime_set

`tdwr_psi_struct_iForecastTime_set` = function(self, s_iForecastTime)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  s_iForecastTime = as.integer(s_iForecastTime) 
  
  if(length(s_iForecastTime) > 1) {
    Rf_warning("using only the first element of s_iForecastTime")
  }
  
  .Call('R_swig_tdwr_psi_struct_iForecastTime_set', self, s_iForecastTime, PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iForecastTime_set`, 'returnType') = 'void'
attr(`tdwr_psi_struct_iForecastTime_set`, "inputTypes") = c('_p_tdwr_psi_struct', 'numeric')
class(`tdwr_psi_struct_iForecastTime_set`) = c("SWIGFunction", class('tdwr_psi_struct_iForecastTime_set'))

# Start of tdwr_psi_struct_iForecastTime_get

`tdwr_psi_struct_iForecastTime_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  .Call('R_swig_tdwr_psi_struct_iForecastTime_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`tdwr_psi_struct_iForecastTime_get`, 'returnType') = 'numeric'
attr(`tdwr_psi_struct_iForecastTime_get`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`tdwr_psi_struct_iForecastTime_get`) = c("SWIGFunction", class('tdwr_psi_struct_iForecastTime_get'))

# Start of new_tdwr_psi_struct

`tdwr_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_tdwr_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_tdwr_psi_struct"
  
  ans
  
}

attr(`tdwr_psi_struct`, 'returnType') = '_p_tdwr_psi_struct'
class(`tdwr_psi_struct`) = c("SWIGFunction", class('tdwr_psi_struct'))

# Start of delete_tdwr_psi_struct

`delete_tdwr_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_tdwr_psi_struct") 
  .Call('R_swig_delete_tdwr_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_tdwr_psi_struct`, 'returnType') = 'void'
attr(`delete_tdwr_psi_struct`, "inputTypes") = c('_p_tdwr_psi_struct')
class(`delete_tdwr_psi_struct`) = c("SWIGFunction", class('delete_tdwr_psi_struct'))

# Start of accessor method for tdwr_psi_struct
setMethod('$', '_p_tdwr_psi_struct', function(x, name)

{
  accessorFuns = list('iFlags' = tdwr_psi_struct_iFlags_get, 'iRMax' = tdwr_psi_struct_iRMax_get, 'sSourceID' = tdwr_psi_struct_sSourceID_get, 'sCFDirection' = tdwr_psi_struct_sCFDirection_get, 'ipad7x1' = tdwr_psi_struct_ipad7x1_get, 'sCFSpeed' = tdwr_psi_struct_sCFSpeed_get, 'sCFGustSpeed' = tdwr_psi_struct_sCFGustSpeed_get, 'iprotect_mask' = tdwr_psi_struct_iprotect_mask_get, 'iCentroidCount' = tdwr_psi_struct_iCentroidCount_get, 'iSlineCount' = tdwr_psi_struct_iSlineCount_get, 'iForecastTime' = tdwr_psi_struct_iForecastTime_get)
  vaccessors = c('iFlags', 'iRMax', 'sSourceID', 'sCFDirection', 'ipad7x1', 'sCFSpeed', 'sCFGustSpeed', 'iprotect_mask', 'iCentroidCount', 'iSlineCount', 'iForecastTime')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for tdwr_psi_struct
# Start of accessor method for tdwr_psi_struct
setMethod('$<-', '_p_tdwr_psi_struct', function(x, name, value)

{
  accessorFuns = list('iFlags' = tdwr_psi_struct_iFlags_set, 'iRMax' = tdwr_psi_struct_iRMax_set, 'sSourceID' = tdwr_psi_struct_sSourceID_set, 'sCFDirection' = tdwr_psi_struct_sCFDirection_set, 'ipad7x1' = tdwr_psi_struct_ipad7x1_set, 'sCFSpeed' = tdwr_psi_struct_sCFSpeed_set, 'sCFGustSpeed' = tdwr_psi_struct_sCFGustSpeed_set, 'iprotect_mask' = tdwr_psi_struct_iprotect_mask_set, 'iCentroidCount' = tdwr_psi_struct_iCentroidCount_set, 'iSlineCount' = tdwr_psi_struct_iSlineCount_set, 'iForecastTime' = tdwr_psi_struct_iForecastTime_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_tdwr_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iFlags' = tdwr_psi_struct_iFlags_set, 'iRMax' = tdwr_psi_struct_iRMax_set, 'sSourceID' = tdwr_psi_struct_sSourceID_set, 'sCFDirection' = tdwr_psi_struct_sCFDirection_set, 'ipad7x1' = tdwr_psi_struct_ipad7x1_set, 'sCFSpeed' = tdwr_psi_struct_sCFSpeed_set, 'sCFGustSpeed' = tdwr_psi_struct_sCFGustSpeed_set, 'iprotect_mask' = tdwr_psi_struct_iprotect_mask_set, 'iCentroidCount' = tdwr_psi_struct_iCentroidCount_set, 'iSlineCount' = tdwr_psi_struct_iSlineCount_set, 'iForecastTime' = tdwr_psi_struct_iForecastTime_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for tdwr_psi_struct
setMethod('delete', '_p_tdwr_psi_struct', function(obj) {delete_tdwr_psi_struct(obj)})
# Start definition of copy functions & methods for tdwr_psi_struct
CopyToR_tdwr_psi_struct = function(value, obj = new("tdwr_psi_struct"))
{
  obj@iFlags = value$iFlags
  obj@iRMax = value$iRMax
  obj@sSourceID = value$sSourceID
  obj@sCFDirection = value$sCFDirection
  obj@sCFSpeed = value$sCFSpeed
  obj@sCFGustSpeed = value$sCFGustSpeed
  obj@iprotect_mask = value$iprotect_mask
  obj@iCentroidCount = value$iCentroidCount
  obj@iSlineCount = value$iSlineCount
  obj@iForecastTime = value$iForecastTime
  obj
}



CopyToC_tdwr_psi_struct = function(value, obj)
{
  obj$iFlags = value@iFlags
  obj$iRMax = value@iRMax
  obj$sSourceID = value@sSourceID
  obj$sCFDirection = value@sCFDirection
  obj$sCFSpeed = value@sCFSpeed
  obj$sCFGustSpeed = value@sCFGustSpeed
  obj$iprotect_mask = value@iprotect_mask
  obj$iCentroidCount = value@iCentroidCount
  obj$iSlineCount = value@iSlineCount
  obj$iForecastTime = value@iForecastTime
  obj
}



# Start definition of copy methods for tdwr_psi_struct
setMethod('copyToR', '_p_tdwr_psi_struct', CopyToR_tdwr_psi_struct)
setMethod('copyToC', 'tdwr_psi_struct', CopyToC_tdwr_psi_struct)

# End definition of copy methods for tdwr_psi_struct
# End definition of copy functions & methods for tdwr_psi_struct
# Start of top_psi_struct_ipad0x4_set

`top_psi_struct_ipad0x4_set` = function(self, s_ipad0x4)
{
  self = coerceIfNotSubclass(self, "_p_top_psi_struct") 
  
  if(is.list(s_ipad0x4))
  assert(all(sapply(s_ipad0x4, class) == "_p_char"))     
  
  
#  assert(length(s_ipad0x4) >= 4)
  
  .Call('R_swig_top_psi_struct_ipad0x4_set', self, s_ipad0x4, PACKAGE='iris')
  
}

attr(`top_psi_struct_ipad0x4_set`, 'returnType') = 'void'
attr(`top_psi_struct_ipad0x4_set`, "inputTypes") = c('_p_top_psi_struct', '_p_char')
class(`top_psi_struct_ipad0x4_set`) = c("SWIGFunction", class('top_psi_struct_ipad0x4_set'))

# Start of top_psi_struct_ipad0x4_get

`top_psi_struct_ipad0x4_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_top_psi_struct") 
  ans = .Call('R_swig_top_psi_struct_ipad0x4_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`top_psi_struct_ipad0x4_get`, 'returnType') = '_p_char'
attr(`top_psi_struct_ipad0x4_get`, "inputTypes") = c('_p_top_psi_struct')
class(`top_psi_struct_ipad0x4_get`) = c("SWIGFunction", class('top_psi_struct_ipad0x4_get'))

# Start of top_psi_struct_iZThreshold_set

`top_psi_struct_iZThreshold_set` = function(self, s_iZThreshold)
{
  self = coerceIfNotSubclass(self, "_p_top_psi_struct") 
  s_iZThreshold = coerceIfNotSubclass(s_iZThreshold, "_p_short") 
  .Call('R_swig_top_psi_struct_iZThreshold_set', self, s_iZThreshold, PACKAGE='iris')
  
}

attr(`top_psi_struct_iZThreshold_set`, 'returnType') = 'void'
attr(`top_psi_struct_iZThreshold_set`, "inputTypes") = c('_p_top_psi_struct', '_p_short')
class(`top_psi_struct_iZThreshold_set`) = c("SWIGFunction", class('top_psi_struct_iZThreshold_set'))

# Start of top_psi_struct_iZThreshold_get

`top_psi_struct_iZThreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_top_psi_struct") 
  ans = .Call('R_swig_top_psi_struct_iZThreshold_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`top_psi_struct_iZThreshold_get`, 'returnType') = '_p_short'
attr(`top_psi_struct_iZThreshold_get`, "inputTypes") = c('_p_top_psi_struct')
class(`top_psi_struct_iZThreshold_get`) = c("SWIGFunction", class('top_psi_struct_iZThreshold_get'))

# Start of top_psi_struct_ipad_end_set

`top_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_top_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -6)
  
  .Call('R_swig_top_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`top_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`top_psi_struct_ipad_end_set`, "inputTypes") = c('_p_top_psi_struct', '_p_char')
class(`top_psi_struct_ipad_end_set`) = c("SWIGFunction", class('top_psi_struct_ipad_end_set'))

# Start of top_psi_struct_ipad_end_get

`top_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_top_psi_struct") 
  ans = .Call('R_swig_top_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`top_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`top_psi_struct_ipad_end_get`, "inputTypes") = c('_p_top_psi_struct')
class(`top_psi_struct_ipad_end_get`) = c("SWIGFunction", class('top_psi_struct_ipad_end_get'))

# Start of new_top_psi_struct

`top_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_top_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_top_psi_struct"
  
  ans
  
}

attr(`top_psi_struct`, 'returnType') = '_p_top_psi_struct'
class(`top_psi_struct`) = c("SWIGFunction", class('top_psi_struct'))

# Start of delete_top_psi_struct

`delete_top_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_top_psi_struct") 
  .Call('R_swig_delete_top_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_top_psi_struct`, 'returnType') = 'void'
attr(`delete_top_psi_struct`, "inputTypes") = c('_p_top_psi_struct')
class(`delete_top_psi_struct`) = c("SWIGFunction", class('delete_top_psi_struct'))

# Start of accessor method for top_psi_struct
setMethod('$', '_p_top_psi_struct', function(x, name)

{
  accessorFuns = list('ipad0x4' = top_psi_struct_ipad0x4_get, 'iZThreshold' = top_psi_struct_iZThreshold_get, 'ipad_end' = top_psi_struct_ipad_end_get)
  vaccessors = c('ipad0x4', 'iZThreshold', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for top_psi_struct
# Start of accessor method for top_psi_struct
setMethod('$<-', '_p_top_psi_struct', function(x, name, value)

{
  accessorFuns = list('ipad0x4' = top_psi_struct_ipad0x4_set, 'iZThreshold' = top_psi_struct_iZThreshold_set, 'ipad_end' = top_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_top_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ipad0x4' = top_psi_struct_ipad0x4_set, 'iZThreshold' = top_psi_struct_iZThreshold_set, 'ipad_end' = top_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for top_psi_struct
setMethod('delete', '_p_top_psi_struct', function(obj) {delete_top_psi_struct(obj)})
# Start definition of copy functions & methods for top_psi_struct
CopyToR_top_psi_struct = function(value, obj = new("top_psi_struct"))
{
  obj@ipad0x4 = value$ipad0x4
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_top_psi_struct = function(value, obj)
{
  obj$ipad0x4 = value@ipad0x4
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for top_psi_struct
setMethod('copyToR', '_p_top_psi_struct', CopyToR_top_psi_struct)
setMethod('copyToC', 'top_psi_struct', CopyToC_top_psi_struct)

# End definition of copy methods for top_psi_struct
# End definition of copy functions & methods for top_psi_struct
# Start of track_psi_struct_iarea_set

`track_psi_struct_iarea_set` = function(self, s_iarea)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_iarea = as.integer(s_iarea) 
  
  if(length(s_iarea) > 1) {
    Rf_warning("using only the first element of s_iarea")
  }
  
  .Call('R_swig_track_psi_struct_iarea_set', self, s_iarea, PACKAGE='iris')
  
}

attr(`track_psi_struct_iarea_set`, 'returnType') = 'void'
attr(`track_psi_struct_iarea_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_iarea_set`) = c("SWIGFunction", class('track_psi_struct_iarea_set'))

# Start of track_psi_struct_iarea_get

`track_psi_struct_iarea_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_iarea_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_iarea_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_iarea_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_iarea_get`) = c("SWIGFunction", class('track_psi_struct_iarea_get'))

# Start of track_psi_struct_ithreshold_set

`track_psi_struct_ithreshold_set` = function(self, s_ithreshold)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_ithreshold = as.integer(s_ithreshold) 
  
  if(length(s_ithreshold) > 1) {
    Rf_warning("using only the first element of s_ithreshold")
  }
  
  .Call('R_swig_track_psi_struct_ithreshold_set', self, s_ithreshold, PACKAGE='iris')
  
}

attr(`track_psi_struct_ithreshold_set`, 'returnType') = 'void'
attr(`track_psi_struct_ithreshold_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_ithreshold_set`) = c("SWIGFunction", class('track_psi_struct_ithreshold_set'))

# Start of track_psi_struct_ithreshold_get

`track_psi_struct_ithreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_ithreshold_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_ithreshold_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_ithreshold_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_ithreshold_get`) = c("SWIGFunction", class('track_psi_struct_ithreshold_get'))

# Start of track_psi_struct_iprotect_mask_set

`track_psi_struct_iprotect_mask_set` = function(self, s_iprotect_mask)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_iprotect_mask = as.numeric(s_iprotect_mask) 
  
  assert(length(s_iprotect_mask) == 1 && s_iprotect_mask >= 0, "All values must be non-negative")
  
  .Call('R_swig_track_psi_struct_iprotect_mask_set', self, s_iprotect_mask, PACKAGE='iris')
  
}

attr(`track_psi_struct_iprotect_mask_set`, 'returnType') = 'void'
attr(`track_psi_struct_iprotect_mask_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_iprotect_mask_set`) = c("SWIGFunction", class('track_psi_struct_iprotect_mask_set'))

# Start of track_psi_struct_iprotect_mask_get

`track_psi_struct_iprotect_mask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_iprotect_mask_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_iprotect_mask_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_iprotect_mask_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_iprotect_mask_get`) = c("SWIGFunction", class('track_psi_struct_iprotect_mask_get'))

# Start of track_psi_struct_iforecast_time_set

`track_psi_struct_iforecast_time_set` = function(self, s_iforecast_time)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_iforecast_time = as.integer(s_iforecast_time) 
  
  if(length(s_iforecast_time) > 1) {
    Rf_warning("using only the first element of s_iforecast_time")
  }
  
  .Call('R_swig_track_psi_struct_iforecast_time_set', self, s_iforecast_time, PACKAGE='iris')
  
}

attr(`track_psi_struct_iforecast_time_set`, 'returnType') = 'void'
attr(`track_psi_struct_iforecast_time_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_iforecast_time_set`) = c("SWIGFunction", class('track_psi_struct_iforecast_time_set'))

# Start of track_psi_struct_iforecast_time_get

`track_psi_struct_iforecast_time_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_iforecast_time_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_iforecast_time_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_iforecast_time_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_iforecast_time_get`) = c("SWIGFunction", class('track_psi_struct_iforecast_time_get'))

# Start of track_psi_struct_imax_time_step_set

`track_psi_struct_imax_time_step_set` = function(self, s_imax_time_step)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_imax_time_step = as.numeric(s_imax_time_step) 
  
  assert(length(s_imax_time_step) == 1 && s_imax_time_step >= 0, "All values must be non-negative")
  
  .Call('R_swig_track_psi_struct_imax_time_step_set', self, s_imax_time_step, PACKAGE='iris')
  
}

attr(`track_psi_struct_imax_time_step_set`, 'returnType') = 'void'
attr(`track_psi_struct_imax_time_step_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_imax_time_step_set`) = c("SWIGFunction", class('track_psi_struct_imax_time_step_set'))

# Start of track_psi_struct_imax_time_step_get

`track_psi_struct_imax_time_step_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_imax_time_step_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_imax_time_step_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_imax_time_step_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_imax_time_step_get`) = c("SWIGFunction", class('track_psi_struct_imax_time_step_get'))

# Start of track_psi_struct_imax_velocity_set

`track_psi_struct_imax_velocity_set` = function(self, s_imax_velocity)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_imax_velocity = as.integer(s_imax_velocity) 
  
  if(length(s_imax_velocity) > 1) {
    Rf_warning("using only the first element of s_imax_velocity")
  }
  
  .Call('R_swig_track_psi_struct_imax_velocity_set', self, s_imax_velocity, PACKAGE='iris')
  
}

attr(`track_psi_struct_imax_velocity_set`, 'returnType') = 'void'
attr(`track_psi_struct_imax_velocity_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_imax_velocity_set`) = c("SWIGFunction", class('track_psi_struct_imax_velocity_set'))

# Start of track_psi_struct_imax_velocity_get

`track_psi_struct_imax_velocity_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_imax_velocity_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_imax_velocity_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_imax_velocity_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_imax_velocity_get`) = c("SWIGFunction", class('track_psi_struct_imax_velocity_get'))

# Start of track_psi_struct_iflags_set

`track_psi_struct_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_track_psi_struct_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`track_psi_struct_iflags_set`, 'returnType') = 'void'
attr(`track_psi_struct_iflags_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_iflags_set`) = c("SWIGFunction", class('track_psi_struct_iflags_set'))

# Start of track_psi_struct_iflags_get

`track_psi_struct_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_iflags_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_iflags_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_iflags_get`) = c("SWIGFunction", class('track_psi_struct_iflags_get'))

# Start of track_psi_struct_ispan_time_set

`track_psi_struct_ispan_time_set` = function(self, s_ispan_time)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_ispan_time = as.integer(s_ispan_time) 
  
  if(length(s_ispan_time) > 1) {
    Rf_warning("using only the first element of s_ispan_time")
  }
  
  .Call('R_swig_track_psi_struct_ispan_time_set', self, s_ispan_time, PACKAGE='iris')
  
}

attr(`track_psi_struct_ispan_time_set`, 'returnType') = 'void'
attr(`track_psi_struct_ispan_time_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_ispan_time_set`) = c("SWIGFunction", class('track_psi_struct_ispan_time_set'))

# Start of track_psi_struct_ispan_time_get

`track_psi_struct_ispan_time_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_ispan_time_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_ispan_time_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_ispan_time_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_ispan_time_get`) = c("SWIGFunction", class('track_psi_struct_ispan_time_get'))

# Start of track_psi_struct_iptype_set

`track_psi_struct_iptype_set` = function(self, s_iptype)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_iptype = as.numeric(s_iptype) 
  
  assert(length(s_iptype) == 1 && s_iptype >= 0, "All values must be non-negative")
  
  .Call('R_swig_track_psi_struct_iptype_set', self, s_iptype, PACKAGE='iris')
  
}

attr(`track_psi_struct_iptype_set`, 'returnType') = 'void'
attr(`track_psi_struct_iptype_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_iptype_set`) = c("SWIGFunction", class('track_psi_struct_iptype_set'))

# Start of track_psi_struct_iptype_get

`track_psi_struct_iptype_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_iptype_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_iptype_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_iptype_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_iptype_get`) = c("SWIGFunction", class('track_psi_struct_iptype_get'))

# Start of track_psi_struct_spname_set

`track_psi_struct_spname_set` = function(self, s_spname)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  
  if(is.list(s_spname))
  assert(all(sapply(s_spname, class) == "_p_char"))     
  
  
#  assert(length(s_spname) >= 12)
  
  .Call('R_swig_track_psi_struct_spname_set', self, s_spname, PACKAGE='iris')
  
}

attr(`track_psi_struct_spname_set`, 'returnType') = 'void'
attr(`track_psi_struct_spname_set`, "inputTypes") = c('_p_track_psi_struct', '_p_char')
class(`track_psi_struct_spname_set`) = c("SWIGFunction", class('track_psi_struct_spname_set'))

# Start of track_psi_struct_spname_get

`track_psi_struct_spname_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  ans = .Call('R_swig_track_psi_struct_spname_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`track_psi_struct_spname_get`, 'returnType') = '_p_char'
attr(`track_psi_struct_spname_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_spname_get`) = c("SWIGFunction", class('track_psi_struct_spname_get'))

# Start of track_psi_struct_iconnect_error_set

`track_psi_struct_iconnect_error_set` = function(self, s_iconnect_error)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  s_iconnect_error = as.integer(s_iconnect_error) 
  
  if(length(s_iconnect_error) > 1) {
    Rf_warning("using only the first element of s_iconnect_error")
  }
  
  .Call('R_swig_track_psi_struct_iconnect_error_set', self, s_iconnect_error, PACKAGE='iris')
  
}

attr(`track_psi_struct_iconnect_error_set`, 'returnType') = 'void'
attr(`track_psi_struct_iconnect_error_set`, "inputTypes") = c('_p_track_psi_struct', 'numeric')
class(`track_psi_struct_iconnect_error_set`) = c("SWIGFunction", class('track_psi_struct_iconnect_error_set'))

# Start of track_psi_struct_iconnect_error_get

`track_psi_struct_iconnect_error_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_track_psi_struct_iconnect_error_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`track_psi_struct_iconnect_error_get`, 'returnType') = 'numeric'
attr(`track_psi_struct_iconnect_error_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_iconnect_error_get`) = c("SWIGFunction", class('track_psi_struct_iconnect_error_get'))

# Start of track_psi_struct_ipad_end_set

`track_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -52)
  
  .Call('R_swig_track_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`track_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`track_psi_struct_ipad_end_set`, "inputTypes") = c('_p_track_psi_struct', '_p_char')
class(`track_psi_struct_ipad_end_set`) = c("SWIGFunction", class('track_psi_struct_ipad_end_set'))

# Start of track_psi_struct_ipad_end_get

`track_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  ans = .Call('R_swig_track_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`track_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`track_psi_struct_ipad_end_get`, "inputTypes") = c('_p_track_psi_struct')
class(`track_psi_struct_ipad_end_get`) = c("SWIGFunction", class('track_psi_struct_ipad_end_get'))

# Start of new_track_psi_struct

`track_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_track_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_track_psi_struct"
  
  ans
  
}

attr(`track_psi_struct`, 'returnType') = '_p_track_psi_struct'
class(`track_psi_struct`) = c("SWIGFunction", class('track_psi_struct'))

# Start of delete_track_psi_struct

`delete_track_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_track_psi_struct") 
  .Call('R_swig_delete_track_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_track_psi_struct`, 'returnType') = 'void'
attr(`delete_track_psi_struct`, "inputTypes") = c('_p_track_psi_struct')
class(`delete_track_psi_struct`) = c("SWIGFunction", class('delete_track_psi_struct'))

# Start of accessor method for track_psi_struct
setMethod('$', '_p_track_psi_struct', function(x, name)

{
  accessorFuns = list('iarea' = track_psi_struct_iarea_get, 'ithreshold' = track_psi_struct_ithreshold_get, 'iprotect_mask' = track_psi_struct_iprotect_mask_get, 'iforecast_time' = track_psi_struct_iforecast_time_get, 'imax_time_step' = track_psi_struct_imax_time_step_get, 'imax_velocity' = track_psi_struct_imax_velocity_get, 'iflags' = track_psi_struct_iflags_get, 'ispan_time' = track_psi_struct_ispan_time_get, 'iptype' = track_psi_struct_iptype_get, 'spname' = track_psi_struct_spname_get, 'iconnect_error' = track_psi_struct_iconnect_error_get, 'ipad_end' = track_psi_struct_ipad_end_get)
  vaccessors = c('iarea', 'ithreshold', 'iprotect_mask', 'iforecast_time', 'imax_time_step', 'imax_velocity', 'iflags', 'ispan_time', 'iptype', 'spname', 'iconnect_error', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for track_psi_struct
# Start of accessor method for track_psi_struct
setMethod('$<-', '_p_track_psi_struct', function(x, name, value)

{
  accessorFuns = list('iarea' = track_psi_struct_iarea_set, 'ithreshold' = track_psi_struct_ithreshold_set, 'iprotect_mask' = track_psi_struct_iprotect_mask_set, 'iforecast_time' = track_psi_struct_iforecast_time_set, 'imax_time_step' = track_psi_struct_imax_time_step_set, 'imax_velocity' = track_psi_struct_imax_velocity_set, 'iflags' = track_psi_struct_iflags_set, 'ispan_time' = track_psi_struct_ispan_time_set, 'iptype' = track_psi_struct_iptype_set, 'spname' = track_psi_struct_spname_set, 'iconnect_error' = track_psi_struct_iconnect_error_set, 'ipad_end' = track_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_track_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iarea' = track_psi_struct_iarea_set, 'ithreshold' = track_psi_struct_ithreshold_set, 'iprotect_mask' = track_psi_struct_iprotect_mask_set, 'iforecast_time' = track_psi_struct_iforecast_time_set, 'imax_time_step' = track_psi_struct_imax_time_step_set, 'imax_velocity' = track_psi_struct_imax_velocity_set, 'iflags' = track_psi_struct_iflags_set, 'ispan_time' = track_psi_struct_ispan_time_set, 'iptype' = track_psi_struct_iptype_set, 'spname' = track_psi_struct_spname_set, 'iconnect_error' = track_psi_struct_iconnect_error_set, 'ipad_end' = track_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for track_psi_struct
setMethod('delete', '_p_track_psi_struct', function(obj) {delete_track_psi_struct(obj)})
# Start definition of copy functions & methods for track_psi_struct
CopyToR_track_psi_struct = function(value, obj = new("track_psi_struct"))
{
  obj@iarea = value$iarea
  obj@ithreshold = value$ithreshold
  obj@iprotect_mask = value$iprotect_mask
  obj@iforecast_time = value$iforecast_time
  obj@imax_time_step = value$imax_time_step
  obj@imax_velocity = value$imax_velocity
  obj@iflags = value$iflags
  obj@ispan_time = value$ispan_time
  obj@iptype = value$iptype
  obj@spname = value$spname
  obj@iconnect_error = value$iconnect_error
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_track_psi_struct = function(value, obj)
{
  obj$iarea = value@iarea
  obj$ithreshold = value@ithreshold
  obj$iprotect_mask = value@iprotect_mask
  obj$iforecast_time = value@iforecast_time
  obj$imax_time_step = value@imax_time_step
  obj$imax_velocity = value@imax_velocity
  obj$iflags = value@iflags
  obj$ispan_time = value@ispan_time
  obj$iptype = value@iptype
  obj$spname = value@spname
  obj$iconnect_error = value@iconnect_error
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for track_psi_struct
setMethod('copyToR', '_p_track_psi_struct', CopyToR_track_psi_struct)
setMethod('copyToC', 'track_psi_struct', CopyToC_track_psi_struct)

# End definition of copy methods for track_psi_struct
# End definition of copy functions & methods for track_psi_struct
# Start of user_psi_struct_imisc_set

`user_psi_struct_imisc_set` = function(self, s_imisc)
{
  self = coerceIfNotSubclass(self, "_p_user_psi_struct") 
  s_imisc = as.integer(s_imisc) 
  
#  assert(length(s_imisc) >= (80)/4)
  
  .Call('R_swig_user_psi_struct_imisc_set', self, s_imisc, PACKAGE='iris')
  
}

attr(`user_psi_struct_imisc_set`, 'returnType') = 'void'
attr(`user_psi_struct_imisc_set`, "inputTypes") = c('_p_user_psi_struct', '_p_int')
class(`user_psi_struct_imisc_set`) = c("SWIGFunction", class('user_psi_struct_imisc_set'))

# Start of user_psi_struct_imisc_get

`user_psi_struct_imisc_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_user_psi_struct") 
  ans = .Call('R_swig_user_psi_struct_imisc_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_int"
  
  ans
  
}

attr(`user_psi_struct_imisc_get`, 'returnType') = '_p_int'
attr(`user_psi_struct_imisc_get`, "inputTypes") = c('_p_user_psi_struct')
class(`user_psi_struct_imisc_get`) = c("SWIGFunction", class('user_psi_struct_imisc_get'))

# Start of new_user_psi_struct

`user_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_user_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_user_psi_struct"
  
  ans
  
}

attr(`user_psi_struct`, 'returnType') = '_p_user_psi_struct'
class(`user_psi_struct`) = c("SWIGFunction", class('user_psi_struct'))

# Start of delete_user_psi_struct

`delete_user_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_user_psi_struct") 
  .Call('R_swig_delete_user_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_user_psi_struct`, 'returnType') = 'void'
attr(`delete_user_psi_struct`, "inputTypes") = c('_p_user_psi_struct')
class(`delete_user_psi_struct`) = c("SWIGFunction", class('delete_user_psi_struct'))

# Start of accessor method for user_psi_struct
setMethod('$', '_p_user_psi_struct', function(x, name)

{
  accessorFuns = list('imisc' = user_psi_struct_imisc_get)
  vaccessors = c('imisc')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for user_psi_struct
# Start of accessor method for user_psi_struct
setMethod('$<-', '_p_user_psi_struct', function(x, name, value)

{
  accessorFuns = list('imisc' = user_psi_struct_imisc_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_user_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('imisc' = user_psi_struct_imisc_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for user_psi_struct
setMethod('delete', '_p_user_psi_struct', function(obj) {delete_user_psi_struct(obj)})
# Start definition of copy functions & methods for user_psi_struct
CopyToR_user_psi_struct = function(value, obj = new("user_psi_struct"))
{
  obj@imisc = value$imisc
  obj
}



CopyToC_user_psi_struct = function(value, obj)
{
  obj$imisc = value@imisc
  obj
}



# Start definition of copy methods for user_psi_struct
setMethod('copyToR', '_p_user_psi_struct', CopyToR_user_psi_struct)
setMethod('copyToC', 'user_psi_struct', CopyToC_user_psi_struct)

# End definition of copy methods for user_psi_struct
# End definition of copy functions & methods for user_psi_struct
# Start of vil_psi_struct_ipad0x4_set

`vil_psi_struct_ipad0x4_set` = function(self, s_ipad0x4)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  
  if(is.list(s_ipad0x4))
  assert(all(sapply(s_ipad0x4, class) == "_p_char"))     
  
  
#  assert(length(s_ipad0x4) >= 4)
  
  .Call('R_swig_vil_psi_struct_ipad0x4_set', self, s_ipad0x4, PACKAGE='iris')
  
}

attr(`vil_psi_struct_ipad0x4_set`, 'returnType') = 'void'
attr(`vil_psi_struct_ipad0x4_set`, "inputTypes") = c('_p_vil_psi_struct', '_p_char')
class(`vil_psi_struct_ipad0x4_set`) = c("SWIGFunction", class('vil_psi_struct_ipad0x4_set'))

# Start of vil_psi_struct_ipad0x4_get

`vil_psi_struct_ipad0x4_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  ans = .Call('R_swig_vil_psi_struct_ipad0x4_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`vil_psi_struct_ipad0x4_get`, 'returnType') = '_p_char'
attr(`vil_psi_struct_ipad0x4_get`, "inputTypes") = c('_p_vil_psi_struct')
class(`vil_psi_struct_ipad0x4_get`) = c("SWIGFunction", class('vil_psi_struct_ipad0x4_get'))

# Start of vil_psi_struct_ivil_bottom_set

`vil_psi_struct_ivil_bottom_set` = function(self, s_ivil_bottom)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  s_ivil_bottom = as.integer(s_ivil_bottom) 
  
  if(length(s_ivil_bottom) > 1) {
    Rf_warning("using only the first element of s_ivil_bottom")
  }
  
  .Call('R_swig_vil_psi_struct_ivil_bottom_set', self, s_ivil_bottom, PACKAGE='iris')
  
}

attr(`vil_psi_struct_ivil_bottom_set`, 'returnType') = 'void'
attr(`vil_psi_struct_ivil_bottom_set`, "inputTypes") = c('_p_vil_psi_struct', 'numeric')
class(`vil_psi_struct_ivil_bottom_set`) = c("SWIGFunction", class('vil_psi_struct_ivil_bottom_set'))

# Start of vil_psi_struct_ivil_bottom_get

`vil_psi_struct_ivil_bottom_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  .Call('R_swig_vil_psi_struct_ivil_bottom_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vil_psi_struct_ivil_bottom_get`, 'returnType') = 'numeric'
attr(`vil_psi_struct_ivil_bottom_get`, "inputTypes") = c('_p_vil_psi_struct')
class(`vil_psi_struct_ivil_bottom_get`) = c("SWIGFunction", class('vil_psi_struct_ivil_bottom_get'))

# Start of vil_psi_struct_ivil_top_set

`vil_psi_struct_ivil_top_set` = function(self, s_ivil_top)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  s_ivil_top = as.integer(s_ivil_top) 
  
  if(length(s_ivil_top) > 1) {
    Rf_warning("using only the first element of s_ivil_top")
  }
  
  .Call('R_swig_vil_psi_struct_ivil_top_set', self, s_ivil_top, PACKAGE='iris')
  
}

attr(`vil_psi_struct_ivil_top_set`, 'returnType') = 'void'
attr(`vil_psi_struct_ivil_top_set`, "inputTypes") = c('_p_vil_psi_struct', 'numeric')
class(`vil_psi_struct_ivil_top_set`) = c("SWIGFunction", class('vil_psi_struct_ivil_top_set'))

# Start of vil_psi_struct_ivil_top_get

`vil_psi_struct_ivil_top_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  .Call('R_swig_vil_psi_struct_ivil_top_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vil_psi_struct_ivil_top_get`, 'returnType') = 'numeric'
attr(`vil_psi_struct_ivil_top_get`, "inputTypes") = c('_p_vil_psi_struct')
class(`vil_psi_struct_ivil_top_get`) = c("SWIGFunction", class('vil_psi_struct_ivil_top_get'))

# Start of vil_psi_struct_ipad_end_set

`vil_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -12)
  
  .Call('R_swig_vil_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`vil_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`vil_psi_struct_ipad_end_set`, "inputTypes") = c('_p_vil_psi_struct', '_p_char')
class(`vil_psi_struct_ipad_end_set`) = c("SWIGFunction", class('vil_psi_struct_ipad_end_set'))

# Start of vil_psi_struct_ipad_end_get

`vil_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  ans = .Call('R_swig_vil_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`vil_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`vil_psi_struct_ipad_end_get`, "inputTypes") = c('_p_vil_psi_struct')
class(`vil_psi_struct_ipad_end_get`) = c("SWIGFunction", class('vil_psi_struct_ipad_end_get'))

# Start of new_vil_psi_struct

`vil_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_vil_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_vil_psi_struct"
  
  ans
  
}

attr(`vil_psi_struct`, 'returnType') = '_p_vil_psi_struct'
class(`vil_psi_struct`) = c("SWIGFunction", class('vil_psi_struct'))

# Start of delete_vil_psi_struct

`delete_vil_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_vil_psi_struct") 
  .Call('R_swig_delete_vil_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_vil_psi_struct`, 'returnType') = 'void'
attr(`delete_vil_psi_struct`, "inputTypes") = c('_p_vil_psi_struct')
class(`delete_vil_psi_struct`) = c("SWIGFunction", class('delete_vil_psi_struct'))

# Start of accessor method for vil_psi_struct
setMethod('$', '_p_vil_psi_struct', function(x, name)

{
  accessorFuns = list('ipad0x4' = vil_psi_struct_ipad0x4_get, 'ivil_bottom' = vil_psi_struct_ivil_bottom_get, 'ivil_top' = vil_psi_struct_ivil_top_get, 'ipad_end' = vil_psi_struct_ipad_end_get)
  vaccessors = c('ipad0x4', 'ivil_bottom', 'ivil_top', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for vil_psi_struct
# Start of accessor method for vil_psi_struct
setMethod('$<-', '_p_vil_psi_struct', function(x, name, value)

{
  accessorFuns = list('ipad0x4' = vil_psi_struct_ipad0x4_set, 'ivil_bottom' = vil_psi_struct_ivil_bottom_set, 'ivil_top' = vil_psi_struct_ivil_top_set, 'ipad_end' = vil_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_vil_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ipad0x4' = vil_psi_struct_ipad0x4_set, 'ivil_bottom' = vil_psi_struct_ivil_bottom_set, 'ivil_top' = vil_psi_struct_ivil_top_set, 'ipad_end' = vil_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for vil_psi_struct
setMethod('delete', '_p_vil_psi_struct', function(obj) {delete_vil_psi_struct(obj)})
# Start definition of copy functions & methods for vil_psi_struct
CopyToR_vil_psi_struct = function(value, obj = new("vil_psi_struct"))
{
  obj@ipad0x4 = value$ipad0x4
  obj@ivil_bottom = value$ivil_bottom
  obj@ivil_top = value$ivil_top
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_vil_psi_struct = function(value, obj)
{
  obj$ipad0x4 = value@ipad0x4
  obj$ivil_bottom = value@ivil_bottom
  obj$ivil_top = value@ivil_top
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for vil_psi_struct
setMethod('copyToR', '_p_vil_psi_struct', CopyToR_vil_psi_struct)
setMethod('copyToC', 'vil_psi_struct', CopyToC_vil_psi_struct)

# End definition of copy methods for vil_psi_struct
# End definition of copy functions & methods for vil_psi_struct
# Start of vvp_psi_struct_ivvp_rmin_set

`vvp_psi_struct_ivvp_rmin_set` = function(self, s_ivvp_rmin)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  s_ivvp_rmin = as.integer(s_ivvp_rmin) 
  
  if(length(s_ivvp_rmin) > 1) {
    Rf_warning("using only the first element of s_ivvp_rmin")
  }
  
  .Call('R_swig_vvp_psi_struct_ivvp_rmin_set', self, s_ivvp_rmin, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_rmin_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ivvp_rmin_set`, "inputTypes") = c('_p_vvp_psi_struct', 'numeric')
class(`vvp_psi_struct_ivvp_rmin_set`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_rmin_set'))

# Start of vvp_psi_struct_ivvp_rmin_get

`vvp_psi_struct_ivvp_rmin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  .Call('R_swig_vvp_psi_struct_ivvp_rmin_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_rmin_get`, 'returnType') = 'numeric'
attr(`vvp_psi_struct_ivvp_rmin_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ivvp_rmin_get`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_rmin_get'))

# Start of vvp_psi_struct_ivvp_rmax_set

`vvp_psi_struct_ivvp_rmax_set` = function(self, s_ivvp_rmax)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  s_ivvp_rmax = as.integer(s_ivvp_rmax) 
  
  if(length(s_ivvp_rmax) > 1) {
    Rf_warning("using only the first element of s_ivvp_rmax")
  }
  
  .Call('R_swig_vvp_psi_struct_ivvp_rmax_set', self, s_ivvp_rmax, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_rmax_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ivvp_rmax_set`, "inputTypes") = c('_p_vvp_psi_struct', 'numeric')
class(`vvp_psi_struct_ivvp_rmax_set`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_rmax_set'))

# Start of vvp_psi_struct_ivvp_rmax_get

`vvp_psi_struct_ivvp_rmax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  .Call('R_swig_vvp_psi_struct_ivvp_rmax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_rmax_get`, 'returnType') = 'numeric'
attr(`vvp_psi_struct_ivvp_rmax_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ivvp_rmax_get`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_rmax_get'))

# Start of vvp_psi_struct_ivvp_hmin_set

`vvp_psi_struct_ivvp_hmin_set` = function(self, s_ivvp_hmin)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  s_ivvp_hmin = as.integer(s_ivvp_hmin) 
  
  if(length(s_ivvp_hmin) > 1) {
    Rf_warning("using only the first element of s_ivvp_hmin")
  }
  
  .Call('R_swig_vvp_psi_struct_ivvp_hmin_set', self, s_ivvp_hmin, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_hmin_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ivvp_hmin_set`, "inputTypes") = c('_p_vvp_psi_struct', 'numeric')
class(`vvp_psi_struct_ivvp_hmin_set`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_hmin_set'))

# Start of vvp_psi_struct_ivvp_hmin_get

`vvp_psi_struct_ivvp_hmin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  .Call('R_swig_vvp_psi_struct_ivvp_hmin_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_hmin_get`, 'returnType') = 'numeric'
attr(`vvp_psi_struct_ivvp_hmin_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ivvp_hmin_get`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_hmin_get'))

# Start of vvp_psi_struct_ivvp_hmax_set

`vvp_psi_struct_ivvp_hmax_set` = function(self, s_ivvp_hmax)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  s_ivvp_hmax = as.integer(s_ivvp_hmax) 
  
  if(length(s_ivvp_hmax) > 1) {
    Rf_warning("using only the first element of s_ivvp_hmax")
  }
  
  .Call('R_swig_vvp_psi_struct_ivvp_hmax_set', self, s_ivvp_hmax, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_hmax_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ivvp_hmax_set`, "inputTypes") = c('_p_vvp_psi_struct', 'numeric')
class(`vvp_psi_struct_ivvp_hmax_set`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_hmax_set'))

# Start of vvp_psi_struct_ivvp_hmax_get

`vvp_psi_struct_ivvp_hmax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  .Call('R_swig_vvp_psi_struct_ivvp_hmax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_hmax_get`, 'returnType') = 'numeric'
attr(`vvp_psi_struct_ivvp_hmax_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ivvp_hmax_get`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_hmax_get'))

# Start of vvp_psi_struct_ivvp_intervals_set

`vvp_psi_struct_ivvp_intervals_set` = function(self, s_ivvp_intervals)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  s_ivvp_intervals = coerceIfNotSubclass(s_ivvp_intervals, "_p_short") 
  .Call('R_swig_vvp_psi_struct_ivvp_intervals_set', self, s_ivvp_intervals, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_intervals_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ivvp_intervals_set`, "inputTypes") = c('_p_vvp_psi_struct', '_p_short')
class(`vvp_psi_struct_ivvp_intervals_set`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_intervals_set'))

# Start of vvp_psi_struct_ivvp_intervals_get

`vvp_psi_struct_ivvp_intervals_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  ans = .Call('R_swig_vvp_psi_struct_ivvp_intervals_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`vvp_psi_struct_ivvp_intervals_get`, 'returnType') = '_p_short'
attr(`vvp_psi_struct_ivvp_intervals_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ivvp_intervals_get`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_intervals_get'))

# Start of vvp_psi_struct_ipad18x2_set

`vvp_psi_struct_ipad18x2_set` = function(self, s_ipad18x2)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  
  if(is.list(s_ipad18x2))
  assert(all(sapply(s_ipad18x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad18x2) >= 2)
  
  .Call('R_swig_vvp_psi_struct_ipad18x2_set', self, s_ipad18x2, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ipad18x2_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ipad18x2_set`, "inputTypes") = c('_p_vvp_psi_struct', '_p_char')
class(`vvp_psi_struct_ipad18x2_set`) = c("SWIGFunction", class('vvp_psi_struct_ipad18x2_set'))

# Start of vvp_psi_struct_ipad18x2_get

`vvp_psi_struct_ipad18x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  ans = .Call('R_swig_vvp_psi_struct_ipad18x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`vvp_psi_struct_ipad18x2_get`, 'returnType') = '_p_char'
attr(`vvp_psi_struct_ipad18x2_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ipad18x2_get`) = c("SWIGFunction", class('vvp_psi_struct_ipad18x2_get'))

# Start of vvp_psi_struct_ivvp_quota_set

`vvp_psi_struct_ivvp_quota_set` = function(self, s_ivvp_quota)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  s_ivvp_quota = as.integer(s_ivvp_quota) 
  
  if(length(s_ivvp_quota) > 1) {
    Rf_warning("using only the first element of s_ivvp_quota")
  }
  
  .Call('R_swig_vvp_psi_struct_ivvp_quota_set', self, s_ivvp_quota, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_quota_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ivvp_quota_set`, "inputTypes") = c('_p_vvp_psi_struct', 'numeric')
class(`vvp_psi_struct_ivvp_quota_set`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_quota_set'))

# Start of vvp_psi_struct_ivvp_quota_get

`vvp_psi_struct_ivvp_quota_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  .Call('R_swig_vvp_psi_struct_ivvp_quota_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_quota_get`, 'returnType') = 'numeric'
attr(`vvp_psi_struct_ivvp_quota_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ivvp_quota_get`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_quota_get'))

# Start of vvp_psi_struct_ivvp_switch_set

`vvp_psi_struct_ivvp_switch_set` = function(self, s_ivvp_switch)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  s_ivvp_switch = as.numeric(s_ivvp_switch) 
  
  assert(length(s_ivvp_switch) == 1 && s_ivvp_switch >= 0, "All values must be non-negative")
  
  .Call('R_swig_vvp_psi_struct_ivvp_switch_set', self, s_ivvp_switch, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_switch_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ivvp_switch_set`, "inputTypes") = c('_p_vvp_psi_struct', 'numeric')
class(`vvp_psi_struct_ivvp_switch_set`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_switch_set'))

# Start of vvp_psi_struct_ivvp_switch_get

`vvp_psi_struct_ivvp_switch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  .Call('R_swig_vvp_psi_struct_ivvp_switch_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ivvp_switch_get`, 'returnType') = 'numeric'
attr(`vvp_psi_struct_ivvp_switch_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ivvp_switch_get`) = c("SWIGFunction", class('vvp_psi_struct_ivvp_switch_get'))

# Start of vvp_psi_struct_ipad_end_set

`vvp_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -28)
  
  .Call('R_swig_vvp_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`vvp_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`vvp_psi_struct_ipad_end_set`, "inputTypes") = c('_p_vvp_psi_struct', '_p_char')
class(`vvp_psi_struct_ipad_end_set`) = c("SWIGFunction", class('vvp_psi_struct_ipad_end_set'))

# Start of vvp_psi_struct_ipad_end_get

`vvp_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  ans = .Call('R_swig_vvp_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`vvp_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`vvp_psi_struct_ipad_end_get`, "inputTypes") = c('_p_vvp_psi_struct')
class(`vvp_psi_struct_ipad_end_get`) = c("SWIGFunction", class('vvp_psi_struct_ipad_end_get'))

# Start of new_vvp_psi_struct

`vvp_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_vvp_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_vvp_psi_struct"
  
  ans
  
}

attr(`vvp_psi_struct`, 'returnType') = '_p_vvp_psi_struct'
class(`vvp_psi_struct`) = c("SWIGFunction", class('vvp_psi_struct'))

# Start of delete_vvp_psi_struct

`delete_vvp_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_vvp_psi_struct") 
  .Call('R_swig_delete_vvp_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_vvp_psi_struct`, 'returnType') = 'void'
attr(`delete_vvp_psi_struct`, "inputTypes") = c('_p_vvp_psi_struct')
class(`delete_vvp_psi_struct`) = c("SWIGFunction", class('delete_vvp_psi_struct'))

# Start of accessor method for vvp_psi_struct
setMethod('$', '_p_vvp_psi_struct', function(x, name)

{
  accessorFuns = list('ivvp_rmin' = vvp_psi_struct_ivvp_rmin_get, 'ivvp_rmax' = vvp_psi_struct_ivvp_rmax_get, 'ivvp_hmin' = vvp_psi_struct_ivvp_hmin_get, 'ivvp_hmax' = vvp_psi_struct_ivvp_hmax_get, 'ivvp_intervals' = vvp_psi_struct_ivvp_intervals_get, 'ipad18x2' = vvp_psi_struct_ipad18x2_get, 'ivvp_quota' = vvp_psi_struct_ivvp_quota_get, 'ivvp_switch' = vvp_psi_struct_ivvp_switch_get, 'ipad_end' = vvp_psi_struct_ipad_end_get)
  vaccessors = c('ivvp_rmin', 'ivvp_rmax', 'ivvp_hmin', 'ivvp_hmax', 'ivvp_intervals', 'ipad18x2', 'ivvp_quota', 'ivvp_switch', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for vvp_psi_struct
# Start of accessor method for vvp_psi_struct
setMethod('$<-', '_p_vvp_psi_struct', function(x, name, value)

{
  accessorFuns = list('ivvp_rmin' = vvp_psi_struct_ivvp_rmin_set, 'ivvp_rmax' = vvp_psi_struct_ivvp_rmax_set, 'ivvp_hmin' = vvp_psi_struct_ivvp_hmin_set, 'ivvp_hmax' = vvp_psi_struct_ivvp_hmax_set, 'ivvp_intervals' = vvp_psi_struct_ivvp_intervals_set, 'ipad18x2' = vvp_psi_struct_ipad18x2_set, 'ivvp_quota' = vvp_psi_struct_ivvp_quota_set, 'ivvp_switch' = vvp_psi_struct_ivvp_switch_set, 'ipad_end' = vvp_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_vvp_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ivvp_rmin' = vvp_psi_struct_ivvp_rmin_set, 'ivvp_rmax' = vvp_psi_struct_ivvp_rmax_set, 'ivvp_hmin' = vvp_psi_struct_ivvp_hmin_set, 'ivvp_hmax' = vvp_psi_struct_ivvp_hmax_set, 'ivvp_intervals' = vvp_psi_struct_ivvp_intervals_set, 'ipad18x2' = vvp_psi_struct_ipad18x2_set, 'ivvp_quota' = vvp_psi_struct_ivvp_quota_set, 'ivvp_switch' = vvp_psi_struct_ivvp_switch_set, 'ipad_end' = vvp_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for vvp_psi_struct
setMethod('delete', '_p_vvp_psi_struct', function(obj) {delete_vvp_psi_struct(obj)})
# Start definition of copy functions & methods for vvp_psi_struct
CopyToR_vvp_psi_struct = function(value, obj = new("vvp_psi_struct"))
{
  obj@ivvp_rmin = value$ivvp_rmin
  obj@ivvp_rmax = value$ivvp_rmax
  obj@ivvp_hmin = value$ivvp_hmin
  obj@ivvp_hmax = value$ivvp_hmax
  obj@ipad18x2 = value$ipad18x2
  obj@ivvp_quota = value$ivvp_quota
  obj@ivvp_switch = value$ivvp_switch
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_vvp_psi_struct = function(value, obj)
{
  obj$ivvp_rmin = value@ivvp_rmin
  obj$ivvp_rmax = value@ivvp_rmax
  obj$ivvp_hmin = value@ivvp_hmin
  obj$ivvp_hmax = value@ivvp_hmax
  obj$ipad18x2 = value@ipad18x2
  obj$ivvp_quota = value@ivvp_quota
  obj$ivvp_switch = value@ivvp_switch
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for vvp_psi_struct
setMethod('copyToR', '_p_vvp_psi_struct', CopyToR_vvp_psi_struct)
setMethod('copyToC', 'vvp_psi_struct', CopyToC_vvp_psi_struct)

# End definition of copy methods for vvp_psi_struct
# End definition of copy functions & methods for vvp_psi_struct
# Start of warn_psi_struct_iwarn_area_set

`warn_psi_struct_iwarn_area_set` = function(self, s_iwarn_area)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  s_iwarn_area = as.integer(s_iwarn_area) 
  
  if(length(s_iwarn_area) > 1) {
    Rf_warning("using only the first element of s_iwarn_area")
  }
  
  .Call('R_swig_warn_psi_struct_iwarn_area_set', self, s_iwarn_area, PACKAGE='iris')
  
}

attr(`warn_psi_struct_iwarn_area_set`, 'returnType') = 'void'
attr(`warn_psi_struct_iwarn_area_set`, "inputTypes") = c('_p_warn_psi_struct', 'numeric')
class(`warn_psi_struct_iwarn_area_set`) = c("SWIGFunction", class('warn_psi_struct_iwarn_area_set'))

# Start of warn_psi_struct_iwarn_area_get

`warn_psi_struct_iwarn_area_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  .Call('R_swig_warn_psi_struct_iwarn_area_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`warn_psi_struct_iwarn_area_get`, 'returnType') = 'numeric'
attr(`warn_psi_struct_iwarn_area_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_iwarn_area_get`) = c("SWIGFunction", class('warn_psi_struct_iwarn_area_get'))

# Start of warn_psi_struct_iwarn_threshs_set

`warn_psi_struct_iwarn_threshs_set` = function(self, s_iwarn_threshs)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  s_iwarn_threshs = as.integer(s_iwarn_threshs) 
  
#  assert(length(s_iwarn_threshs) >= 3)
  
  .Call('R_swig_warn_psi_struct_iwarn_threshs_set', self, s_iwarn_threshs, PACKAGE='iris')
  
}

attr(`warn_psi_struct_iwarn_threshs_set`, 'returnType') = 'void'
attr(`warn_psi_struct_iwarn_threshs_set`, "inputTypes") = c('_p_warn_psi_struct', '_p_int')
class(`warn_psi_struct_iwarn_threshs_set`) = c("SWIGFunction", class('warn_psi_struct_iwarn_threshs_set'))

# Start of warn_psi_struct_iwarn_threshs_get

`warn_psi_struct_iwarn_threshs_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  ans = .Call('R_swig_warn_psi_struct_iwarn_threshs_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_int"
  
  ans
  
}

attr(`warn_psi_struct_iwarn_threshs_get`, 'returnType') = '_p_int'
attr(`warn_psi_struct_iwarn_threshs_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_iwarn_threshs_get`) = c("SWIGFunction", class('warn_psi_struct_iwarn_threshs_get'))

# Start of warn_psi_struct_iwarn_seconds_set

`warn_psi_struct_iwarn_seconds_set` = function(self, s_iwarn_seconds)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  
  if(is.list(s_iwarn_seconds))
  assert(all(sapply(s_iwarn_seconds, class) == "_p_short"))     
  
  
#  assert(length(s_iwarn_seconds) >= 3)
  
  .Call('R_swig_warn_psi_struct_iwarn_seconds_set', self, s_iwarn_seconds, PACKAGE='iris')
  
}

attr(`warn_psi_struct_iwarn_seconds_set`, 'returnType') = 'void'
attr(`warn_psi_struct_iwarn_seconds_set`, "inputTypes") = c('_p_warn_psi_struct', '_p_short')
class(`warn_psi_struct_iwarn_seconds_set`) = c("SWIGFunction", class('warn_psi_struct_iwarn_seconds_set'))

# Start of warn_psi_struct_iwarn_seconds_get

`warn_psi_struct_iwarn_seconds_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  ans = .Call('R_swig_warn_psi_struct_iwarn_seconds_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`warn_psi_struct_iwarn_seconds_get`, 'returnType') = '_p_short'
attr(`warn_psi_struct_iwarn_seconds_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_iwarn_seconds_get`) = c("SWIGFunction", class('warn_psi_struct_iwarn_seconds_get'))

# Start of warn_psi_struct_ipad22x2_set

`warn_psi_struct_ipad22x2_set` = function(self, s_ipad22x2)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  
  if(is.list(s_ipad22x2))
  assert(all(sapply(s_ipad22x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad22x2) >= 2)
  
  .Call('R_swig_warn_psi_struct_ipad22x2_set', self, s_ipad22x2, PACKAGE='iris')
  
}

attr(`warn_psi_struct_ipad22x2_set`, 'returnType') = 'void'
attr(`warn_psi_struct_ipad22x2_set`, "inputTypes") = c('_p_warn_psi_struct', '_p_char')
class(`warn_psi_struct_ipad22x2_set`) = c("SWIGFunction", class('warn_psi_struct_ipad22x2_set'))

# Start of warn_psi_struct_ipad22x2_get

`warn_psi_struct_ipad22x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  ans = .Call('R_swig_warn_psi_struct_ipad22x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`warn_psi_struct_ipad22x2_get`, 'returnType') = '_p_char'
attr(`warn_psi_struct_ipad22x2_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_ipad22x2_get`) = c("SWIGFunction", class('warn_psi_struct_ipad22x2_get'))

# Start of warn_psi_struct_swarn_symbol_set

`warn_psi_struct_swarn_symbol_set` = function(self, s_swarn_symbol)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  
  if(is.list(s_swarn_symbol))
  assert(all(sapply(s_swarn_symbol, class) == "_p_char"))     
  
  
#  assert(length(s_swarn_symbol) >= 12)
  
  .Call('R_swig_warn_psi_struct_swarn_symbol_set', self, s_swarn_symbol, PACKAGE='iris')
  
}

attr(`warn_psi_struct_swarn_symbol_set`, 'returnType') = 'void'
attr(`warn_psi_struct_swarn_symbol_set`, "inputTypes") = c('_p_warn_psi_struct', '_p_char')
class(`warn_psi_struct_swarn_symbol_set`) = c("SWIGFunction", class('warn_psi_struct_swarn_symbol_set'))

# Start of warn_psi_struct_swarn_symbol_get

`warn_psi_struct_swarn_symbol_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  ans = .Call('R_swig_warn_psi_struct_swarn_symbol_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`warn_psi_struct_swarn_symbol_get`, 'returnType') = '_p_char'
attr(`warn_psi_struct_swarn_symbol_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_swarn_symbol_get`) = c("SWIGFunction", class('warn_psi_struct_swarn_symbol_get'))

# Start of warn_psi_struct_swarn_names_set

`warn_psi_struct_swarn_names_set` = function(self, s_swarn_names)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  
  if(is.list(s_swarn_names))
  assert(all(sapply(s_swarn_names, class) == "_p_a_12__char"))     
  
  
#  assert(length(s_swarn_names) >= 3)
  
  .Call('R_swig_warn_psi_struct_swarn_names_set', self, s_swarn_names, PACKAGE='iris')
  
}

attr(`warn_psi_struct_swarn_names_set`, 'returnType') = 'void'
attr(`warn_psi_struct_swarn_names_set`, "inputTypes") = c('_p_warn_psi_struct', '_p_a_12__char')
class(`warn_psi_struct_swarn_names_set`) = c("SWIGFunction", class('warn_psi_struct_swarn_names_set'))

# Start of warn_psi_struct_swarn_names_get

`warn_psi_struct_swarn_names_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  ans = .Call('R_swig_warn_psi_struct_swarn_names_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_a_12__char"
  
  ans
  
}

attr(`warn_psi_struct_swarn_names_get`, 'returnType') = '_p_a_12__char'
attr(`warn_psi_struct_swarn_names_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_swarn_names_get`) = c("SWIGFunction", class('warn_psi_struct_swarn_names_get'))

# Start of warn_psi_struct_iwarn_prods_set

`warn_psi_struct_iwarn_prods_set` = function(self, s_iwarn_prods)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  
  if(is.list(s_iwarn_prods))
  assert(all(sapply(s_iwarn_prods, class) == "_p_unsigned_char"))     
  
  
#  assert(length(s_iwarn_prods) >= 3)
  
  .Call('R_swig_warn_psi_struct_iwarn_prods_set', self, s_iwarn_prods, PACKAGE='iris')
  
}

attr(`warn_psi_struct_iwarn_prods_set`, 'returnType') = 'void'
attr(`warn_psi_struct_iwarn_prods_set`, "inputTypes") = c('_p_warn_psi_struct', '_p_unsigned_char')
class(`warn_psi_struct_iwarn_prods_set`) = c("SWIGFunction", class('warn_psi_struct_iwarn_prods_set'))

# Start of warn_psi_struct_iwarn_prods_get

`warn_psi_struct_iwarn_prods_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  ans = .Call('R_swig_warn_psi_struct_iwarn_prods_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`warn_psi_struct_iwarn_prods_get`, 'returnType') = '_p_unsigned_char'
attr(`warn_psi_struct_iwarn_prods_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_iwarn_prods_get`) = c("SWIGFunction", class('warn_psi_struct_iwarn_prods_get'))

# Start of warn_psi_struct_iflags_set

`warn_psi_struct_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_unsigned_char") 
  .Call('R_swig_warn_psi_struct_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`warn_psi_struct_iflags_set`, 'returnType') = 'void'
attr(`warn_psi_struct_iflags_set`, "inputTypes") = c('_p_warn_psi_struct', '_p_unsigned_char')
class(`warn_psi_struct_iflags_set`) = c("SWIGFunction", class('warn_psi_struct_iflags_set'))

# Start of warn_psi_struct_iflags_get

`warn_psi_struct_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  ans = .Call('R_swig_warn_psi_struct_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`warn_psi_struct_iflags_get`, 'returnType') = '_p_unsigned_char'
attr(`warn_psi_struct_iflags_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_iflags_get`) = c("SWIGFunction", class('warn_psi_struct_iflags_get'))

# Start of warn_psi_struct_iprotect_mask_set

`warn_psi_struct_iprotect_mask_set` = function(self, s_iprotect_mask)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  s_iprotect_mask = as.numeric(s_iprotect_mask) 
  
  assert(length(s_iprotect_mask) == 1 && s_iprotect_mask >= 0, "All values must be non-negative")
  
  .Call('R_swig_warn_psi_struct_iprotect_mask_set', self, s_iprotect_mask, PACKAGE='iris')
  
}

attr(`warn_psi_struct_iprotect_mask_set`, 'returnType') = 'void'
attr(`warn_psi_struct_iprotect_mask_set`, "inputTypes") = c('_p_warn_psi_struct', 'numeric')
class(`warn_psi_struct_iprotect_mask_set`) = c("SWIGFunction", class('warn_psi_struct_iprotect_mask_set'))

# Start of warn_psi_struct_iprotect_mask_get

`warn_psi_struct_iprotect_mask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  .Call('R_swig_warn_psi_struct_iprotect_mask_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`warn_psi_struct_iprotect_mask_get`, 'returnType') = 'numeric'
attr(`warn_psi_struct_iprotect_mask_get`, "inputTypes") = c('_p_warn_psi_struct')
class(`warn_psi_struct_iprotect_mask_get`) = c("SWIGFunction", class('warn_psi_struct_iprotect_mask_get'))

# Start of new_warn_psi_struct

`warn_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_warn_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_warn_psi_struct"
  
  ans
  
}

attr(`warn_psi_struct`, 'returnType') = '_p_warn_psi_struct'
class(`warn_psi_struct`) = c("SWIGFunction", class('warn_psi_struct'))

# Start of delete_warn_psi_struct

`delete_warn_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_warn_psi_struct") 
  .Call('R_swig_delete_warn_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_warn_psi_struct`, 'returnType') = 'void'
attr(`delete_warn_psi_struct`, "inputTypes") = c('_p_warn_psi_struct')
class(`delete_warn_psi_struct`) = c("SWIGFunction", class('delete_warn_psi_struct'))

# Start of accessor method for warn_psi_struct
setMethod('$', '_p_warn_psi_struct', function(x, name)

{
  accessorFuns = list('iwarn_area' = warn_psi_struct_iwarn_area_get, 'iwarn_threshs' = warn_psi_struct_iwarn_threshs_get, 'iwarn_seconds' = warn_psi_struct_iwarn_seconds_get, 'ipad22x2' = warn_psi_struct_ipad22x2_get, 'swarn_symbol' = warn_psi_struct_swarn_symbol_get, 'swarn_names' = warn_psi_struct_swarn_names_get, 'iwarn_prods' = warn_psi_struct_iwarn_prods_get, 'iflags' = warn_psi_struct_iflags_get, 'iprotect_mask' = warn_psi_struct_iprotect_mask_get)
  vaccessors = c('iwarn_area', 'iwarn_threshs', 'iwarn_seconds', 'ipad22x2', 'swarn_symbol', 'swarn_names', 'iwarn_prods', 'iflags', 'iprotect_mask')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for warn_psi_struct
# Start of accessor method for warn_psi_struct
setMethod('$<-', '_p_warn_psi_struct', function(x, name, value)

{
  accessorFuns = list('iwarn_area' = warn_psi_struct_iwarn_area_set, 'iwarn_threshs' = warn_psi_struct_iwarn_threshs_set, 'iwarn_seconds' = warn_psi_struct_iwarn_seconds_set, 'ipad22x2' = warn_psi_struct_ipad22x2_set, 'swarn_symbol' = warn_psi_struct_swarn_symbol_set, 'swarn_names' = warn_psi_struct_swarn_names_set, 'iwarn_prods' = warn_psi_struct_iwarn_prods_set, 'iflags' = warn_psi_struct_iflags_set, 'iprotect_mask' = warn_psi_struct_iprotect_mask_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_warn_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iwarn_area' = warn_psi_struct_iwarn_area_set, 'iwarn_threshs' = warn_psi_struct_iwarn_threshs_set, 'iwarn_seconds' = warn_psi_struct_iwarn_seconds_set, 'ipad22x2' = warn_psi_struct_ipad22x2_set, 'swarn_symbol' = warn_psi_struct_swarn_symbol_set, 'swarn_names' = warn_psi_struct_swarn_names_set, 'iwarn_prods' = warn_psi_struct_iwarn_prods_set, 'iflags' = warn_psi_struct_iflags_set, 'iprotect_mask' = warn_psi_struct_iprotect_mask_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for warn_psi_struct
setMethod('delete', '_p_warn_psi_struct', function(obj) {delete_warn_psi_struct(obj)})
# Start definition of copy functions & methods for warn_psi_struct
CopyToR_warn_psi_struct = function(value, obj = new("warn_psi_struct"))
{
  obj@iwarn_area = value$iwarn_area
  obj@iwarn_threshs = value$iwarn_threshs
  obj@ipad22x2 = value$ipad22x2
  obj@swarn_symbol = value$swarn_symbol
  obj@swarn_names = value$swarn_names
  obj@iprotect_mask = value$iprotect_mask
  obj
}



CopyToC_warn_psi_struct = function(value, obj)
{
  obj$iwarn_area = value@iwarn_area
  obj$iwarn_threshs = value@iwarn_threshs
  obj$ipad22x2 = value@ipad22x2
  obj$swarn_symbol = value@swarn_symbol
  obj$swarn_names = value@swarn_names
  obj$iprotect_mask = value@iprotect_mask
  obj
}



# Start definition of copy methods for warn_psi_struct
setMethod('copyToR', '_p_warn_psi_struct', CopyToR_warn_psi_struct)
setMethod('copyToC', 'warn_psi_struct', CopyToC_warn_psi_struct)

# End definition of copy methods for warn_psi_struct
# End definition of copy functions & methods for warn_psi_struct
# Start of wind_psi_struct_ihmin_set

`wind_psi_struct_ihmin_set` = function(self, s_ihmin)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_ihmin = as.integer(s_ihmin) 
  
  if(length(s_ihmin) > 1) {
    Rf_warning("using only the first element of s_ihmin")
  }
  
  .Call('R_swig_wind_psi_struct_ihmin_set', self, s_ihmin, PACKAGE='iris')
  
}

attr(`wind_psi_struct_ihmin_set`, 'returnType') = 'void'
attr(`wind_psi_struct_ihmin_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_ihmin_set`) = c("SWIGFunction", class('wind_psi_struct_ihmin_set'))

# Start of wind_psi_struct_ihmin_get

`wind_psi_struct_ihmin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_ihmin_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_ihmin_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_ihmin_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_ihmin_get`) = c("SWIGFunction", class('wind_psi_struct_ihmin_get'))

# Start of wind_psi_struct_ihmax_set

`wind_psi_struct_ihmax_set` = function(self, s_ihmax)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_ihmax = as.integer(s_ihmax) 
  
  if(length(s_ihmax) > 1) {
    Rf_warning("using only the first element of s_ihmax")
  }
  
  .Call('R_swig_wind_psi_struct_ihmax_set', self, s_ihmax, PACKAGE='iris')
  
}

attr(`wind_psi_struct_ihmax_set`, 'returnType') = 'void'
attr(`wind_psi_struct_ihmax_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_ihmax_set`) = c("SWIGFunction", class('wind_psi_struct_ihmax_set'))

# Start of wind_psi_struct_ihmax_get

`wind_psi_struct_ihmax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_ihmax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_ihmax_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_ihmax_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_ihmax_get`) = c("SWIGFunction", class('wind_psi_struct_ihmax_get'))

# Start of wind_psi_struct_irmin_set

`wind_psi_struct_irmin_set` = function(self, s_irmin)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_irmin = as.integer(s_irmin) 
  
  if(length(s_irmin) > 1) {
    Rf_warning("using only the first element of s_irmin")
  }
  
  .Call('R_swig_wind_psi_struct_irmin_set', self, s_irmin, PACKAGE='iris')
  
}

attr(`wind_psi_struct_irmin_set`, 'returnType') = 'void'
attr(`wind_psi_struct_irmin_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_irmin_set`) = c("SWIGFunction", class('wind_psi_struct_irmin_set'))

# Start of wind_psi_struct_irmin_get

`wind_psi_struct_irmin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_irmin_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_irmin_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_irmin_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_irmin_get`) = c("SWIGFunction", class('wind_psi_struct_irmin_get'))

# Start of wind_psi_struct_irmax_set

`wind_psi_struct_irmax_set` = function(self, s_irmax)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_irmax = as.integer(s_irmax) 
  
  if(length(s_irmax) > 1) {
    Rf_warning("using only the first element of s_irmax")
  }
  
  .Call('R_swig_wind_psi_struct_irmax_set', self, s_irmax, PACKAGE='iris')
  
}

attr(`wind_psi_struct_irmax_set`, 'returnType') = 'void'
attr(`wind_psi_struct_irmax_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_irmax_set`) = c("SWIGFunction", class('wind_psi_struct_irmax_set'))

# Start of wind_psi_struct_irmax_get

`wind_psi_struct_irmax_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_irmax_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_irmax_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_irmax_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_irmax_get`) = c("SWIGFunction", class('wind_psi_struct_irmax_get'))

# Start of wind_psi_struct_irange_count_set

`wind_psi_struct_irange_count_set` = function(self, s_irange_count)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_irange_count = as.integer(s_irange_count) 
  
  if(length(s_irange_count) > 1) {
    Rf_warning("using only the first element of s_irange_count")
  }
  
  .Call('R_swig_wind_psi_struct_irange_count_set', self, s_irange_count, PACKAGE='iris')
  
}

attr(`wind_psi_struct_irange_count_set`, 'returnType') = 'void'
attr(`wind_psi_struct_irange_count_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_irange_count_set`) = c("SWIGFunction", class('wind_psi_struct_irange_count_set'))

# Start of wind_psi_struct_irange_count_get

`wind_psi_struct_irange_count_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_irange_count_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_irange_count_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_irange_count_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_irange_count_get`) = c("SWIGFunction", class('wind_psi_struct_irange_count_get'))

# Start of wind_psi_struct_iazimuth_count_set

`wind_psi_struct_iazimuth_count_set` = function(self, s_iazimuth_count)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_iazimuth_count = as.integer(s_iazimuth_count) 
  
  if(length(s_iazimuth_count) > 1) {
    Rf_warning("using only the first element of s_iazimuth_count")
  }
  
  .Call('R_swig_wind_psi_struct_iazimuth_count_set', self, s_iazimuth_count, PACKAGE='iris')
  
}

attr(`wind_psi_struct_iazimuth_count_set`, 'returnType') = 'void'
attr(`wind_psi_struct_iazimuth_count_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_iazimuth_count_set`) = c("SWIGFunction", class('wind_psi_struct_iazimuth_count_set'))

# Start of wind_psi_struct_iazimuth_count_get

`wind_psi_struct_iazimuth_count_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_iazimuth_count_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_iazimuth_count_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_iazimuth_count_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_iazimuth_count_get`) = c("SWIGFunction", class('wind_psi_struct_iazimuth_count_get'))

# Start of wind_psi_struct_isector_length_set

`wind_psi_struct_isector_length_set` = function(self, s_isector_length)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_isector_length = as.integer(s_isector_length) 
  
  if(length(s_isector_length) > 1) {
    Rf_warning("using only the first element of s_isector_length")
  }
  
  .Call('R_swig_wind_psi_struct_isector_length_set', self, s_isector_length, PACKAGE='iris')
  
}

attr(`wind_psi_struct_isector_length_set`, 'returnType') = 'void'
attr(`wind_psi_struct_isector_length_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_isector_length_set`) = c("SWIGFunction", class('wind_psi_struct_isector_length_set'))

# Start of wind_psi_struct_isector_length_get

`wind_psi_struct_isector_length_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_isector_length_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_isector_length_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_isector_length_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_isector_length_get`) = c("SWIGFunction", class('wind_psi_struct_isector_length_get'))

# Start of wind_psi_struct_isector_width_set

`wind_psi_struct_isector_width_set` = function(self, s_isector_width)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_isector_width = as.numeric(s_isector_width) 
  
  assert(length(s_isector_width) == 1 && s_isector_width >= 0, "All values must be non-negative")
  
  .Call('R_swig_wind_psi_struct_isector_width_set', self, s_isector_width, PACKAGE='iris')
  
}

attr(`wind_psi_struct_isector_width_set`, 'returnType') = 'void'
attr(`wind_psi_struct_isector_width_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_isector_width_set`) = c("SWIGFunction", class('wind_psi_struct_isector_width_set'))

# Start of wind_psi_struct_isector_width_get

`wind_psi_struct_isector_width_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_isector_width_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_isector_width_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_isector_width_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_isector_width_get`) = c("SWIGFunction", class('wind_psi_struct_isector_width_get'))

# Start of wind_psi_struct_iflags_set

`wind_psi_struct_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_wind_psi_struct_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`wind_psi_struct_iflags_set`, 'returnType') = 'void'
attr(`wind_psi_struct_iflags_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_iflags_set`) = c("SWIGFunction", class('wind_psi_struct_iflags_set'))

# Start of wind_psi_struct_iflags_get

`wind_psi_struct_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_iflags_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_iflags_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_iflags_get`) = c("SWIGFunction", class('wind_psi_struct_iflags_get'))

# Start of wind_psi_struct_ivvp_switch_set

`wind_psi_struct_ivvp_switch_set` = function(self, s_ivvp_switch)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  s_ivvp_switch = as.numeric(s_ivvp_switch) 
  
  assert(length(s_ivvp_switch) == 1 && s_ivvp_switch >= 0, "All values must be non-negative")
  
  .Call('R_swig_wind_psi_struct_ivvp_switch_set', self, s_ivvp_switch, PACKAGE='iris')
  
}

attr(`wind_psi_struct_ivvp_switch_set`, 'returnType') = 'void'
attr(`wind_psi_struct_ivvp_switch_set`, "inputTypes") = c('_p_wind_psi_struct', 'numeric')
class(`wind_psi_struct_ivvp_switch_set`) = c("SWIGFunction", class('wind_psi_struct_ivvp_switch_set'))

# Start of wind_psi_struct_ivvp_switch_get

`wind_psi_struct_ivvp_switch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_wind_psi_struct_ivvp_switch_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`wind_psi_struct_ivvp_switch_get`, 'returnType') = 'numeric'
attr(`wind_psi_struct_ivvp_switch_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_ivvp_switch_get`) = c("SWIGFunction", class('wind_psi_struct_ivvp_switch_get'))

# Start of wind_psi_struct_ipad_end_set

`wind_psi_struct_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (80) -40)
  
  .Call('R_swig_wind_psi_struct_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`wind_psi_struct_ipad_end_set`, 'returnType') = 'void'
attr(`wind_psi_struct_ipad_end_set`, "inputTypes") = c('_p_wind_psi_struct', '_p_char')
class(`wind_psi_struct_ipad_end_set`) = c("SWIGFunction", class('wind_psi_struct_ipad_end_set'))

# Start of wind_psi_struct_ipad_end_get

`wind_psi_struct_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  ans = .Call('R_swig_wind_psi_struct_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`wind_psi_struct_ipad_end_get`, 'returnType') = '_p_char'
attr(`wind_psi_struct_ipad_end_get`, "inputTypes") = c('_p_wind_psi_struct')
class(`wind_psi_struct_ipad_end_get`) = c("SWIGFunction", class('wind_psi_struct_ipad_end_get'))

# Start of new_wind_psi_struct

`wind_psi_struct` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_wind_psi_struct', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_wind_psi_struct"
  
  ans
  
}

attr(`wind_psi_struct`, 'returnType') = '_p_wind_psi_struct'
class(`wind_psi_struct`) = c("SWIGFunction", class('wind_psi_struct'))

# Start of delete_wind_psi_struct

`delete_wind_psi_struct` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_wind_psi_struct") 
  .Call('R_swig_delete_wind_psi_struct', self, PACKAGE='iris')
  
}

attr(`delete_wind_psi_struct`, 'returnType') = 'void'
attr(`delete_wind_psi_struct`, "inputTypes") = c('_p_wind_psi_struct')
class(`delete_wind_psi_struct`) = c("SWIGFunction", class('delete_wind_psi_struct'))

# Start of accessor method for wind_psi_struct
setMethod('$', '_p_wind_psi_struct', function(x, name)

{
  accessorFuns = list('ihmin' = wind_psi_struct_ihmin_get, 'ihmax' = wind_psi_struct_ihmax_get, 'irmin' = wind_psi_struct_irmin_get, 'irmax' = wind_psi_struct_irmax_get, 'irange_count' = wind_psi_struct_irange_count_get, 'iazimuth_count' = wind_psi_struct_iazimuth_count_get, 'isector_length' = wind_psi_struct_isector_length_get, 'isector_width' = wind_psi_struct_isector_width_get, 'iflags' = wind_psi_struct_iflags_get, 'ivvp_switch' = wind_psi_struct_ivvp_switch_get, 'ipad_end' = wind_psi_struct_ipad_end_get)
  vaccessors = c('ihmin', 'ihmax', 'irmin', 'irmax', 'irange_count', 'iazimuth_count', 'isector_length', 'isector_width', 'iflags', 'ivvp_switch', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for wind_psi_struct
# Start of accessor method for wind_psi_struct
setMethod('$<-', '_p_wind_psi_struct', function(x, name, value)

{
  accessorFuns = list('ihmin' = wind_psi_struct_ihmin_set, 'ihmax' = wind_psi_struct_ihmax_set, 'irmin' = wind_psi_struct_irmin_set, 'irmax' = wind_psi_struct_irmax_set, 'irange_count' = wind_psi_struct_irange_count_set, 'iazimuth_count' = wind_psi_struct_iazimuth_count_set, 'isector_length' = wind_psi_struct_isector_length_set, 'isector_width' = wind_psi_struct_isector_width_set, 'iflags' = wind_psi_struct_iflags_set, 'ivvp_switch' = wind_psi_struct_ivvp_switch_set, 'ipad_end' = wind_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_wind_psi_struct', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ihmin' = wind_psi_struct_ihmin_set, 'ihmax' = wind_psi_struct_ihmax_set, 'irmin' = wind_psi_struct_irmin_set, 'irmax' = wind_psi_struct_irmax_set, 'irange_count' = wind_psi_struct_irange_count_set, 'iazimuth_count' = wind_psi_struct_iazimuth_count_set, 'isector_length' = wind_psi_struct_isector_length_set, 'isector_width' = wind_psi_struct_isector_width_set, 'iflags' = wind_psi_struct_iflags_set, 'ivvp_switch' = wind_psi_struct_ivvp_switch_set, 'ipad_end' = wind_psi_struct_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for wind_psi_struct
setMethod('delete', '_p_wind_psi_struct', function(obj) {delete_wind_psi_struct(obj)})
# Start definition of copy functions & methods for wind_psi_struct
CopyToR_wind_psi_struct = function(value, obj = new("wind_psi_struct"))
{
  obj@ihmin = value$ihmin
  obj@ihmax = value$ihmax
  obj@irmin = value$irmin
  obj@irmax = value$irmax
  obj@irange_count = value$irange_count
  obj@iazimuth_count = value$iazimuth_count
  obj@isector_length = value$isector_length
  obj@isector_width = value$isector_width
  obj@iflags = value$iflags
  obj@ivvp_switch = value$ivvp_switch
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_wind_psi_struct = function(value, obj)
{
  obj$ihmin = value@ihmin
  obj$ihmax = value@ihmax
  obj$irmin = value@irmin
  obj$irmax = value@irmax
  obj$irange_count = value@irange_count
  obj$iazimuth_count = value@iazimuth_count
  obj$isector_length = value@isector_length
  obj$isector_width = value@isector_width
  obj$iflags = value@iflags
  obj$ivvp_switch = value@ivvp_switch
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for wind_psi_struct
setMethod('copyToR', '_p_wind_psi_struct', CopyToR_wind_psi_struct)
setMethod('copyToC', 'wind_psi_struct', CopyToC_wind_psi_struct)

# End definition of copy methods for wind_psi_struct
# End definition of copy functions & methods for wind_psi_struct
# Start of product_specific_info_beam_set

`product_specific_info_beam_set` = function(self, s_beam)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_beam = coerceIfNotSubclass(s_beam, "_p_beam_psi_struct") 
  .Call('R_swig_product_specific_info_beam_set', self, s_beam, PACKAGE='iris')
  
}

attr(`product_specific_info_beam_set`, 'returnType') = 'void'
attr(`product_specific_info_beam_set`, "inputTypes") = c('_p_product_specific_info', '_p_beam_psi_struct')
class(`product_specific_info_beam_set`) = c("SWIGFunction", class('product_specific_info_beam_set'))

# Start of product_specific_info_beam_get

`product_specific_info_beam_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_beam_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_beam_psi_struct"
  
  ans
  
}

attr(`product_specific_info_beam_get`, 'returnType') = '_p_beam_psi_struct'
attr(`product_specific_info_beam_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_beam_get`) = c("SWIGFunction", class('product_specific_info_beam_get'))

# Start of product_specific_info_cappi_set

`product_specific_info_cappi_set` = function(self, s_cappi)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_cappi = coerceIfNotSubclass(s_cappi, "_p_cappi_psi_struct") 
  .Call('R_swig_product_specific_info_cappi_set', self, s_cappi, PACKAGE='iris')
  
}

attr(`product_specific_info_cappi_set`, 'returnType') = 'void'
attr(`product_specific_info_cappi_set`, "inputTypes") = c('_p_product_specific_info', '_p_cappi_psi_struct')
class(`product_specific_info_cappi_set`) = c("SWIGFunction", class('product_specific_info_cappi_set'))

# Start of product_specific_info_cappi_get

`product_specific_info_cappi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_cappi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_cappi_psi_struct"
  
  ans
  
}

attr(`product_specific_info_cappi_get`, 'returnType') = '_p_cappi_psi_struct'
attr(`product_specific_info_cappi_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_cappi_get`) = c("SWIGFunction", class('product_specific_info_cappi_get'))

# Start of product_specific_info_Catch_set

`product_specific_info_Catch_set` = function(self, s_Catch)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_Catch = coerceIfNotSubclass(s_Catch, "_p_catch_psi_struct") 
  .Call('R_swig_product_specific_info_Catch_set', self, s_Catch, PACKAGE='iris')
  
}

attr(`product_specific_info_Catch_set`, 'returnType') = 'void'
attr(`product_specific_info_Catch_set`, "inputTypes") = c('_p_product_specific_info', '_p_catch_psi_struct')
class(`product_specific_info_Catch_set`) = c("SWIGFunction", class('product_specific_info_Catch_set'))

# Start of product_specific_info_Catch_get

`product_specific_info_Catch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_Catch_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_catch_psi_struct"
  
  ans
  
}

attr(`product_specific_info_Catch_get`, 'returnType') = '_p_catch_psi_struct'
attr(`product_specific_info_Catch_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_Catch_get`) = c("SWIGFunction", class('product_specific_info_Catch_get'))

# Start of product_specific_info_comp_set

`product_specific_info_comp_set` = function(self, s_comp)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_comp = coerceIfNotSubclass(s_comp, "_p_comp_psi_struct") 
  .Call('R_swig_product_specific_info_comp_set', self, s_comp, PACKAGE='iris')
  
}

attr(`product_specific_info_comp_set`, 'returnType') = 'void'
attr(`product_specific_info_comp_set`, "inputTypes") = c('_p_product_specific_info', '_p_comp_psi_struct')
class(`product_specific_info_comp_set`) = c("SWIGFunction", class('product_specific_info_comp_set'))

# Start of product_specific_info_comp_get

`product_specific_info_comp_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_comp_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_comp_psi_struct"
  
  ans
  
}

attr(`product_specific_info_comp_get`, 'returnType') = '_p_comp_psi_struct'
attr(`product_specific_info_comp_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_comp_get`) = c("SWIGFunction", class('product_specific_info_comp_get'))

# Start of product_specific_info_cross_set

`product_specific_info_cross_set` = function(self, s_cross)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_cross = coerceIfNotSubclass(s_cross, "_p_cross_psi_struct") 
  .Call('R_swig_product_specific_info_cross_set', self, s_cross, PACKAGE='iris')
  
}

attr(`product_specific_info_cross_set`, 'returnType') = 'void'
attr(`product_specific_info_cross_set`, "inputTypes") = c('_p_product_specific_info', '_p_cross_psi_struct')
class(`product_specific_info_cross_set`) = c("SWIGFunction", class('product_specific_info_cross_set'))

# Start of product_specific_info_cross_get

`product_specific_info_cross_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_cross_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_cross_psi_struct"
  
  ans
  
}

attr(`product_specific_info_cross_get`, 'returnType') = '_p_cross_psi_struct'
attr(`product_specific_info_cross_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_cross_get`) = c("SWIGFunction", class('product_specific_info_cross_get'))

# Start of product_specific_info_Dwell_set

`product_specific_info_Dwell_set` = function(self, s_Dwell)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_Dwell = coerceIfNotSubclass(s_Dwell, "_p_dwell_psi_struct") 
  .Call('R_swig_product_specific_info_Dwell_set', self, s_Dwell, PACKAGE='iris')
  
}

attr(`product_specific_info_Dwell_set`, 'returnType') = 'void'
attr(`product_specific_info_Dwell_set`, "inputTypes") = c('_p_product_specific_info', '_p_dwell_psi_struct')
class(`product_specific_info_Dwell_set`) = c("SWIGFunction", class('product_specific_info_Dwell_set'))

# Start of product_specific_info_Dwell_get

`product_specific_info_Dwell_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_Dwell_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dwell_psi_struct"
  
  ans
  
}

attr(`product_specific_info_Dwell_get`, 'returnType') = '_p_dwell_psi_struct'
attr(`product_specific_info_Dwell_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_Dwell_get`) = c("SWIGFunction", class('product_specific_info_Dwell_get'))

# Start of product_specific_info_fcast_set

`product_specific_info_fcast_set` = function(self, s_fcast)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_fcast = coerceIfNotSubclass(s_fcast, "_p_fcast_psi_struct") 
  .Call('R_swig_product_specific_info_fcast_set', self, s_fcast, PACKAGE='iris')
  
}

attr(`product_specific_info_fcast_set`, 'returnType') = 'void'
attr(`product_specific_info_fcast_set`, "inputTypes") = c('_p_product_specific_info', '_p_fcast_psi_struct')
class(`product_specific_info_fcast_set`) = c("SWIGFunction", class('product_specific_info_fcast_set'))

# Start of product_specific_info_fcast_get

`product_specific_info_fcast_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_fcast_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_fcast_psi_struct"
  
  ans
  
}

attr(`product_specific_info_fcast_get`, 'returnType') = '_p_fcast_psi_struct'
attr(`product_specific_info_fcast_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_fcast_get`) = c("SWIGFunction", class('product_specific_info_fcast_get'))

# Start of product_specific_info_Gage_set

`product_specific_info_Gage_set` = function(self, s_Gage)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_Gage = coerceIfNotSubclass(s_Gage, "_p_gage_psi_struct") 
  .Call('R_swig_product_specific_info_Gage_set', self, s_Gage, PACKAGE='iris')
  
}

attr(`product_specific_info_Gage_set`, 'returnType') = 'void'
attr(`product_specific_info_Gage_set`, "inputTypes") = c('_p_product_specific_info', '_p_gage_psi_struct')
class(`product_specific_info_Gage_set`) = c("SWIGFunction", class('product_specific_info_Gage_set'))

# Start of product_specific_info_Gage_get

`product_specific_info_Gage_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_Gage_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_gage_psi_struct"
  
  ans
  
}

attr(`product_specific_info_Gage_get`, 'returnType') = '_p_gage_psi_struct'
attr(`product_specific_info_Gage_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_Gage_get`) = c("SWIGFunction", class('product_specific_info_Gage_get'))

# Start of product_specific_info_max_set

`product_specific_info_max_set` = function(self, s_max)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_max = coerceIfNotSubclass(s_max, "_p_maximum_psi_struct") 
  .Call('R_swig_product_specific_info_max_set', self, s_max, PACKAGE='iris')
  
}

attr(`product_specific_info_max_set`, 'returnType') = 'void'
attr(`product_specific_info_max_set`, "inputTypes") = c('_p_product_specific_info', '_p_maximum_psi_struct')
class(`product_specific_info_max_set`) = c("SWIGFunction", class('product_specific_info_max_set'))

# Start of product_specific_info_max_get

`product_specific_info_max_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_max_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_maximum_psi_struct"
  
  ans
  
}

attr(`product_specific_info_max_get`, 'returnType') = '_p_maximum_psi_struct'
attr(`product_specific_info_max_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_max_get`) = c("SWIGFunction", class('product_specific_info_max_get'))

# Start of product_specific_info_ndop_set

`product_specific_info_ndop_set` = function(self, s_ndop)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_ndop = coerceIfNotSubclass(s_ndop, "_p_ndop_psi_struct") 
  .Call('R_swig_product_specific_info_ndop_set', self, s_ndop, PACKAGE='iris')
  
}

attr(`product_specific_info_ndop_set`, 'returnType') = 'void'
attr(`product_specific_info_ndop_set`, "inputTypes") = c('_p_product_specific_info', '_p_ndop_psi_struct')
class(`product_specific_info_ndop_set`) = c("SWIGFunction", class('product_specific_info_ndop_set'))

# Start of product_specific_info_ndop_get

`product_specific_info_ndop_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_ndop_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ndop_psi_struct"
  
  ans
  
}

attr(`product_specific_info_ndop_get`, 'returnType') = '_p_ndop_psi_struct'
attr(`product_specific_info_ndop_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_ndop_get`) = c("SWIGFunction", class('product_specific_info_ndop_get'))

# Start of product_specific_info_ppi_set

`product_specific_info_ppi_set` = function(self, s_ppi)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_ppi = coerceIfNotSubclass(s_ppi, "_p_ppi_psi_struct") 
  .Call('R_swig_product_specific_info_ppi_set', self, s_ppi, PACKAGE='iris')
  
}

attr(`product_specific_info_ppi_set`, 'returnType') = 'void'
attr(`product_specific_info_ppi_set`, "inputTypes") = c('_p_product_specific_info', '_p_ppi_psi_struct')
class(`product_specific_info_ppi_set`) = c("SWIGFunction", class('product_specific_info_ppi_set'))

# Start of product_specific_info_ppi_get

`product_specific_info_ppi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_ppi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ppi_psi_struct"
  
  ans
  
}

attr(`product_specific_info_ppi_get`, 'returnType') = '_p_ppi_psi_struct'
attr(`product_specific_info_ppi_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_ppi_get`) = c("SWIGFunction", class('product_specific_info_ppi_get'))

# Start of product_specific_info_rain_set

`product_specific_info_rain_set` = function(self, s_rain)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_rain = coerceIfNotSubclass(s_rain, "_p_rain_psi_struct") 
  .Call('R_swig_product_specific_info_rain_set', self, s_rain, PACKAGE='iris')
  
}

attr(`product_specific_info_rain_set`, 'returnType') = 'void'
attr(`product_specific_info_rain_set`, "inputTypes") = c('_p_product_specific_info', '_p_rain_psi_struct')
class(`product_specific_info_rain_set`) = c("SWIGFunction", class('product_specific_info_rain_set'))

# Start of product_specific_info_rain_get

`product_specific_info_rain_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_rain_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_rain_psi_struct"
  
  ans
  
}

attr(`product_specific_info_rain_get`, 'returnType') = '_p_rain_psi_struct'
attr(`product_specific_info_rain_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_rain_get`) = c("SWIGFunction", class('product_specific_info_rain_get'))

# Start of product_specific_info_raw_set

`product_specific_info_raw_set` = function(self, s_raw)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_raw = coerceIfNotSubclass(s_raw, "_p_raw_psi_struct") 
  .Call('R_swig_product_specific_info_raw_set', self, s_raw, PACKAGE='iris')
  
}

attr(`product_specific_info_raw_set`, 'returnType') = 'void'
attr(`product_specific_info_raw_set`, "inputTypes") = c('_p_product_specific_info', '_p_raw_psi_struct')
class(`product_specific_info_raw_set`) = c("SWIGFunction", class('product_specific_info_raw_set'))

# Start of product_specific_info_raw_get

`product_specific_info_raw_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_raw_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_raw_psi_struct"
  
  ans
  
}

attr(`product_specific_info_raw_get`, 'returnType') = '_p_raw_psi_struct'
attr(`product_specific_info_raw_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_raw_get`) = c("SWIGFunction", class('product_specific_info_raw_get'))

# Start of product_specific_info_rhi_set

`product_specific_info_rhi_set` = function(self, s_rhi)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_rhi = coerceIfNotSubclass(s_rhi, "_p_rhi_psi_struct") 
  .Call('R_swig_product_specific_info_rhi_set', self, s_rhi, PACKAGE='iris')
  
}

attr(`product_specific_info_rhi_set`, 'returnType') = 'void'
attr(`product_specific_info_rhi_set`, "inputTypes") = c('_p_product_specific_info', '_p_rhi_psi_struct')
class(`product_specific_info_rhi_set`) = c("SWIGFunction", class('product_specific_info_rhi_set'))

# Start of product_specific_info_rhi_get

`product_specific_info_rhi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_rhi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_rhi_psi_struct"
  
  ans
  
}

attr(`product_specific_info_rhi_get`, 'returnType') = '_p_rhi_psi_struct'
attr(`product_specific_info_rhi_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_rhi_get`) = c("SWIGFunction", class('product_specific_info_rhi_get'))

# Start of product_specific_info_rti_set

`product_specific_info_rti_set` = function(self, s_rti)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_rti = coerceIfNotSubclass(s_rti, "_p_rti_psi_struct") 
  .Call('R_swig_product_specific_info_rti_set', self, s_rti, PACKAGE='iris')
  
}

attr(`product_specific_info_rti_set`, 'returnType') = 'void'
attr(`product_specific_info_rti_set`, "inputTypes") = c('_p_product_specific_info', '_p_rti_psi_struct')
class(`product_specific_info_rti_set`) = c("SWIGFunction", class('product_specific_info_rti_set'))

# Start of product_specific_info_rti_get

`product_specific_info_rti_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_rti_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_rti_psi_struct"
  
  ans
  
}

attr(`product_specific_info_rti_get`, 'returnType') = '_p_rti_psi_struct'
attr(`product_specific_info_rti_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_rti_get`) = c("SWIGFunction", class('product_specific_info_rti_get'))

# Start of product_specific_info_shear_set

`product_specific_info_shear_set` = function(self, s_shear)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_shear = coerceIfNotSubclass(s_shear, "_p_shear_psi_struct") 
  .Call('R_swig_product_specific_info_shear_set', self, s_shear, PACKAGE='iris')
  
}

attr(`product_specific_info_shear_set`, 'returnType') = 'void'
attr(`product_specific_info_shear_set`, "inputTypes") = c('_p_product_specific_info', '_p_shear_psi_struct')
class(`product_specific_info_shear_set`) = c("SWIGFunction", class('product_specific_info_shear_set'))

# Start of product_specific_info_shear_get

`product_specific_info_shear_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_shear_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_shear_psi_struct"
  
  ans
  
}

attr(`product_specific_info_shear_get`, 'returnType') = '_p_shear_psi_struct'
attr(`product_specific_info_shear_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_shear_get`) = c("SWIGFunction", class('product_specific_info_shear_get'))

# Start of product_specific_info_sline_set

`product_specific_info_sline_set` = function(self, s_sline)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_sline = coerceIfNotSubclass(s_sline, "_p_sline_psi_struct") 
  .Call('R_swig_product_specific_info_sline_set', self, s_sline, PACKAGE='iris')
  
}

attr(`product_specific_info_sline_set`, 'returnType') = 'void'
attr(`product_specific_info_sline_set`, "inputTypes") = c('_p_product_specific_info', '_p_sline_psi_struct')
class(`product_specific_info_sline_set`) = c("SWIGFunction", class('product_specific_info_sline_set'))

# Start of product_specific_info_sline_get

`product_specific_info_sline_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_sline_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_sline_psi_struct"
  
  ans
  
}

attr(`product_specific_info_sline_get`, 'returnType') = '_p_sline_psi_struct'
attr(`product_specific_info_sline_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_sline_get`) = c("SWIGFunction", class('product_specific_info_sline_get'))

# Start of product_specific_info_Sri_set

`product_specific_info_Sri_set` = function(self, s_Sri)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_Sri = coerceIfNotSubclass(s_Sri, "_p_sri_psi_struct") 
  .Call('R_swig_product_specific_info_Sri_set', self, s_Sri, PACKAGE='iris')
  
}

attr(`product_specific_info_Sri_set`, 'returnType') = 'void'
attr(`product_specific_info_Sri_set`, "inputTypes") = c('_p_product_specific_info', '_p_sri_psi_struct')
class(`product_specific_info_Sri_set`) = c("SWIGFunction", class('product_specific_info_Sri_set'))

# Start of product_specific_info_Sri_get

`product_specific_info_Sri_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_Sri_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_sri_psi_struct"
  
  ans
  
}

attr(`product_specific_info_Sri_get`, 'returnType') = '_p_sri_psi_struct'
attr(`product_specific_info_Sri_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_Sri_get`) = c("SWIGFunction", class('product_specific_info_Sri_get'))

# Start of product_specific_info_tdwr_set

`product_specific_info_tdwr_set` = function(self, s_tdwr)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_tdwr = coerceIfNotSubclass(s_tdwr, "_p_tdwr_psi_struct") 
  .Call('R_swig_product_specific_info_tdwr_set', self, s_tdwr, PACKAGE='iris')
  
}

attr(`product_specific_info_tdwr_set`, 'returnType') = 'void'
attr(`product_specific_info_tdwr_set`, "inputTypes") = c('_p_product_specific_info', '_p_tdwr_psi_struct')
class(`product_specific_info_tdwr_set`) = c("SWIGFunction", class('product_specific_info_tdwr_set'))

# Start of product_specific_info_tdwr_get

`product_specific_info_tdwr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_tdwr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_tdwr_psi_struct"
  
  ans
  
}

attr(`product_specific_info_tdwr_get`, 'returnType') = '_p_tdwr_psi_struct'
attr(`product_specific_info_tdwr_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_tdwr_get`) = c("SWIGFunction", class('product_specific_info_tdwr_get'))

# Start of product_specific_info_top_set

`product_specific_info_top_set` = function(self, s_top)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_top = coerceIfNotSubclass(s_top, "_p_top_psi_struct") 
  .Call('R_swig_product_specific_info_top_set', self, s_top, PACKAGE='iris')
  
}

attr(`product_specific_info_top_set`, 'returnType') = 'void'
attr(`product_specific_info_top_set`, "inputTypes") = c('_p_product_specific_info', '_p_top_psi_struct')
class(`product_specific_info_top_set`) = c("SWIGFunction", class('product_specific_info_top_set'))

# Start of product_specific_info_top_get

`product_specific_info_top_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_top_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_top_psi_struct"
  
  ans
  
}

attr(`product_specific_info_top_get`, 'returnType') = '_p_top_psi_struct'
attr(`product_specific_info_top_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_top_get`) = c("SWIGFunction", class('product_specific_info_top_get'))

# Start of product_specific_info_track_set

`product_specific_info_track_set` = function(self, s_track)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_track = coerceIfNotSubclass(s_track, "_p_track_psi_struct") 
  .Call('R_swig_product_specific_info_track_set', self, s_track, PACKAGE='iris')
  
}

attr(`product_specific_info_track_set`, 'returnType') = 'void'
attr(`product_specific_info_track_set`, "inputTypes") = c('_p_product_specific_info', '_p_track_psi_struct')
class(`product_specific_info_track_set`) = c("SWIGFunction", class('product_specific_info_track_set'))

# Start of product_specific_info_track_get

`product_specific_info_track_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_track_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_track_psi_struct"
  
  ans
  
}

attr(`product_specific_info_track_get`, 'returnType') = '_p_track_psi_struct'
attr(`product_specific_info_track_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_track_get`) = c("SWIGFunction", class('product_specific_info_track_get'))

# Start of product_specific_info_user_set

`product_specific_info_user_set` = function(self, s_user)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_user = coerceIfNotSubclass(s_user, "_p_user_psi_struct") 
  .Call('R_swig_product_specific_info_user_set', self, s_user, PACKAGE='iris')
  
}

attr(`product_specific_info_user_set`, 'returnType') = 'void'
attr(`product_specific_info_user_set`, "inputTypes") = c('_p_product_specific_info', '_p_user_psi_struct')
class(`product_specific_info_user_set`) = c("SWIGFunction", class('product_specific_info_user_set'))

# Start of product_specific_info_user_get

`product_specific_info_user_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_user_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_user_psi_struct"
  
  ans
  
}

attr(`product_specific_info_user_get`, 'returnType') = '_p_user_psi_struct'
attr(`product_specific_info_user_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_user_get`) = c("SWIGFunction", class('product_specific_info_user_get'))

# Start of product_specific_info_vil_set

`product_specific_info_vil_set` = function(self, s_vil)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_vil = coerceIfNotSubclass(s_vil, "_p_vil_psi_struct") 
  .Call('R_swig_product_specific_info_vil_set', self, s_vil, PACKAGE='iris')
  
}

attr(`product_specific_info_vil_set`, 'returnType') = 'void'
attr(`product_specific_info_vil_set`, "inputTypes") = c('_p_product_specific_info', '_p_vil_psi_struct')
class(`product_specific_info_vil_set`) = c("SWIGFunction", class('product_specific_info_vil_set'))

# Start of product_specific_info_vil_get

`product_specific_info_vil_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_vil_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_vil_psi_struct"
  
  ans
  
}

attr(`product_specific_info_vil_get`, 'returnType') = '_p_vil_psi_struct'
attr(`product_specific_info_vil_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_vil_get`) = c("SWIGFunction", class('product_specific_info_vil_get'))

# Start of product_specific_info_vvp_set

`product_specific_info_vvp_set` = function(self, s_vvp)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_vvp = coerceIfNotSubclass(s_vvp, "_p_vvp_psi_struct") 
  .Call('R_swig_product_specific_info_vvp_set', self, s_vvp, PACKAGE='iris')
  
}

attr(`product_specific_info_vvp_set`, 'returnType') = 'void'
attr(`product_specific_info_vvp_set`, "inputTypes") = c('_p_product_specific_info', '_p_vvp_psi_struct')
class(`product_specific_info_vvp_set`) = c("SWIGFunction", class('product_specific_info_vvp_set'))

# Start of product_specific_info_vvp_get

`product_specific_info_vvp_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_vvp_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_vvp_psi_struct"
  
  ans
  
}

attr(`product_specific_info_vvp_get`, 'returnType') = '_p_vvp_psi_struct'
attr(`product_specific_info_vvp_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_vvp_get`) = c("SWIGFunction", class('product_specific_info_vvp_get'))

# Start of product_specific_info_warn_set

`product_specific_info_warn_set` = function(self, s_warn)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_warn = coerceIfNotSubclass(s_warn, "_p_warn_psi_struct") 
  .Call('R_swig_product_specific_info_warn_set', self, s_warn, PACKAGE='iris')
  
}

attr(`product_specific_info_warn_set`, 'returnType') = 'void'
attr(`product_specific_info_warn_set`, "inputTypes") = c('_p_product_specific_info', '_p_warn_psi_struct')
class(`product_specific_info_warn_set`) = c("SWIGFunction", class('product_specific_info_warn_set'))

# Start of product_specific_info_warn_get

`product_specific_info_warn_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_warn_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_warn_psi_struct"
  
  ans
  
}

attr(`product_specific_info_warn_get`, 'returnType') = '_p_warn_psi_struct'
attr(`product_specific_info_warn_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_warn_get`) = c("SWIGFunction", class('product_specific_info_warn_get'))

# Start of product_specific_info_wind_set

`product_specific_info_wind_set` = function(self, s_wind)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  s_wind = coerceIfNotSubclass(s_wind, "_p_wind_psi_struct") 
  .Call('R_swig_product_specific_info_wind_set', self, s_wind, PACKAGE='iris')
  
}

attr(`product_specific_info_wind_set`, 'returnType') = 'void'
attr(`product_specific_info_wind_set`, "inputTypes") = c('_p_product_specific_info', '_p_wind_psi_struct')
class(`product_specific_info_wind_set`) = c("SWIGFunction", class('product_specific_info_wind_set'))

# Start of product_specific_info_wind_get

`product_specific_info_wind_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_wind_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_wind_psi_struct"
  
  ans
  
}

attr(`product_specific_info_wind_get`, 'returnType') = '_p_wind_psi_struct'
attr(`product_specific_info_wind_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_wind_get`) = c("SWIGFunction", class('product_specific_info_wind_get'))

# Start of product_specific_info_ipad_set

`product_specific_info_ipad_set` = function(self, s_ipad)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  
  if(is.list(s_ipad))
  assert(all(sapply(s_ipad, class) == "_p_char"))     
  
  
#  assert(length(s_ipad) >= (80))
  
  .Call('R_swig_product_specific_info_ipad_set', self, s_ipad, PACKAGE='iris')
  
}

attr(`product_specific_info_ipad_set`, 'returnType') = 'void'
attr(`product_specific_info_ipad_set`, "inputTypes") = c('_p_product_specific_info', '_p_char')
class(`product_specific_info_ipad_set`) = c("SWIGFunction", class('product_specific_info_ipad_set'))

# Start of product_specific_info_ipad_get

`product_specific_info_ipad_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  ans = .Call('R_swig_product_specific_info_ipad_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_specific_info_ipad_get`, 'returnType') = '_p_char'
attr(`product_specific_info_ipad_get`, "inputTypes") = c('_p_product_specific_info')
class(`product_specific_info_ipad_get`) = c("SWIGFunction", class('product_specific_info_ipad_get'))

# Start of new_product_specific_info

`product_specific_info` = function()
{
  ans = .Call('R_swig_new_product_specific_info', PACKAGE='iris')
  class(ans) <- "_p_product_specific_info"
  
  ans
  
}

attr(`product_specific_info`, 'returnType') = '_p_product_specific_info'
class(`product_specific_info`) = c("SWIGFunction", class('product_specific_info'))

# Start of delete_product_specific_info

`delete_product_specific_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_product_specific_info") 
  .Call('R_swig_delete_product_specific_info', self, PACKAGE='iris')
  
}

attr(`delete_product_specific_info`, 'returnType') = 'void'
attr(`delete_product_specific_info`, "inputTypes") = c('_p_product_specific_info')
class(`delete_product_specific_info`) = c("SWIGFunction", class('delete_product_specific_info'))

# Start of accessor method for product_specific_info
setMethod('$', '_p_product_specific_info', function(x, name)

{
  accessorFuns = list('beam' = product_specific_info_beam_get, 'cappi' = product_specific_info_cappi_get, 'Catch' = product_specific_info_Catch_get, 'comp' = product_specific_info_comp_get, 'cross' = product_specific_info_cross_get, 'Dwell' = product_specific_info_Dwell_get, 'fcast' = product_specific_info_fcast_get, 'Gage' = product_specific_info_Gage_get, 'max' = product_specific_info_max_get, 'ndop' = product_specific_info_ndop_get, 'ppi' = product_specific_info_ppi_get, 'rain' = product_specific_info_rain_get, 'raw' = product_specific_info_raw_get, 'rhi' = product_specific_info_rhi_get, 'rti' = product_specific_info_rti_get, 'shear' = product_specific_info_shear_get, 'sline' = product_specific_info_sline_get, 'Sri' = product_specific_info_Sri_get, 'tdwr' = product_specific_info_tdwr_get, 'top' = product_specific_info_top_get, 'track' = product_specific_info_track_get, 'user' = product_specific_info_user_get, 'vil' = product_specific_info_vil_get, 'vvp' = product_specific_info_vvp_get, 'warn' = product_specific_info_warn_get, 'wind' = product_specific_info_wind_get, 'ipad' = product_specific_info_ipad_get)
  vaccessors = c('beam', 'cappi', 'Catch', 'comp', 'cross', 'Dwell', 'fcast', 'Gage', 'max', 'ndop', 'ppi', 'rain', 'raw', 'rhi', 'rti', 'shear', 'sline', 'Sri', 'tdwr', 'top', 'track', 'user', 'vil', 'vvp', 'warn', 'wind', 'ipad')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for product_specific_info
# Start of accessor method for product_specific_info
setMethod('$<-', '_p_product_specific_info', function(x, name, value)

{
  accessorFuns = list('beam' = product_specific_info_beam_set, 'cappi' = product_specific_info_cappi_set, 'Catch' = product_specific_info_Catch_set, 'comp' = product_specific_info_comp_set, 'cross' = product_specific_info_cross_set, 'Dwell' = product_specific_info_Dwell_set, 'fcast' = product_specific_info_fcast_set, 'Gage' = product_specific_info_Gage_set, 'max' = product_specific_info_max_set, 'ndop' = product_specific_info_ndop_set, 'ppi' = product_specific_info_ppi_set, 'rain' = product_specific_info_rain_set, 'raw' = product_specific_info_raw_set, 'rhi' = product_specific_info_rhi_set, 'rti' = product_specific_info_rti_set, 'shear' = product_specific_info_shear_set, 'sline' = product_specific_info_sline_set, 'Sri' = product_specific_info_Sri_set, 'tdwr' = product_specific_info_tdwr_set, 'top' = product_specific_info_top_set, 'track' = product_specific_info_track_set, 'user' = product_specific_info_user_set, 'vil' = product_specific_info_vil_set, 'vvp' = product_specific_info_vvp_set, 'warn' = product_specific_info_warn_set, 'wind' = product_specific_info_wind_set, 'ipad' = product_specific_info_ipad_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_product_specific_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('beam' = product_specific_info_beam_set, 'cappi' = product_specific_info_cappi_set, 'Catch' = product_specific_info_Catch_set, 'comp' = product_specific_info_comp_set, 'cross' = product_specific_info_cross_set, 'Dwell' = product_specific_info_Dwell_set, 'fcast' = product_specific_info_fcast_set, 'Gage' = product_specific_info_Gage_set, 'max' = product_specific_info_max_set, 'ndop' = product_specific_info_ndop_set, 'ppi' = product_specific_info_ppi_set, 'rain' = product_specific_info_rain_set, 'raw' = product_specific_info_raw_set, 'rhi' = product_specific_info_rhi_set, 'rti' = product_specific_info_rti_set, 'shear' = product_specific_info_shear_set, 'sline' = product_specific_info_sline_set, 'Sri' = product_specific_info_Sri_set, 'tdwr' = product_specific_info_tdwr_set, 'top' = product_specific_info_top_set, 'track' = product_specific_info_track_set, 'user' = product_specific_info_user_set, 'vil' = product_specific_info_vil_set, 'vvp' = product_specific_info_vvp_set, 'warn' = product_specific_info_warn_set, 'wind' = product_specific_info_wind_set, 'ipad' = product_specific_info_ipad_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for product_specific_info
setMethod('delete', '_p_product_specific_info', function(obj) {delete_product_specific_info(obj)})
# Start of product_configuration_hdr_set

`product_configuration_hdr_set` = function(self, s_hdr)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_hdr = coerceIfNotSubclass(s_hdr, "_p_structure_header") 
  .Call('R_swig_product_configuration_hdr_set', self, s_hdr, PACKAGE='iris')
  
}

attr(`product_configuration_hdr_set`, 'returnType') = 'void'
attr(`product_configuration_hdr_set`, "inputTypes") = c('_p_product_configuration', '_p_structure_header')
class(`product_configuration_hdr_set`) = c("SWIGFunction", class('product_configuration_hdr_set'))

# Start of product_configuration_hdr_get

`product_configuration_hdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_hdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_structure_header"
  
  ans
  
}

attr(`product_configuration_hdr_get`, 'returnType') = '_p_structure_header'
attr(`product_configuration_hdr_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_hdr_get`) = c("SWIGFunction", class('product_configuration_hdr_get'))

# Start of product_configuration_iptype_set

`product_configuration_iptype_set` = function(self, s_iptype)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iptype = coerceIfNotSubclass(s_iptype, "_p_unsigned_short") 
  .Call('R_swig_product_configuration_iptype_set', self, s_iptype, PACKAGE='iris')
  
}

attr(`product_configuration_iptype_set`, 'returnType') = 'void'
attr(`product_configuration_iptype_set`, "inputTypes") = c('_p_product_configuration', '_p_unsigned_short')
class(`product_configuration_iptype_set`) = c("SWIGFunction", class('product_configuration_iptype_set'))

# Start of product_configuration_iptype_get

`product_configuration_iptype_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_iptype_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_configuration_iptype_get`, 'returnType') = '_p_unsigned_short'
attr(`product_configuration_iptype_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iptype_get`) = c("SWIGFunction", class('product_configuration_iptype_get'))

# Start of product_configuration_isch_set

`product_configuration_isch_set` = function(self, s_isch)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_isch = coerceIfNotSubclass(s_isch, "_p_unsigned_short") 
  .Call('R_swig_product_configuration_isch_set', self, s_isch, PACKAGE='iris')
  
}

attr(`product_configuration_isch_set`, 'returnType') = 'void'
attr(`product_configuration_isch_set`, "inputTypes") = c('_p_product_configuration', '_p_unsigned_short')
class(`product_configuration_isch_set`) = c("SWIGFunction", class('product_configuration_isch_set'))

# Start of product_configuration_isch_get

`product_configuration_isch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_isch_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_configuration_isch_get`, 'returnType') = '_p_unsigned_short'
attr(`product_configuration_isch_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_isch_get`) = c("SWIGFunction", class('product_configuration_isch_get'))

# Start of product_configuration_isch_skip_set

`product_configuration_isch_skip_set` = function(self, s_isch_skip)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_isch_skip = as.integer(s_isch_skip) 
  
  if(length(s_isch_skip) > 1) {
    Rf_warning("using only the first element of s_isch_skip")
  }
  
  .Call('R_swig_product_configuration_isch_skip_set', self, s_isch_skip, PACKAGE='iris')
  
}

attr(`product_configuration_isch_skip_set`, 'returnType') = 'void'
attr(`product_configuration_isch_skip_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_isch_skip_set`) = c("SWIGFunction", class('product_configuration_isch_skip_set'))

# Start of product_configuration_isch_skip_get

`product_configuration_isch_skip_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_isch_skip_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_isch_skip_get`, 'returnType') = 'numeric'
attr(`product_configuration_isch_skip_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_isch_skip_get`) = c("SWIGFunction", class('product_configuration_isch_skip_get'))

# Start of product_configuration_prod_time_set

`product_configuration_prod_time_set` = function(self, s_prod_time)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_prod_time = coerceIfNotSubclass(s_prod_time, "_p_ymds_time") 
  .Call('R_swig_product_configuration_prod_time_set', self, s_prod_time, PACKAGE='iris')
  
}

attr(`product_configuration_prod_time_set`, 'returnType') = 'void'
attr(`product_configuration_prod_time_set`, "inputTypes") = c('_p_product_configuration', '_p_ymds_time')
class(`product_configuration_prod_time_set`) = c("SWIGFunction", class('product_configuration_prod_time_set'))

# Start of product_configuration_prod_time_get

`product_configuration_prod_time_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_prod_time_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`product_configuration_prod_time_get`, 'returnType') = '_p_ymds_time'
attr(`product_configuration_prod_time_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_prod_time_get`) = c("SWIGFunction", class('product_configuration_prod_time_get'))

# Start of product_configuration_ing_time_set

`product_configuration_ing_time_set` = function(self, s_ing_time)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_ing_time = coerceIfNotSubclass(s_ing_time, "_p_ymds_time") 
  .Call('R_swig_product_configuration_ing_time_set', self, s_ing_time, PACKAGE='iris')
  
}

attr(`product_configuration_ing_time_set`, 'returnType') = 'void'
attr(`product_configuration_ing_time_set`, "inputTypes") = c('_p_product_configuration', '_p_ymds_time')
class(`product_configuration_ing_time_set`) = c("SWIGFunction", class('product_configuration_ing_time_set'))

# Start of product_configuration_ing_time_get

`product_configuration_ing_time_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_ing_time_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`product_configuration_ing_time_get`, 'returnType') = '_p_ymds_time'
attr(`product_configuration_ing_time_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ing_time_get`) = c("SWIGFunction", class('product_configuration_ing_time_get'))

# Start of product_configuration_epoch_set

`product_configuration_epoch_set` = function(self, s_epoch)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_epoch = coerceIfNotSubclass(s_epoch, "_p_ymds_time") 
  .Call('R_swig_product_configuration_epoch_set', self, s_epoch, PACKAGE='iris')
  
}

attr(`product_configuration_epoch_set`, 'returnType') = 'void'
attr(`product_configuration_epoch_set`, "inputTypes") = c('_p_product_configuration', '_p_ymds_time')
class(`product_configuration_epoch_set`) = c("SWIGFunction", class('product_configuration_epoch_set'))

# Start of product_configuration_epoch_get

`product_configuration_epoch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_epoch_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`product_configuration_epoch_get`, 'returnType') = '_p_ymds_time'
attr(`product_configuration_epoch_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_epoch_get`) = c("SWIGFunction", class('product_configuration_epoch_get'))

# Start of product_configuration_ipad56x6_set

`product_configuration_ipad56x6_set` = function(self, s_ipad56x6)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  
  if(is.list(s_ipad56x6))
  assert(all(sapply(s_ipad56x6, class) == "_p_char"))     
  
  
#  assert(length(s_ipad56x6) >= 6)
  
  .Call('R_swig_product_configuration_ipad56x6_set', self, s_ipad56x6, PACKAGE='iris')
  
}

attr(`product_configuration_ipad56x6_set`, 'returnType') = 'void'
attr(`product_configuration_ipad56x6_set`, "inputTypes") = c('_p_product_configuration', '_p_char')
class(`product_configuration_ipad56x6_set`) = c("SWIGFunction", class('product_configuration_ipad56x6_set'))

# Start of product_configuration_ipad56x6_get

`product_configuration_ipad56x6_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_ipad56x6_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_configuration_ipad56x6_get`, 'returnType') = '_p_char'
attr(`product_configuration_ipad56x6_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ipad56x6_get`) = c("SWIGFunction", class('product_configuration_ipad56x6_get'))

# Start of product_configuration_spname_set

`product_configuration_spname_set` = function(self, s_spname)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  
  if(is.list(s_spname))
  assert(all(sapply(s_spname, class) == "_p_char"))     
  
  
#  assert(length(s_spname) >= 12)
  
  .Call('R_swig_product_configuration_spname_set', self, s_spname, PACKAGE='iris')
  
}

attr(`product_configuration_spname_set`, 'returnType') = 'void'
attr(`product_configuration_spname_set`, "inputTypes") = c('_p_product_configuration', '_p_char')
class(`product_configuration_spname_set`) = c("SWIGFunction", class('product_configuration_spname_set'))

# Start of product_configuration_spname_get

`product_configuration_spname_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_spname_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_configuration_spname_get`, 'returnType') = '_p_char'
attr(`product_configuration_spname_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_spname_get`) = c("SWIGFunction", class('product_configuration_spname_get'))

# Start of product_configuration_stname_set

`product_configuration_stname_set` = function(self, s_stname)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  
  if(is.list(s_stname))
  assert(all(sapply(s_stname, class) == "_p_char"))     
  
  
#  assert(length(s_stname) >= 12)
  
  .Call('R_swig_product_configuration_stname_set', self, s_stname, PACKAGE='iris')
  
}

attr(`product_configuration_stname_set`, 'returnType') = 'void'
attr(`product_configuration_stname_set`, "inputTypes") = c('_p_product_configuration', '_p_char')
class(`product_configuration_stname_set`) = c("SWIGFunction", class('product_configuration_stname_set'))

# Start of product_configuration_stname_get

`product_configuration_stname_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_stname_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_configuration_stname_get`, 'returnType') = '_p_char'
attr(`product_configuration_stname_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_stname_get`) = c("SWIGFunction", class('product_configuration_stname_get'))

# Start of product_configuration_iflags_set

`product_configuration_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_unsigned_short") 
  .Call('R_swig_product_configuration_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`product_configuration_iflags_set`, 'returnType') = 'void'
attr(`product_configuration_iflags_set`, "inputTypes") = c('_p_product_configuration', '_p_unsigned_short')
class(`product_configuration_iflags_set`) = c("SWIGFunction", class('product_configuration_iflags_set'))

# Start of product_configuration_iflags_get

`product_configuration_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_configuration_iflags_get`, 'returnType') = '_p_unsigned_short'
attr(`product_configuration_iflags_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iflags_get`) = c("SWIGFunction", class('product_configuration_iflags_get'))

# Start of product_configuration_ixscale_set

`product_configuration_ixscale_set` = function(self, s_ixscale)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_ixscale = as.integer(s_ixscale) 
  
  if(length(s_ixscale) > 1) {
    Rf_warning("using only the first element of s_ixscale")
  }
  
  .Call('R_swig_product_configuration_ixscale_set', self, s_ixscale, PACKAGE='iris')
  
}

attr(`product_configuration_ixscale_set`, 'returnType') = 'void'
attr(`product_configuration_ixscale_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_ixscale_set`) = c("SWIGFunction", class('product_configuration_ixscale_set'))

# Start of product_configuration_ixscale_get

`product_configuration_ixscale_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_ixscale_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_ixscale_get`, 'returnType') = 'numeric'
attr(`product_configuration_ixscale_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ixscale_get`) = c("SWIGFunction", class('product_configuration_ixscale_get'))

# Start of product_configuration_iyscale_set

`product_configuration_iyscale_set` = function(self, s_iyscale)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iyscale = as.integer(s_iyscale) 
  
  if(length(s_iyscale) > 1) {
    Rf_warning("using only the first element of s_iyscale")
  }
  
  .Call('R_swig_product_configuration_iyscale_set', self, s_iyscale, PACKAGE='iris')
  
}

attr(`product_configuration_iyscale_set`, 'returnType') = 'void'
attr(`product_configuration_iyscale_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_iyscale_set`) = c("SWIGFunction", class('product_configuration_iyscale_set'))

# Start of product_configuration_iyscale_get

`product_configuration_iyscale_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_iyscale_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_iyscale_get`, 'returnType') = 'numeric'
attr(`product_configuration_iyscale_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iyscale_get`) = c("SWIGFunction", class('product_configuration_iyscale_get'))

# Start of product_configuration_izscale_set

`product_configuration_izscale_set` = function(self, s_izscale)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_izscale = as.integer(s_izscale) 
  
  if(length(s_izscale) > 1) {
    Rf_warning("using only the first element of s_izscale")
  }
  
  .Call('R_swig_product_configuration_izscale_set', self, s_izscale, PACKAGE='iris')
  
}

attr(`product_configuration_izscale_set`, 'returnType') = 'void'
attr(`product_configuration_izscale_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_izscale_set`) = c("SWIGFunction", class('product_configuration_izscale_set'))

# Start of product_configuration_izscale_get

`product_configuration_izscale_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_izscale_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_izscale_get`, 'returnType') = 'numeric'
attr(`product_configuration_izscale_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_izscale_get`) = c("SWIGFunction", class('product_configuration_izscale_get'))

# Start of product_configuration_ixsize_set

`product_configuration_ixsize_set` = function(self, s_ixsize)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_ixsize = as.integer(s_ixsize) 
  
  if(length(s_ixsize) > 1) {
    Rf_warning("using only the first element of s_ixsize")
  }
  
  .Call('R_swig_product_configuration_ixsize_set', self, s_ixsize, PACKAGE='iris')
  
}

attr(`product_configuration_ixsize_set`, 'returnType') = 'void'
attr(`product_configuration_ixsize_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_ixsize_set`) = c("SWIGFunction", class('product_configuration_ixsize_set'))

# Start of product_configuration_ixsize_get

`product_configuration_ixsize_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_ixsize_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_ixsize_get`, 'returnType') = 'numeric'
attr(`product_configuration_ixsize_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ixsize_get`) = c("SWIGFunction", class('product_configuration_ixsize_get'))

# Start of product_configuration_iysize_set

`product_configuration_iysize_set` = function(self, s_iysize)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iysize = as.integer(s_iysize) 
  
  if(length(s_iysize) > 1) {
    Rf_warning("using only the first element of s_iysize")
  }
  
  .Call('R_swig_product_configuration_iysize_set', self, s_iysize, PACKAGE='iris')
  
}

attr(`product_configuration_iysize_set`, 'returnType') = 'void'
attr(`product_configuration_iysize_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_iysize_set`) = c("SWIGFunction", class('product_configuration_iysize_set'))

# Start of product_configuration_iysize_get

`product_configuration_iysize_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_iysize_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_iysize_get`, 'returnType') = 'numeric'
attr(`product_configuration_iysize_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iysize_get`) = c("SWIGFunction", class('product_configuration_iysize_get'))

# Start of product_configuration_izsize_set

`product_configuration_izsize_set` = function(self, s_izsize)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_izsize = as.integer(s_izsize) 
  
  if(length(s_izsize) > 1) {
    Rf_warning("using only the first element of s_izsize")
  }
  
  .Call('R_swig_product_configuration_izsize_set', self, s_izsize, PACKAGE='iris')
  
}

attr(`product_configuration_izsize_set`, 'returnType') = 'void'
attr(`product_configuration_izsize_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_izsize_set`) = c("SWIGFunction", class('product_configuration_izsize_set'))

# Start of product_configuration_izsize_get

`product_configuration_izsize_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_izsize_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_izsize_get`, 'returnType') = 'numeric'
attr(`product_configuration_izsize_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_izsize_get`) = c("SWIGFunction", class('product_configuration_izsize_get'))

# Start of product_configuration_ixrad_set

`product_configuration_ixrad_set` = function(self, s_ixrad)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_ixrad = as.integer(s_ixrad) 
  
  if(length(s_ixrad) > 1) {
    Rf_warning("using only the first element of s_ixrad")
  }
  
  .Call('R_swig_product_configuration_ixrad_set', self, s_ixrad, PACKAGE='iris')
  
}

attr(`product_configuration_ixrad_set`, 'returnType') = 'void'
attr(`product_configuration_ixrad_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_ixrad_set`) = c("SWIGFunction", class('product_configuration_ixrad_set'))

# Start of product_configuration_ixrad_get

`product_configuration_ixrad_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_ixrad_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_ixrad_get`, 'returnType') = 'numeric'
attr(`product_configuration_ixrad_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ixrad_get`) = c("SWIGFunction", class('product_configuration_ixrad_get'))

# Start of product_configuration_iyrad_set

`product_configuration_iyrad_set` = function(self, s_iyrad)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iyrad = as.integer(s_iyrad) 
  
  if(length(s_iyrad) > 1) {
    Rf_warning("using only the first element of s_iyrad")
  }
  
  .Call('R_swig_product_configuration_iyrad_set', self, s_iyrad, PACKAGE='iris')
  
}

attr(`product_configuration_iyrad_set`, 'returnType') = 'void'
attr(`product_configuration_iyrad_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_iyrad_set`) = c("SWIGFunction", class('product_configuration_iyrad_set'))

# Start of product_configuration_iyrad_get

`product_configuration_iyrad_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_iyrad_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_iyrad_get`, 'returnType') = 'numeric'
attr(`product_configuration_iyrad_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iyrad_get`) = c("SWIGFunction", class('product_configuration_iyrad_get'))

# Start of product_configuration_izrad_set

`product_configuration_izrad_set` = function(self, s_izrad)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_izrad = as.integer(s_izrad) 
  
  if(length(s_izrad) > 1) {
    Rf_warning("using only the first element of s_izrad")
  }
  
  .Call('R_swig_product_configuration_izrad_set', self, s_izrad, PACKAGE='iris')
  
}

attr(`product_configuration_izrad_set`, 'returnType') = 'void'
attr(`product_configuration_izrad_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_izrad_set`) = c("SWIGFunction", class('product_configuration_izrad_set'))

# Start of product_configuration_izrad_get

`product_configuration_izrad_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_izrad_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_izrad_get`, 'returnType') = 'numeric'
attr(`product_configuration_izrad_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_izrad_get`) = c("SWIGFunction", class('product_configuration_izrad_get'))

# Start of product_configuration_irange_last_v20_set

`product_configuration_irange_last_v20_set` = function(self, s_irange_last_v20)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_irange_last_v20 = as.integer(s_irange_last_v20) 
  
  if(length(s_irange_last_v20) > 1) {
    Rf_warning("using only the first element of s_irange_last_v20")
  }
  
  .Call('R_swig_product_configuration_irange_last_v20_set', self, s_irange_last_v20, PACKAGE='iris')
  
}

attr(`product_configuration_irange_last_v20_set`, 'returnType') = 'void'
attr(`product_configuration_irange_last_v20_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_irange_last_v20_set`) = c("SWIGFunction", class('product_configuration_irange_last_v20_set'))

# Start of product_configuration_irange_last_v20_get

`product_configuration_irange_last_v20_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_irange_last_v20_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_irange_last_v20_get`, 'returnType') = 'numeric'
attr(`product_configuration_irange_last_v20_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_irange_last_v20_get`) = c("SWIGFunction", class('product_configuration_irange_last_v20_get'))

# Start of product_configuration_ipad128x2_set

`product_configuration_ipad128x2_set` = function(self, s_ipad128x2)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  
  if(is.list(s_ipad128x2))
  assert(all(sapply(s_ipad128x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad128x2) >= 2)
  
  .Call('R_swig_product_configuration_ipad128x2_set', self, s_ipad128x2, PACKAGE='iris')
  
}

attr(`product_configuration_ipad128x2_set`, 'returnType') = 'void'
attr(`product_configuration_ipad128x2_set`, "inputTypes") = c('_p_product_configuration', '_p_char')
class(`product_configuration_ipad128x2_set`) = c("SWIGFunction", class('product_configuration_ipad128x2_set'))

# Start of product_configuration_ipad128x2_get

`product_configuration_ipad128x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_ipad128x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_configuration_ipad128x2_get`, 'returnType') = '_p_char'
attr(`product_configuration_ipad128x2_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ipad128x2_get`) = c("SWIGFunction", class('product_configuration_ipad128x2_get'))

# Start of product_configuration_idata_out_set

`product_configuration_idata_out_set` = function(self, s_idata_out)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_idata_out = coerceIfNotSubclass(s_idata_out, "_p_unsigned_short") 
  .Call('R_swig_product_configuration_idata_out_set', self, s_idata_out, PACKAGE='iris')
  
}

attr(`product_configuration_idata_out_set`, 'returnType') = 'void'
attr(`product_configuration_idata_out_set`, "inputTypes") = c('_p_product_configuration', '_p_unsigned_short')
class(`product_configuration_idata_out_set`) = c("SWIGFunction", class('product_configuration_idata_out_set'))

# Start of product_configuration_idata_out_get

`product_configuration_idata_out_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_idata_out_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_configuration_idata_out_get`, 'returnType') = '_p_unsigned_short'
attr(`product_configuration_idata_out_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_idata_out_get`) = c("SWIGFunction", class('product_configuration_idata_out_get'))

# Start of product_configuration_sprojection_name_set

`product_configuration_sprojection_name_set` = function(self, s_sprojection_name)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  
  if(is.list(s_sprojection_name))
  assert(all(sapply(s_sprojection_name, class) == "_p_char"))     
  
  
#  assert(length(s_sprojection_name) >= 12)
  
  .Call('R_swig_product_configuration_sprojection_name_set', self, s_sprojection_name, PACKAGE='iris')
  
}

attr(`product_configuration_sprojection_name_set`, 'returnType') = 'void'
attr(`product_configuration_sprojection_name_set`, "inputTypes") = c('_p_product_configuration', '_p_char')
class(`product_configuration_sprojection_name_set`) = c("SWIGFunction", class('product_configuration_sprojection_name_set'))

# Start of product_configuration_sprojection_name_get

`product_configuration_sprojection_name_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_sprojection_name_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_configuration_sprojection_name_get`, 'returnType') = '_p_char'
attr(`product_configuration_sprojection_name_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_sprojection_name_get`) = c("SWIGFunction", class('product_configuration_sprojection_name_get'))

# Start of product_configuration_idata_in_set

`product_configuration_idata_in_set` = function(self, s_idata_in)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_idata_in = coerceIfNotSubclass(s_idata_in, "_p_unsigned_short") 
  .Call('R_swig_product_configuration_idata_in_set', self, s_idata_in, PACKAGE='iris')
  
}

attr(`product_configuration_idata_in_set`, 'returnType') = 'void'
attr(`product_configuration_idata_in_set`, "inputTypes") = c('_p_product_configuration', '_p_unsigned_short')
class(`product_configuration_idata_in_set`) = c("SWIGFunction", class('product_configuration_idata_in_set'))

# Start of product_configuration_idata_in_get

`product_configuration_idata_in_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_idata_in_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_configuration_idata_in_get`, 'returnType') = '_p_unsigned_short'
attr(`product_configuration_idata_in_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_idata_in_get`) = c("SWIGFunction", class('product_configuration_idata_in_get'))

# Start of product_configuration_iprojection_type_set

`product_configuration_iprojection_type_set` = function(self, s_iprojection_type)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iprojection_type = coerceIfNotSubclass(s_iprojection_type, "_p_unsigned_char") 
  .Call('R_swig_product_configuration_iprojection_type_set', self, s_iprojection_type, PACKAGE='iris')
  
}

attr(`product_configuration_iprojection_type_set`, 'returnType') = 'void'
attr(`product_configuration_iprojection_type_set`, "inputTypes") = c('_p_product_configuration', '_p_unsigned_char')
class(`product_configuration_iprojection_type_set`) = c("SWIGFunction", class('product_configuration_iprojection_type_set'))

# Start of product_configuration_iprojection_type_get

`product_configuration_iprojection_type_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_iprojection_type_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`product_configuration_iprojection_type_get`, 'returnType') = '_p_unsigned_char'
attr(`product_configuration_iprojection_type_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iprojection_type_get`) = c("SWIGFunction", class('product_configuration_iprojection_type_get'))

# Start of product_configuration_ipad147x1_set

`product_configuration_ipad147x1_set` = function(self, s_ipad147x1)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_ipad147x1 = as(s_ipad147x1, "character");     
  .Call('R_swig_product_configuration_ipad147x1_set', self, s_ipad147x1, PACKAGE='iris')
  
}

attr(`product_configuration_ipad147x1_set`, 'returnType') = 'void'
attr(`product_configuration_ipad147x1_set`, "inputTypes") = c('_p_product_configuration', 'character')
class(`product_configuration_ipad147x1_set`) = c("SWIGFunction", class('product_configuration_ipad147x1_set'))

# Start of product_configuration_ipad147x1_get

`product_configuration_ipad147x1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_ipad147x1_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_ipad147x1_get`, 'returnType') = 'character'
attr(`product_configuration_ipad147x1_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ipad147x1_get`) = c("SWIGFunction", class('product_configuration_ipad147x1_get'))

# Start of product_configuration_iradial_smooth_set

`product_configuration_iradial_smooth_set` = function(self, s_iradial_smooth)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iradial_smooth = coerceIfNotSubclass(s_iradial_smooth, "_p_short") 
  .Call('R_swig_product_configuration_iradial_smooth_set', self, s_iradial_smooth, PACKAGE='iris')
  
}

attr(`product_configuration_iradial_smooth_set`, 'returnType') = 'void'
attr(`product_configuration_iradial_smooth_set`, "inputTypes") = c('_p_product_configuration', '_p_short')
class(`product_configuration_iradial_smooth_set`) = c("SWIGFunction", class('product_configuration_iradial_smooth_set'))

# Start of product_configuration_iradial_smooth_get

`product_configuration_iradial_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_iradial_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_configuration_iradial_smooth_get`, 'returnType') = '_p_short'
attr(`product_configuration_iradial_smooth_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iradial_smooth_get`) = c("SWIGFunction", class('product_configuration_iradial_smooth_get'))

# Start of product_configuration_iruns_set

`product_configuration_iruns_set` = function(self, s_iruns)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iruns = coerceIfNotSubclass(s_iruns, "_p_unsigned_short") 
  .Call('R_swig_product_configuration_iruns_set', self, s_iruns, PACKAGE='iris')
  
}

attr(`product_configuration_iruns_set`, 'returnType') = 'void'
attr(`product_configuration_iruns_set`, "inputTypes") = c('_p_product_configuration', '_p_unsigned_short')
class(`product_configuration_iruns_set`) = c("SWIGFunction", class('product_configuration_iruns_set'))

# Start of product_configuration_iruns_get

`product_configuration_iruns_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_iruns_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_configuration_iruns_get`, 'returnType') = '_p_unsigned_short'
attr(`product_configuration_iruns_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iruns_get`) = c("SWIGFunction", class('product_configuration_iruns_get'))

# Start of product_configuration_izr_const_set

`product_configuration_izr_const_set` = function(self, s_izr_const)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_izr_const = as.integer(s_izr_const) 
  
  if(length(s_izr_const) > 1) {
    Rf_warning("using only the first element of s_izr_const")
  }
  
  .Call('R_swig_product_configuration_izr_const_set', self, s_izr_const, PACKAGE='iris')
  
}

attr(`product_configuration_izr_const_set`, 'returnType') = 'void'
attr(`product_configuration_izr_const_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_izr_const_set`) = c("SWIGFunction", class('product_configuration_izr_const_set'))

# Start of product_configuration_izr_const_get

`product_configuration_izr_const_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_izr_const_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_izr_const_get`, 'returnType') = 'numeric'
attr(`product_configuration_izr_const_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_izr_const_get`) = c("SWIGFunction", class('product_configuration_izr_const_get'))

# Start of product_configuration_izr_exp_set

`product_configuration_izr_exp_set` = function(self, s_izr_exp)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_izr_exp = as.integer(s_izr_exp) 
  
  if(length(s_izr_exp) > 1) {
    Rf_warning("using only the first element of s_izr_exp")
  }
  
  .Call('R_swig_product_configuration_izr_exp_set', self, s_izr_exp, PACKAGE='iris')
  
}

attr(`product_configuration_izr_exp_set`, 'returnType') = 'void'
attr(`product_configuration_izr_exp_set`, "inputTypes") = c('_p_product_configuration', 'numeric')
class(`product_configuration_izr_exp_set`) = c("SWIGFunction", class('product_configuration_izr_exp_set'))

# Start of product_configuration_izr_exp_get

`product_configuration_izr_exp_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_product_configuration_izr_exp_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_configuration_izr_exp_get`, 'returnType') = 'numeric'
attr(`product_configuration_izr_exp_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_izr_exp_get`) = c("SWIGFunction", class('product_configuration_izr_exp_get'))

# Start of product_configuration_ix_smooth_set

`product_configuration_ix_smooth_set` = function(self, s_ix_smooth)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_ix_smooth = coerceIfNotSubclass(s_ix_smooth, "_p_short") 
  .Call('R_swig_product_configuration_ix_smooth_set', self, s_ix_smooth, PACKAGE='iris')
  
}

attr(`product_configuration_ix_smooth_set`, 'returnType') = 'void'
attr(`product_configuration_ix_smooth_set`, "inputTypes") = c('_p_product_configuration', '_p_short')
class(`product_configuration_ix_smooth_set`) = c("SWIGFunction", class('product_configuration_ix_smooth_set'))

# Start of product_configuration_ix_smooth_get

`product_configuration_ix_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_ix_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_configuration_ix_smooth_get`, 'returnType') = '_p_short'
attr(`product_configuration_ix_smooth_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ix_smooth_get`) = c("SWIGFunction", class('product_configuration_ix_smooth_get'))

# Start of product_configuration_iy_smooth_set

`product_configuration_iy_smooth_set` = function(self, s_iy_smooth)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_iy_smooth = coerceIfNotSubclass(s_iy_smooth, "_p_short") 
  .Call('R_swig_product_configuration_iy_smooth_set', self, s_iy_smooth, PACKAGE='iris')
  
}

attr(`product_configuration_iy_smooth_set`, 'returnType') = 'void'
attr(`product_configuration_iy_smooth_set`, "inputTypes") = c('_p_product_configuration', '_p_short')
class(`product_configuration_iy_smooth_set`) = c("SWIGFunction", class('product_configuration_iy_smooth_set'))

# Start of product_configuration_iy_smooth_get

`product_configuration_iy_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_iy_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_configuration_iy_smooth_get`, 'returnType') = '_p_short'
attr(`product_configuration_iy_smooth_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_iy_smooth_get`) = c("SWIGFunction", class('product_configuration_iy_smooth_get'))

# Start of product_configuration_psi_set

`product_configuration_psi_set` = function(self, s_psi)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_psi = coerceIfNotSubclass(s_psi, "_p_product_specific_info") 
  .Call('R_swig_product_configuration_psi_set', self, s_psi, PACKAGE='iris')
  
}

attr(`product_configuration_psi_set`, 'returnType') = 'void'
attr(`product_configuration_psi_set`, "inputTypes") = c('_p_product_configuration', '_p_product_specific_info')
class(`product_configuration_psi_set`) = c("SWIGFunction", class('product_configuration_psi_set'))

# Start of product_configuration_psi_get

`product_configuration_psi_get` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_psi_get', self, PACKAGE='iris')
  class(ans) <- "_p_product_specific_info"
  
  ans
  
}

attr(`product_configuration_psi_get`, 'returnType') = '_p_product_specific_info'
attr(`product_configuration_psi_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_psi_get`) = c("SWIGFunction", class('product_configuration_psi_get'))

# Start of product_configuration_sTaskMinorList_set

`product_configuration_sTaskMinorList_set` = function(self, s_sTaskMinorList)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  
  if(is.list(s_sTaskMinorList))
  assert(all(sapply(s_sTaskMinorList, class) == "_p_char"))     
  
  
#  assert(length(s_sTaskMinorList) >= (16))
  
  .Call('R_swig_product_configuration_sTaskMinorList_set', self, s_sTaskMinorList, PACKAGE='iris')
  
}

attr(`product_configuration_sTaskMinorList_set`, 'returnType') = 'void'
attr(`product_configuration_sTaskMinorList_set`, "inputTypes") = c('_p_product_configuration', '_p_char')
class(`product_configuration_sTaskMinorList_set`) = c("SWIGFunction", class('product_configuration_sTaskMinorList_set'))

# Start of product_configuration_sTaskMinorList_get

`product_configuration_sTaskMinorList_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_sTaskMinorList_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_configuration_sTaskMinorList_get`, 'returnType') = '_p_char'
attr(`product_configuration_sTaskMinorList_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_sTaskMinorList_get`) = c("SWIGFunction", class('product_configuration_sTaskMinorList_get'))

# Start of product_configuration_ipad260x12_set

`product_configuration_ipad260x12_set` = function(self, s_ipad260x12)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  
  if(is.list(s_ipad260x12))
  assert(all(sapply(s_ipad260x12, class) == "_p_char"))     
  
  
#  assert(length(s_ipad260x12) >= 12)
  
  .Call('R_swig_product_configuration_ipad260x12_set', self, s_ipad260x12, PACKAGE='iris')
  
}

attr(`product_configuration_ipad260x12_set`, 'returnType') = 'void'
attr(`product_configuration_ipad260x12_set`, "inputTypes") = c('_p_product_configuration', '_p_char')
class(`product_configuration_ipad260x12_set`) = c("SWIGFunction", class('product_configuration_ipad260x12_set'))

# Start of product_configuration_ipad260x12_get

`product_configuration_ipad260x12_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_ipad260x12_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_configuration_ipad260x12_get`, 'returnType') = '_p_char'
attr(`product_configuration_ipad260x12_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_ipad260x12_get`) = c("SWIGFunction", class('product_configuration_ipad260x12_get'))

# Start of product_configuration_colors_set

`product_configuration_colors_set` = function(self, s_colors)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  s_colors = coerceIfNotSubclass(s_colors, "_p_color_scale_def") 
  .Call('R_swig_product_configuration_colors_set', self, s_colors, PACKAGE='iris')
  
}

attr(`product_configuration_colors_set`, 'returnType') = 'void'
attr(`product_configuration_colors_set`, "inputTypes") = c('_p_product_configuration', '_p_color_scale_def')
class(`product_configuration_colors_set`) = c("SWIGFunction", class('product_configuration_colors_set'))

# Start of product_configuration_colors_get

`product_configuration_colors_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  ans = .Call('R_swig_product_configuration_colors_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_color_scale_def"
  
  ans
  
}

attr(`product_configuration_colors_get`, 'returnType') = '_p_color_scale_def'
attr(`product_configuration_colors_get`, "inputTypes") = c('_p_product_configuration')
class(`product_configuration_colors_get`) = c("SWIGFunction", class('product_configuration_colors_get'))

# Start of new_product_configuration

`product_configuration` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_product_configuration', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_product_configuration"
  
  ans
  
}

attr(`product_configuration`, 'returnType') = '_p_product_configuration'
class(`product_configuration`) = c("SWIGFunction", class('product_configuration'))

# Start of delete_product_configuration

`delete_product_configuration` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_product_configuration") 
  .Call('R_swig_delete_product_configuration', self, PACKAGE='iris')
  
}

attr(`delete_product_configuration`, 'returnType') = 'void'
attr(`delete_product_configuration`, "inputTypes") = c('_p_product_configuration')
class(`delete_product_configuration`) = c("SWIGFunction", class('delete_product_configuration'))

# Start of accessor method for product_configuration
setMethod('$', '_p_product_configuration', function(x, name)

{
  accessorFuns = list('hdr' = product_configuration_hdr_get, 'iptype' = product_configuration_iptype_get, 'isch' = product_configuration_isch_get, 'isch_skip' = product_configuration_isch_skip_get, 'prod_time' = product_configuration_prod_time_get, 'ing_time' = product_configuration_ing_time_get, 'epoch' = product_configuration_epoch_get, 'ipad56x6' = product_configuration_ipad56x6_get, 'spname' = product_configuration_spname_get, 'stname' = product_configuration_stname_get, 'iflags' = product_configuration_iflags_get, 'ixscale' = product_configuration_ixscale_get, 'iyscale' = product_configuration_iyscale_get, 'izscale' = product_configuration_izscale_get, 'ixsize' = product_configuration_ixsize_get, 'iysize' = product_configuration_iysize_get, 'izsize' = product_configuration_izsize_get, 'ixrad' = product_configuration_ixrad_get, 'iyrad' = product_configuration_iyrad_get, 'izrad' = product_configuration_izrad_get, 'irange_last_v20' = product_configuration_irange_last_v20_get, 'ipad128x2' = product_configuration_ipad128x2_get, 'idata_out' = product_configuration_idata_out_get, 'sprojection_name' = product_configuration_sprojection_name_get, 'idata_in' = product_configuration_idata_in_get, 'iprojection_type' = product_configuration_iprojection_type_get, 'ipad147x1' = product_configuration_ipad147x1_get, 'iradial_smooth' = product_configuration_iradial_smooth_get, 'iruns' = product_configuration_iruns_get, 'izr_const' = product_configuration_izr_const_get, 'izr_exp' = product_configuration_izr_exp_get, 'ix_smooth' = product_configuration_ix_smooth_get, 'iy_smooth' = product_configuration_iy_smooth_get, 'psi' = product_configuration_psi_get, 'sTaskMinorList' = product_configuration_sTaskMinorList_get, 'ipad260x12' = product_configuration_ipad260x12_get, 'colors' = product_configuration_colors_get)
  vaccessors = c('hdr', 'iptype', 'isch', 'isch_skip', 'prod_time', 'ing_time', 'epoch', 'ipad56x6', 'spname', 'stname', 'iflags', 'ixscale', 'iyscale', 'izscale', 'ixsize', 'iysize', 'izsize', 'ixrad', 'iyrad', 'izrad', 'irange_last_v20', 'ipad128x2', 'idata_out', 'sprojection_name', 'idata_in', 'iprojection_type', 'ipad147x1', 'iradial_smooth', 'iruns', 'izr_const', 'izr_exp', 'ix_smooth', 'iy_smooth', 'psi', 'sTaskMinorList', 'ipad260x12', 'colors')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for product_configuration
# Start of accessor method for product_configuration
setMethod('$<-', '_p_product_configuration', function(x, name, value)

{
  accessorFuns = list('hdr' = product_configuration_hdr_set, 'iptype' = product_configuration_iptype_set, 'isch' = product_configuration_isch_set, 'isch_skip' = product_configuration_isch_skip_set, 'prod_time' = product_configuration_prod_time_set, 'ing_time' = product_configuration_ing_time_set, 'epoch' = product_configuration_epoch_set, 'ipad56x6' = product_configuration_ipad56x6_set, 'spname' = product_configuration_spname_set, 'stname' = product_configuration_stname_set, 'iflags' = product_configuration_iflags_set, 'ixscale' = product_configuration_ixscale_set, 'iyscale' = product_configuration_iyscale_set, 'izscale' = product_configuration_izscale_set, 'ixsize' = product_configuration_ixsize_set, 'iysize' = product_configuration_iysize_set, 'izsize' = product_configuration_izsize_set, 'ixrad' = product_configuration_ixrad_set, 'iyrad' = product_configuration_iyrad_set, 'izrad' = product_configuration_izrad_set, 'irange_last_v20' = product_configuration_irange_last_v20_set, 'ipad128x2' = product_configuration_ipad128x2_set, 'idata_out' = product_configuration_idata_out_set, 'sprojection_name' = product_configuration_sprojection_name_set, 'idata_in' = product_configuration_idata_in_set, 'iprojection_type' = product_configuration_iprojection_type_set, 'ipad147x1' = product_configuration_ipad147x1_set, 'iradial_smooth' = product_configuration_iradial_smooth_set, 'iruns' = product_configuration_iruns_set, 'izr_const' = product_configuration_izr_const_set, 'izr_exp' = product_configuration_izr_exp_set, 'ix_smooth' = product_configuration_ix_smooth_set, 'iy_smooth' = product_configuration_iy_smooth_set, 'psi' = product_configuration_psi_set, 'sTaskMinorList' = product_configuration_sTaskMinorList_set, 'ipad260x12' = product_configuration_ipad260x12_set, 'colors' = product_configuration_colors_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_product_configuration', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('hdr' = product_configuration_hdr_set, 'iptype' = product_configuration_iptype_set, 'isch' = product_configuration_isch_set, 'isch_skip' = product_configuration_isch_skip_set, 'prod_time' = product_configuration_prod_time_set, 'ing_time' = product_configuration_ing_time_set, 'epoch' = product_configuration_epoch_set, 'ipad56x6' = product_configuration_ipad56x6_set, 'spname' = product_configuration_spname_set, 'stname' = product_configuration_stname_set, 'iflags' = product_configuration_iflags_set, 'ixscale' = product_configuration_ixscale_set, 'iyscale' = product_configuration_iyscale_set, 'izscale' = product_configuration_izscale_set, 'ixsize' = product_configuration_ixsize_set, 'iysize' = product_configuration_iysize_set, 'izsize' = product_configuration_izsize_set, 'ixrad' = product_configuration_ixrad_set, 'iyrad' = product_configuration_iyrad_set, 'izrad' = product_configuration_izrad_set, 'irange_last_v20' = product_configuration_irange_last_v20_set, 'ipad128x2' = product_configuration_ipad128x2_set, 'idata_out' = product_configuration_idata_out_set, 'sprojection_name' = product_configuration_sprojection_name_set, 'idata_in' = product_configuration_idata_in_set, 'iprojection_type' = product_configuration_iprojection_type_set, 'ipad147x1' = product_configuration_ipad147x1_set, 'iradial_smooth' = product_configuration_iradial_smooth_set, 'iruns' = product_configuration_iruns_set, 'izr_const' = product_configuration_izr_const_set, 'izr_exp' = product_configuration_izr_exp_set, 'ix_smooth' = product_configuration_ix_smooth_set, 'iy_smooth' = product_configuration_iy_smooth_set, 'psi' = product_configuration_psi_set, 'sTaskMinorList' = product_configuration_sTaskMinorList_set, 'ipad260x12' = product_configuration_ipad260x12_set, 'colors' = product_configuration_colors_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for product_configuration
setMethod('delete', '_p_product_configuration', function(obj) {delete_product_configuration(obj)})
# Start definition of copy functions & methods for product_configuration
CopyToR_product_configuration = function(value, obj = new("product_configuration"))
{
  obj@isch_skip = value$isch_skip
  obj@ipad56x6 = value$ipad56x6
  obj@spname = value$spname
  obj@stname = value$stname
  obj@ixscale = value$ixscale
  obj@iyscale = value$iyscale
  obj@izscale = value$izscale
  obj@ixsize = value$ixsize
  obj@iysize = value$iysize
  obj@izsize = value$izsize
  obj@ixrad = value$ixrad
  obj@iyrad = value$iyrad
  obj@izrad = value$izrad
  obj@irange_last_v20 = value$irange_last_v20
  obj@ipad128x2 = value$ipad128x2
  obj@sprojection_name = value$sprojection_name
  obj@ipad147x1 = value$ipad147x1
  obj@izr_const = value$izr_const
  obj@izr_exp = value$izr_exp
  obj@sTaskMinorList = value$sTaskMinorList
  obj@ipad260x12 = value$ipad260x12
  obj
}



CopyToC_product_configuration = function(value, obj)
{
  obj$isch_skip = value@isch_skip
  obj$ipad56x6 = value@ipad56x6
  obj$spname = value@spname
  obj$stname = value@stname
  obj$ixscale = value@ixscale
  obj$iyscale = value@iyscale
  obj$izscale = value@izscale
  obj$ixsize = value@ixsize
  obj$iysize = value@iysize
  obj$izsize = value@izsize
  obj$ixrad = value@ixrad
  obj$iyrad = value@iyrad
  obj$izrad = value@izrad
  obj$irange_last_v20 = value@irange_last_v20
  obj$ipad128x2 = value@ipad128x2
  obj$sprojection_name = value@sprojection_name
  obj$ipad147x1 = value@ipad147x1
  obj$izr_const = value@izr_const
  obj$izr_exp = value@izr_exp
  obj$sTaskMinorList = value@sTaskMinorList
  obj$ipad260x12 = value@ipad260x12
  obj
}



# Start definition of copy methods for product_configuration
setMethod('copyToR', '_p_product_configuration', CopyToR_product_configuration)
setMethod('copyToC', 'product_configuration', CopyToC_product_configuration)

# End definition of copy methods for product_configuration
# End definition of copy functions & methods for product_configuration
# Start of task_rhi_scan_info_istartel_set

`task_rhi_scan_info_istartel_set` = function(self, s_istartel)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  s_istartel = coerceIfNotSubclass(s_istartel, "_p_unsigned_short") 
  .Call('R_swig_task_rhi_scan_info_istartel_set', self, s_istartel, PACKAGE='iris')
  
}

attr(`task_rhi_scan_info_istartel_set`, 'returnType') = 'void'
attr(`task_rhi_scan_info_istartel_set`, "inputTypes") = c('_p_task_rhi_scan_info', '_p_unsigned_short')
class(`task_rhi_scan_info_istartel_set`) = c("SWIGFunction", class('task_rhi_scan_info_istartel_set'))

# Start of task_rhi_scan_info_istartel_get

`task_rhi_scan_info_istartel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  ans = .Call('R_swig_task_rhi_scan_info_istartel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_rhi_scan_info_istartel_get`, 'returnType') = '_p_unsigned_short'
attr(`task_rhi_scan_info_istartel_get`, "inputTypes") = c('_p_task_rhi_scan_info')
class(`task_rhi_scan_info_istartel_get`) = c("SWIGFunction", class('task_rhi_scan_info_istartel_get'))

# Start of task_rhi_scan_info_iendel_set

`task_rhi_scan_info_iendel_set` = function(self, s_iendel)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  s_iendel = coerceIfNotSubclass(s_iendel, "_p_unsigned_short") 
  .Call('R_swig_task_rhi_scan_info_iendel_set', self, s_iendel, PACKAGE='iris')
  
}

attr(`task_rhi_scan_info_iendel_set`, 'returnType') = 'void'
attr(`task_rhi_scan_info_iendel_set`, "inputTypes") = c('_p_task_rhi_scan_info', '_p_unsigned_short')
class(`task_rhi_scan_info_iendel_set`) = c("SWIGFunction", class('task_rhi_scan_info_iendel_set'))

# Start of task_rhi_scan_info_iendel_get

`task_rhi_scan_info_iendel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  ans = .Call('R_swig_task_rhi_scan_info_iendel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_rhi_scan_info_iendel_get`, 'returnType') = '_p_unsigned_short'
attr(`task_rhi_scan_info_iendel_get`, "inputTypes") = c('_p_task_rhi_scan_info')
class(`task_rhi_scan_info_iendel_get`) = c("SWIGFunction", class('task_rhi_scan_info_iendel_get'))

# Start of task_rhi_scan_info_iazlst_set

`task_rhi_scan_info_iazlst_set` = function(self, s_iazlst)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  
  if(is.list(s_iazlst))
  assert(all(sapply(s_iazlst, class) == "_p_unsigned_short"))     
  
  
#  assert(length(s_iazlst) >= (40))
  
  .Call('R_swig_task_rhi_scan_info_iazlst_set', self, s_iazlst, PACKAGE='iris')
  
}

attr(`task_rhi_scan_info_iazlst_set`, 'returnType') = 'void'
attr(`task_rhi_scan_info_iazlst_set`, "inputTypes") = c('_p_task_rhi_scan_info', '_p_unsigned_short')
class(`task_rhi_scan_info_iazlst_set`) = c("SWIGFunction", class('task_rhi_scan_info_iazlst_set'))

# Start of task_rhi_scan_info_iazlst_get

`task_rhi_scan_info_iazlst_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  ans = .Call('R_swig_task_rhi_scan_info_iazlst_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_rhi_scan_info_iazlst_get`, 'returnType') = '_p_unsigned_short'
attr(`task_rhi_scan_info_iazlst_get`, "inputTypes") = c('_p_task_rhi_scan_info')
class(`task_rhi_scan_info_iazlst_get`) = c("SWIGFunction", class('task_rhi_scan_info_iazlst_get'))

# Start of task_rhi_scan_info_ipad_end_set

`task_rhi_scan_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (115))
  
  .Call('R_swig_task_rhi_scan_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_rhi_scan_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_rhi_scan_info_ipad_end_set`, "inputTypes") = c('_p_task_rhi_scan_info', '_p_char')
class(`task_rhi_scan_info_ipad_end_set`) = c("SWIGFunction", class('task_rhi_scan_info_ipad_end_set'))

# Start of task_rhi_scan_info_ipad_end_get

`task_rhi_scan_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  ans = .Call('R_swig_task_rhi_scan_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_rhi_scan_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_rhi_scan_info_ipad_end_get`, "inputTypes") = c('_p_task_rhi_scan_info')
class(`task_rhi_scan_info_ipad_end_get`) = c("SWIGFunction", class('task_rhi_scan_info_ipad_end_get'))

# Start of task_rhi_scan_info_iStartEnd_set

`task_rhi_scan_info_iStartEnd_set` = function(self, s_iStartEnd)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  s_iStartEnd = coerceIfNotSubclass(s_iStartEnd, "_p_unsigned_char") 
  .Call('R_swig_task_rhi_scan_info_iStartEnd_set', self, s_iStartEnd, PACKAGE='iris')
  
}

attr(`task_rhi_scan_info_iStartEnd_set`, 'returnType') = 'void'
attr(`task_rhi_scan_info_iStartEnd_set`, "inputTypes") = c('_p_task_rhi_scan_info', '_p_unsigned_char')
class(`task_rhi_scan_info_iStartEnd_set`) = c("SWIGFunction", class('task_rhi_scan_info_iStartEnd_set'))

# Start of task_rhi_scan_info_iStartEnd_get

`task_rhi_scan_info_iStartEnd_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  ans = .Call('R_swig_task_rhi_scan_info_iStartEnd_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`task_rhi_scan_info_iStartEnd_get`, 'returnType') = '_p_unsigned_char'
attr(`task_rhi_scan_info_iStartEnd_get`, "inputTypes") = c('_p_task_rhi_scan_info')
class(`task_rhi_scan_info_iStartEnd_get`) = c("SWIGFunction", class('task_rhi_scan_info_iStartEnd_get'))

# Start of new_task_rhi_scan_info

`task_rhi_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_rhi_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_rhi_scan_info"
  
  ans
  
}

attr(`task_rhi_scan_info`, 'returnType') = '_p_task_rhi_scan_info'
class(`task_rhi_scan_info`) = c("SWIGFunction", class('task_rhi_scan_info'))

# Start of delete_task_rhi_scan_info

`delete_task_rhi_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_rhi_scan_info") 
  .Call('R_swig_delete_task_rhi_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_task_rhi_scan_info`, 'returnType') = 'void'
attr(`delete_task_rhi_scan_info`, "inputTypes") = c('_p_task_rhi_scan_info')
class(`delete_task_rhi_scan_info`) = c("SWIGFunction", class('delete_task_rhi_scan_info'))

# Start of accessor method for task_rhi_scan_info
setMethod('$', '_p_task_rhi_scan_info', function(x, name)

{
  accessorFuns = list('istartel' = task_rhi_scan_info_istartel_get, 'iendel' = task_rhi_scan_info_iendel_get, 'iazlst' = task_rhi_scan_info_iazlst_get, 'ipad_end' = task_rhi_scan_info_ipad_end_get, 'iStartEnd' = task_rhi_scan_info_iStartEnd_get)
  vaccessors = c('istartel', 'iendel', 'iazlst', 'ipad_end', 'iStartEnd')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_rhi_scan_info
# Start of accessor method for task_rhi_scan_info
setMethod('$<-', '_p_task_rhi_scan_info', function(x, name, value)

{
  accessorFuns = list('istartel' = task_rhi_scan_info_istartel_set, 'iendel' = task_rhi_scan_info_iendel_set, 'iazlst' = task_rhi_scan_info_iazlst_set, 'ipad_end' = task_rhi_scan_info_ipad_end_set, 'iStartEnd' = task_rhi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_rhi_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('istartel' = task_rhi_scan_info_istartel_set, 'iendel' = task_rhi_scan_info_iendel_set, 'iazlst' = task_rhi_scan_info_iazlst_set, 'ipad_end' = task_rhi_scan_info_ipad_end_set, 'iStartEnd' = task_rhi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_rhi_scan_info
setMethod('delete', '_p_task_rhi_scan_info', function(obj) {delete_task_rhi_scan_info(obj)})
# Start definition of copy functions & methods for task_rhi_scan_info
CopyToR_task_rhi_scan_info = function(value, obj = new("task_rhi_scan_info"))
{
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_rhi_scan_info = function(value, obj)
{
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_rhi_scan_info
setMethod('copyToR', '_p_task_rhi_scan_info', CopyToR_task_rhi_scan_info)
setMethod('copyToC', 'task_rhi_scan_info', CopyToC_task_rhi_scan_info)

# End definition of copy methods for task_rhi_scan_info
# End definition of copy functions & methods for task_rhi_scan_info
# Start of serv_task_rhi_scan_info_istartel_set

`serv_task_rhi_scan_info_istartel_set` = function(self, s_istartel)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  s_istartel = as.numeric(s_istartel) 
  
  assert(length(s_istartel) == 1 && s_istartel >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_rhi_scan_info_istartel_set', self, s_istartel, PACKAGE='iris')
  
}

attr(`serv_task_rhi_scan_info_istartel_set`, 'returnType') = 'void'
attr(`serv_task_rhi_scan_info_istartel_set`, "inputTypes") = c('_p_serv_task_rhi_scan_info', 'numeric')
class(`serv_task_rhi_scan_info_istartel_set`) = c("SWIGFunction", class('serv_task_rhi_scan_info_istartel_set'))

# Start of serv_task_rhi_scan_info_istartel_get

`serv_task_rhi_scan_info_istartel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  .Call('R_swig_serv_task_rhi_scan_info_istartel_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_rhi_scan_info_istartel_get`, 'returnType') = 'numeric'
attr(`serv_task_rhi_scan_info_istartel_get`, "inputTypes") = c('_p_serv_task_rhi_scan_info')
class(`serv_task_rhi_scan_info_istartel_get`) = c("SWIGFunction", class('serv_task_rhi_scan_info_istartel_get'))

# Start of serv_task_rhi_scan_info_iendel_set

`serv_task_rhi_scan_info_iendel_set` = function(self, s_iendel)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  s_iendel = as.numeric(s_iendel) 
  
  assert(length(s_iendel) == 1 && s_iendel >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_rhi_scan_info_iendel_set', self, s_iendel, PACKAGE='iris')
  
}

attr(`serv_task_rhi_scan_info_iendel_set`, 'returnType') = 'void'
attr(`serv_task_rhi_scan_info_iendel_set`, "inputTypes") = c('_p_serv_task_rhi_scan_info', 'numeric')
class(`serv_task_rhi_scan_info_iendel_set`) = c("SWIGFunction", class('serv_task_rhi_scan_info_iendel_set'))

# Start of serv_task_rhi_scan_info_iendel_get

`serv_task_rhi_scan_info_iendel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  .Call('R_swig_serv_task_rhi_scan_info_iendel_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_rhi_scan_info_iendel_get`, 'returnType') = 'numeric'
attr(`serv_task_rhi_scan_info_iendel_get`, "inputTypes") = c('_p_serv_task_rhi_scan_info')
class(`serv_task_rhi_scan_info_iendel_get`) = c("SWIGFunction", class('serv_task_rhi_scan_info_iendel_get'))

# Start of serv_task_rhi_scan_info_iazlst_set

`serv_task_rhi_scan_info_iazlst_set` = function(self, s_iazlst)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  s_iazlst = as.numeric(s_iazlst) 
  
#  assert(length(s_iazlst) >= (40))
  
  .Call('R_swig_serv_task_rhi_scan_info_iazlst_set', self, s_iazlst, PACKAGE='iris')
  
}

attr(`serv_task_rhi_scan_info_iazlst_set`, 'returnType') = 'void'
attr(`serv_task_rhi_scan_info_iazlst_set`, "inputTypes") = c('_p_serv_task_rhi_scan_info', '_p_unsigned_int')
class(`serv_task_rhi_scan_info_iazlst_set`) = c("SWIGFunction", class('serv_task_rhi_scan_info_iazlst_set'))

# Start of serv_task_rhi_scan_info_iazlst_get

`serv_task_rhi_scan_info_iazlst_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  ans = .Call('R_swig_serv_task_rhi_scan_info_iazlst_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_int"
  
  ans
  
}

attr(`serv_task_rhi_scan_info_iazlst_get`, 'returnType') = '_p_unsigned_int'
attr(`serv_task_rhi_scan_info_iazlst_get`, "inputTypes") = c('_p_serv_task_rhi_scan_info')
class(`serv_task_rhi_scan_info_iazlst_get`) = c("SWIGFunction", class('serv_task_rhi_scan_info_iazlst_get'))

# Start of serv_task_rhi_scan_info_iStartEnd_set

`serv_task_rhi_scan_info_iStartEnd_set` = function(self, s_iStartEnd)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  s_iStartEnd = as.numeric(s_iStartEnd) 
  
  assert(length(s_iStartEnd) == 1 && s_iStartEnd >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_rhi_scan_info_iStartEnd_set', self, s_iStartEnd, PACKAGE='iris')
  
}

attr(`serv_task_rhi_scan_info_iStartEnd_set`, 'returnType') = 'void'
attr(`serv_task_rhi_scan_info_iStartEnd_set`, "inputTypes") = c('_p_serv_task_rhi_scan_info', 'numeric')
class(`serv_task_rhi_scan_info_iStartEnd_set`) = c("SWIGFunction", class('serv_task_rhi_scan_info_iStartEnd_set'))

# Start of serv_task_rhi_scan_info_iStartEnd_get

`serv_task_rhi_scan_info_iStartEnd_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  .Call('R_swig_serv_task_rhi_scan_info_iStartEnd_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_rhi_scan_info_iStartEnd_get`, 'returnType') = 'numeric'
attr(`serv_task_rhi_scan_info_iStartEnd_get`, "inputTypes") = c('_p_serv_task_rhi_scan_info')
class(`serv_task_rhi_scan_info_iStartEnd_get`) = c("SWIGFunction", class('serv_task_rhi_scan_info_iStartEnd_get'))

# Start of new_serv_task_rhi_scan_info

`serv_task_rhi_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_serv_task_rhi_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_rhi_scan_info"
  
  ans
  
}

attr(`serv_task_rhi_scan_info`, 'returnType') = '_p_serv_task_rhi_scan_info'
class(`serv_task_rhi_scan_info`) = c("SWIGFunction", class('serv_task_rhi_scan_info'))

# Start of delete_serv_task_rhi_scan_info

`delete_serv_task_rhi_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_rhi_scan_info") 
  .Call('R_swig_delete_serv_task_rhi_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_serv_task_rhi_scan_info`, 'returnType') = 'void'
attr(`delete_serv_task_rhi_scan_info`, "inputTypes") = c('_p_serv_task_rhi_scan_info')
class(`delete_serv_task_rhi_scan_info`) = c("SWIGFunction", class('delete_serv_task_rhi_scan_info'))

# Start of accessor method for serv_task_rhi_scan_info
setMethod('$', '_p_serv_task_rhi_scan_info', function(x, name)

{
  accessorFuns = list('istartel' = serv_task_rhi_scan_info_istartel_get, 'iendel' = serv_task_rhi_scan_info_iendel_get, 'iazlst' = serv_task_rhi_scan_info_iazlst_get, 'iStartEnd' = serv_task_rhi_scan_info_iStartEnd_get)
  vaccessors = c('istartel', 'iendel', 'iazlst', 'iStartEnd')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for serv_task_rhi_scan_info
# Start of accessor method for serv_task_rhi_scan_info
setMethod('$<-', '_p_serv_task_rhi_scan_info', function(x, name, value)

{
  accessorFuns = list('istartel' = serv_task_rhi_scan_info_istartel_set, 'iendel' = serv_task_rhi_scan_info_iendel_set, 'iazlst' = serv_task_rhi_scan_info_iazlst_set, 'iStartEnd' = serv_task_rhi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_serv_task_rhi_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('istartel' = serv_task_rhi_scan_info_istartel_set, 'iendel' = serv_task_rhi_scan_info_iendel_set, 'iazlst' = serv_task_rhi_scan_info_iazlst_set, 'iStartEnd' = serv_task_rhi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for serv_task_rhi_scan_info
setMethod('delete', '_p_serv_task_rhi_scan_info', function(obj) {delete_serv_task_rhi_scan_info(obj)})
# Start definition of copy functions & methods for serv_task_rhi_scan_info
CopyToR_serv_task_rhi_scan_info = function(value, obj = new("serv_task_rhi_scan_info"))
{
  obj@istartel = value$istartel
  obj@iendel = value$iendel
  obj@iazlst = value$iazlst
  obj@iStartEnd = value$iStartEnd
  obj
}



CopyToC_serv_task_rhi_scan_info = function(value, obj)
{
  obj$istartel = value@istartel
  obj$iendel = value@iendel
  obj$iazlst = value@iazlst
  obj$iStartEnd = value@iStartEnd
  obj
}



# Start definition of copy methods for serv_task_rhi_scan_info
setMethod('copyToR', '_p_serv_task_rhi_scan_info', CopyToR_serv_task_rhi_scan_info)
setMethod('copyToC', 'serv_task_rhi_scan_info', CopyToC_serv_task_rhi_scan_info)

# End definition of copy methods for serv_task_rhi_scan_info
# End definition of copy functions & methods for serv_task_rhi_scan_info
# Start of task_ppi_scan_info_istartaz_set

`task_ppi_scan_info_istartaz_set` = function(self, s_istartaz)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  s_istartaz = coerceIfNotSubclass(s_istartaz, "_p_unsigned_short") 
  .Call('R_swig_task_ppi_scan_info_istartaz_set', self, s_istartaz, PACKAGE='iris')
  
}

attr(`task_ppi_scan_info_istartaz_set`, 'returnType') = 'void'
attr(`task_ppi_scan_info_istartaz_set`, "inputTypes") = c('_p_task_ppi_scan_info', '_p_unsigned_short')
class(`task_ppi_scan_info_istartaz_set`) = c("SWIGFunction", class('task_ppi_scan_info_istartaz_set'))

# Start of task_ppi_scan_info_istartaz_get

`task_ppi_scan_info_istartaz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  ans = .Call('R_swig_task_ppi_scan_info_istartaz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_ppi_scan_info_istartaz_get`, 'returnType') = '_p_unsigned_short'
attr(`task_ppi_scan_info_istartaz_get`, "inputTypes") = c('_p_task_ppi_scan_info')
class(`task_ppi_scan_info_istartaz_get`) = c("SWIGFunction", class('task_ppi_scan_info_istartaz_get'))

# Start of task_ppi_scan_info_iendaz_set

`task_ppi_scan_info_iendaz_set` = function(self, s_iendaz)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  s_iendaz = coerceIfNotSubclass(s_iendaz, "_p_unsigned_short") 
  .Call('R_swig_task_ppi_scan_info_iendaz_set', self, s_iendaz, PACKAGE='iris')
  
}

attr(`task_ppi_scan_info_iendaz_set`, 'returnType') = 'void'
attr(`task_ppi_scan_info_iendaz_set`, "inputTypes") = c('_p_task_ppi_scan_info', '_p_unsigned_short')
class(`task_ppi_scan_info_iendaz_set`) = c("SWIGFunction", class('task_ppi_scan_info_iendaz_set'))

# Start of task_ppi_scan_info_iendaz_get

`task_ppi_scan_info_iendaz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  ans = .Call('R_swig_task_ppi_scan_info_iendaz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_ppi_scan_info_iendaz_get`, 'returnType') = '_p_unsigned_short'
attr(`task_ppi_scan_info_iendaz_get`, "inputTypes") = c('_p_task_ppi_scan_info')
class(`task_ppi_scan_info_iendaz_get`) = c("SWIGFunction", class('task_ppi_scan_info_iendaz_get'))

# Start of task_ppi_scan_info_iellst_set

`task_ppi_scan_info_iellst_set` = function(self, s_iellst)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  
  if(is.list(s_iellst))
  assert(all(sapply(s_iellst, class) == "_p_unsigned_short"))     
  
  
#  assert(length(s_iellst) >= (40))
  
  .Call('R_swig_task_ppi_scan_info_iellst_set', self, s_iellst, PACKAGE='iris')
  
}

attr(`task_ppi_scan_info_iellst_set`, 'returnType') = 'void'
attr(`task_ppi_scan_info_iellst_set`, "inputTypes") = c('_p_task_ppi_scan_info', '_p_unsigned_short')
class(`task_ppi_scan_info_iellst_set`) = c("SWIGFunction", class('task_ppi_scan_info_iellst_set'))

# Start of task_ppi_scan_info_iellst_get

`task_ppi_scan_info_iellst_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  ans = .Call('R_swig_task_ppi_scan_info_iellst_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_ppi_scan_info_iellst_get`, 'returnType') = '_p_unsigned_short'
attr(`task_ppi_scan_info_iellst_get`, "inputTypes") = c('_p_task_ppi_scan_info')
class(`task_ppi_scan_info_iellst_get`) = c("SWIGFunction", class('task_ppi_scan_info_iellst_get'))

# Start of task_ppi_scan_info_ipad_end_set

`task_ppi_scan_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (115))
  
  .Call('R_swig_task_ppi_scan_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_ppi_scan_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_ppi_scan_info_ipad_end_set`, "inputTypes") = c('_p_task_ppi_scan_info', '_p_char')
class(`task_ppi_scan_info_ipad_end_set`) = c("SWIGFunction", class('task_ppi_scan_info_ipad_end_set'))

# Start of task_ppi_scan_info_ipad_end_get

`task_ppi_scan_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  ans = .Call('R_swig_task_ppi_scan_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_ppi_scan_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_ppi_scan_info_ipad_end_get`, "inputTypes") = c('_p_task_ppi_scan_info')
class(`task_ppi_scan_info_ipad_end_get`) = c("SWIGFunction", class('task_ppi_scan_info_ipad_end_get'))

# Start of task_ppi_scan_info_iStartEnd_set

`task_ppi_scan_info_iStartEnd_set` = function(self, s_iStartEnd)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  s_iStartEnd = coerceIfNotSubclass(s_iStartEnd, "_p_unsigned_char") 
  .Call('R_swig_task_ppi_scan_info_iStartEnd_set', self, s_iStartEnd, PACKAGE='iris')
  
}

attr(`task_ppi_scan_info_iStartEnd_set`, 'returnType') = 'void'
attr(`task_ppi_scan_info_iStartEnd_set`, "inputTypes") = c('_p_task_ppi_scan_info', '_p_unsigned_char')
class(`task_ppi_scan_info_iStartEnd_set`) = c("SWIGFunction", class('task_ppi_scan_info_iStartEnd_set'))

# Start of task_ppi_scan_info_iStartEnd_get

`task_ppi_scan_info_iStartEnd_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  ans = .Call('R_swig_task_ppi_scan_info_iStartEnd_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`task_ppi_scan_info_iStartEnd_get`, 'returnType') = '_p_unsigned_char'
attr(`task_ppi_scan_info_iStartEnd_get`, "inputTypes") = c('_p_task_ppi_scan_info')
class(`task_ppi_scan_info_iStartEnd_get`) = c("SWIGFunction", class('task_ppi_scan_info_iStartEnd_get'))

# Start of new_task_ppi_scan_info

`task_ppi_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_ppi_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_ppi_scan_info"
  
  ans
  
}

attr(`task_ppi_scan_info`, 'returnType') = '_p_task_ppi_scan_info'
class(`task_ppi_scan_info`) = c("SWIGFunction", class('task_ppi_scan_info'))

# Start of delete_task_ppi_scan_info

`delete_task_ppi_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_ppi_scan_info") 
  .Call('R_swig_delete_task_ppi_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_task_ppi_scan_info`, 'returnType') = 'void'
attr(`delete_task_ppi_scan_info`, "inputTypes") = c('_p_task_ppi_scan_info')
class(`delete_task_ppi_scan_info`) = c("SWIGFunction", class('delete_task_ppi_scan_info'))

# Start of accessor method for task_ppi_scan_info
setMethod('$', '_p_task_ppi_scan_info', function(x, name)

{
  accessorFuns = list('istartaz' = task_ppi_scan_info_istartaz_get, 'iendaz' = task_ppi_scan_info_iendaz_get, 'iellst' = task_ppi_scan_info_iellst_get, 'ipad_end' = task_ppi_scan_info_ipad_end_get, 'iStartEnd' = task_ppi_scan_info_iStartEnd_get)
  vaccessors = c('istartaz', 'iendaz', 'iellst', 'ipad_end', 'iStartEnd')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_ppi_scan_info
# Start of accessor method for task_ppi_scan_info
setMethod('$<-', '_p_task_ppi_scan_info', function(x, name, value)

{
  accessorFuns = list('istartaz' = task_ppi_scan_info_istartaz_set, 'iendaz' = task_ppi_scan_info_iendaz_set, 'iellst' = task_ppi_scan_info_iellst_set, 'ipad_end' = task_ppi_scan_info_ipad_end_set, 'iStartEnd' = task_ppi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_ppi_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('istartaz' = task_ppi_scan_info_istartaz_set, 'iendaz' = task_ppi_scan_info_iendaz_set, 'iellst' = task_ppi_scan_info_iellst_set, 'ipad_end' = task_ppi_scan_info_ipad_end_set, 'iStartEnd' = task_ppi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_ppi_scan_info
setMethod('delete', '_p_task_ppi_scan_info', function(obj) {delete_task_ppi_scan_info(obj)})
# Start definition of copy functions & methods for task_ppi_scan_info
CopyToR_task_ppi_scan_info = function(value, obj = new("task_ppi_scan_info"))
{
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_ppi_scan_info = function(value, obj)
{
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_ppi_scan_info
setMethod('copyToR', '_p_task_ppi_scan_info', CopyToR_task_ppi_scan_info)
setMethod('copyToC', 'task_ppi_scan_info', CopyToC_task_ppi_scan_info)

# End definition of copy methods for task_ppi_scan_info
# End definition of copy functions & methods for task_ppi_scan_info
# Start of serv_task_ppi_scan_info_istartaz_set

`serv_task_ppi_scan_info_istartaz_set` = function(self, s_istartaz)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  s_istartaz = as.numeric(s_istartaz) 
  
  assert(length(s_istartaz) == 1 && s_istartaz >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_ppi_scan_info_istartaz_set', self, s_istartaz, PACKAGE='iris')
  
}

attr(`serv_task_ppi_scan_info_istartaz_set`, 'returnType') = 'void'
attr(`serv_task_ppi_scan_info_istartaz_set`, "inputTypes") = c('_p_serv_task_ppi_scan_info', 'numeric')
class(`serv_task_ppi_scan_info_istartaz_set`) = c("SWIGFunction", class('serv_task_ppi_scan_info_istartaz_set'))

# Start of serv_task_ppi_scan_info_istartaz_get

`serv_task_ppi_scan_info_istartaz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  .Call('R_swig_serv_task_ppi_scan_info_istartaz_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_ppi_scan_info_istartaz_get`, 'returnType') = 'numeric'
attr(`serv_task_ppi_scan_info_istartaz_get`, "inputTypes") = c('_p_serv_task_ppi_scan_info')
class(`serv_task_ppi_scan_info_istartaz_get`) = c("SWIGFunction", class('serv_task_ppi_scan_info_istartaz_get'))

# Start of serv_task_ppi_scan_info_iendaz_set

`serv_task_ppi_scan_info_iendaz_set` = function(self, s_iendaz)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  s_iendaz = as.numeric(s_iendaz) 
  
  assert(length(s_iendaz) == 1 && s_iendaz >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_ppi_scan_info_iendaz_set', self, s_iendaz, PACKAGE='iris')
  
}

attr(`serv_task_ppi_scan_info_iendaz_set`, 'returnType') = 'void'
attr(`serv_task_ppi_scan_info_iendaz_set`, "inputTypes") = c('_p_serv_task_ppi_scan_info', 'numeric')
class(`serv_task_ppi_scan_info_iendaz_set`) = c("SWIGFunction", class('serv_task_ppi_scan_info_iendaz_set'))

# Start of serv_task_ppi_scan_info_iendaz_get

`serv_task_ppi_scan_info_iendaz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  .Call('R_swig_serv_task_ppi_scan_info_iendaz_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_ppi_scan_info_iendaz_get`, 'returnType') = 'numeric'
attr(`serv_task_ppi_scan_info_iendaz_get`, "inputTypes") = c('_p_serv_task_ppi_scan_info')
class(`serv_task_ppi_scan_info_iendaz_get`) = c("SWIGFunction", class('serv_task_ppi_scan_info_iendaz_get'))

# Start of serv_task_ppi_scan_info_iellst_set

`serv_task_ppi_scan_info_iellst_set` = function(self, s_iellst)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  s_iellst = as.numeric(s_iellst) 
  
#  assert(length(s_iellst) >= (40))
  
  .Call('R_swig_serv_task_ppi_scan_info_iellst_set', self, s_iellst, PACKAGE='iris')
  
}

attr(`serv_task_ppi_scan_info_iellst_set`, 'returnType') = 'void'
attr(`serv_task_ppi_scan_info_iellst_set`, "inputTypes") = c('_p_serv_task_ppi_scan_info', '_p_unsigned_int')
class(`serv_task_ppi_scan_info_iellst_set`) = c("SWIGFunction", class('serv_task_ppi_scan_info_iellst_set'))

# Start of serv_task_ppi_scan_info_iellst_get

`serv_task_ppi_scan_info_iellst_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  ans = .Call('R_swig_serv_task_ppi_scan_info_iellst_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_int"
  
  ans
  
}

attr(`serv_task_ppi_scan_info_iellst_get`, 'returnType') = '_p_unsigned_int'
attr(`serv_task_ppi_scan_info_iellst_get`, "inputTypes") = c('_p_serv_task_ppi_scan_info')
class(`serv_task_ppi_scan_info_iellst_get`) = c("SWIGFunction", class('serv_task_ppi_scan_info_iellst_get'))

# Start of serv_task_ppi_scan_info_iStartEnd_set

`serv_task_ppi_scan_info_iStartEnd_set` = function(self, s_iStartEnd)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  s_iStartEnd = as.numeric(s_iStartEnd) 
  
  assert(length(s_iStartEnd) == 1 && s_iStartEnd >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_ppi_scan_info_iStartEnd_set', self, s_iStartEnd, PACKAGE='iris')
  
}

attr(`serv_task_ppi_scan_info_iStartEnd_set`, 'returnType') = 'void'
attr(`serv_task_ppi_scan_info_iStartEnd_set`, "inputTypes") = c('_p_serv_task_ppi_scan_info', 'numeric')
class(`serv_task_ppi_scan_info_iStartEnd_set`) = c("SWIGFunction", class('serv_task_ppi_scan_info_iStartEnd_set'))

# Start of serv_task_ppi_scan_info_iStartEnd_get

`serv_task_ppi_scan_info_iStartEnd_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  .Call('R_swig_serv_task_ppi_scan_info_iStartEnd_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_ppi_scan_info_iStartEnd_get`, 'returnType') = 'numeric'
attr(`serv_task_ppi_scan_info_iStartEnd_get`, "inputTypes") = c('_p_serv_task_ppi_scan_info')
class(`serv_task_ppi_scan_info_iStartEnd_get`) = c("SWIGFunction", class('serv_task_ppi_scan_info_iStartEnd_get'))

# Start of new_serv_task_ppi_scan_info

`serv_task_ppi_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_serv_task_ppi_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_ppi_scan_info"
  
  ans
  
}

attr(`serv_task_ppi_scan_info`, 'returnType') = '_p_serv_task_ppi_scan_info'
class(`serv_task_ppi_scan_info`) = c("SWIGFunction", class('serv_task_ppi_scan_info'))

# Start of delete_serv_task_ppi_scan_info

`delete_serv_task_ppi_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_ppi_scan_info") 
  .Call('R_swig_delete_serv_task_ppi_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_serv_task_ppi_scan_info`, 'returnType') = 'void'
attr(`delete_serv_task_ppi_scan_info`, "inputTypes") = c('_p_serv_task_ppi_scan_info')
class(`delete_serv_task_ppi_scan_info`) = c("SWIGFunction", class('delete_serv_task_ppi_scan_info'))

# Start of accessor method for serv_task_ppi_scan_info
setMethod('$', '_p_serv_task_ppi_scan_info', function(x, name)

{
  accessorFuns = list('istartaz' = serv_task_ppi_scan_info_istartaz_get, 'iendaz' = serv_task_ppi_scan_info_iendaz_get, 'iellst' = serv_task_ppi_scan_info_iellst_get, 'iStartEnd' = serv_task_ppi_scan_info_iStartEnd_get)
  vaccessors = c('istartaz', 'iendaz', 'iellst', 'iStartEnd')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for serv_task_ppi_scan_info
# Start of accessor method for serv_task_ppi_scan_info
setMethod('$<-', '_p_serv_task_ppi_scan_info', function(x, name, value)

{
  accessorFuns = list('istartaz' = serv_task_ppi_scan_info_istartaz_set, 'iendaz' = serv_task_ppi_scan_info_iendaz_set, 'iellst' = serv_task_ppi_scan_info_iellst_set, 'iStartEnd' = serv_task_ppi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_serv_task_ppi_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('istartaz' = serv_task_ppi_scan_info_istartaz_set, 'iendaz' = serv_task_ppi_scan_info_iendaz_set, 'iellst' = serv_task_ppi_scan_info_iellst_set, 'iStartEnd' = serv_task_ppi_scan_info_iStartEnd_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for serv_task_ppi_scan_info
setMethod('delete', '_p_serv_task_ppi_scan_info', function(obj) {delete_serv_task_ppi_scan_info(obj)})
# Start definition of copy functions & methods for serv_task_ppi_scan_info
CopyToR_serv_task_ppi_scan_info = function(value, obj = new("serv_task_ppi_scan_info"))
{
  obj@istartaz = value$istartaz
  obj@iendaz = value$iendaz
  obj@iellst = value$iellst
  obj@iStartEnd = value$iStartEnd
  obj
}



CopyToC_serv_task_ppi_scan_info = function(value, obj)
{
  obj$istartaz = value@istartaz
  obj$iendaz = value@iendaz
  obj$iellst = value@iellst
  obj$iStartEnd = value@iStartEnd
  obj
}



# Start definition of copy methods for serv_task_ppi_scan_info
setMethod('copyToR', '_p_serv_task_ppi_scan_info', CopyToR_serv_task_ppi_scan_info)
setMethod('copyToC', 'serv_task_ppi_scan_info', CopyToC_serv_task_ppi_scan_info)

# End definition of copy methods for serv_task_ppi_scan_info
# End definition of copy functions & methods for serv_task_ppi_scan_info
# Start of task_file_scan_info_ifirstaz_set

`task_file_scan_info_ifirstaz_set` = function(self, s_ifirstaz)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  s_ifirstaz = coerceIfNotSubclass(s_ifirstaz, "_p_unsigned_short") 
  .Call('R_swig_task_file_scan_info_ifirstaz_set', self, s_ifirstaz, PACKAGE='iris')
  
}

attr(`task_file_scan_info_ifirstaz_set`, 'returnType') = 'void'
attr(`task_file_scan_info_ifirstaz_set`, "inputTypes") = c('_p_task_file_scan_info', '_p_unsigned_short')
class(`task_file_scan_info_ifirstaz_set`) = c("SWIGFunction", class('task_file_scan_info_ifirstaz_set'))

# Start of task_file_scan_info_ifirstaz_get

`task_file_scan_info_ifirstaz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  ans = .Call('R_swig_task_file_scan_info_ifirstaz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_file_scan_info_ifirstaz_get`, 'returnType') = '_p_unsigned_short'
attr(`task_file_scan_info_ifirstaz_get`, "inputTypes") = c('_p_task_file_scan_info')
class(`task_file_scan_info_ifirstaz_get`) = c("SWIGFunction", class('task_file_scan_info_ifirstaz_get'))

# Start of task_file_scan_info_ifirstel_set

`task_file_scan_info_ifirstel_set` = function(self, s_ifirstel)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  s_ifirstel = coerceIfNotSubclass(s_ifirstel, "_p_unsigned_short") 
  .Call('R_swig_task_file_scan_info_ifirstel_set', self, s_ifirstel, PACKAGE='iris')
  
}

attr(`task_file_scan_info_ifirstel_set`, 'returnType') = 'void'
attr(`task_file_scan_info_ifirstel_set`, "inputTypes") = c('_p_task_file_scan_info', '_p_unsigned_short')
class(`task_file_scan_info_ifirstel_set`) = c("SWIGFunction", class('task_file_scan_info_ifirstel_set'))

# Start of task_file_scan_info_ifirstel_get

`task_file_scan_info_ifirstel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  ans = .Call('R_swig_task_file_scan_info_ifirstel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_file_scan_info_ifirstel_get`, 'returnType') = '_p_unsigned_short'
attr(`task_file_scan_info_ifirstel_get`, "inputTypes") = c('_p_task_file_scan_info')
class(`task_file_scan_info_ifirstel_get`) = c("SWIGFunction", class('task_file_scan_info_ifirstel_get'))

# Start of task_file_scan_info_scan_file_set

`task_file_scan_info_scan_file_set` = function(self, s_scan_file)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  
  if(is.list(s_scan_file))
  assert(all(sapply(s_scan_file, class) == "_p_char"))     
  
  
#  assert(length(s_scan_file) >= 12)
  
  .Call('R_swig_task_file_scan_info_scan_file_set', self, s_scan_file, PACKAGE='iris')
  
}

attr(`task_file_scan_info_scan_file_set`, 'returnType') = 'void'
attr(`task_file_scan_info_scan_file_set`, "inputTypes") = c('_p_task_file_scan_info', '_p_char')
class(`task_file_scan_info_scan_file_set`) = c("SWIGFunction", class('task_file_scan_info_scan_file_set'))

# Start of task_file_scan_info_scan_file_get

`task_file_scan_info_scan_file_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  ans = .Call('R_swig_task_file_scan_info_scan_file_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_file_scan_info_scan_file_get`, 'returnType') = '_p_char'
attr(`task_file_scan_info_scan_file_get`, "inputTypes") = c('_p_task_file_scan_info')
class(`task_file_scan_info_scan_file_get`) = c("SWIGFunction", class('task_file_scan_info_scan_file_get'))

# Start of task_file_scan_info_ipad_set

`task_file_scan_info_ipad_set` = function(self, s_ipad)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  
  if(is.list(s_ipad))
  assert(all(sapply(s_ipad, class) == "_p_char"))     
  
  
#  assert(length(s_ipad) >= 184)
  
  .Call('R_swig_task_file_scan_info_ipad_set', self, s_ipad, PACKAGE='iris')
  
}

attr(`task_file_scan_info_ipad_set`, 'returnType') = 'void'
attr(`task_file_scan_info_ipad_set`, "inputTypes") = c('_p_task_file_scan_info', '_p_char')
class(`task_file_scan_info_ipad_set`) = c("SWIGFunction", class('task_file_scan_info_ipad_set'))

# Start of task_file_scan_info_ipad_get

`task_file_scan_info_ipad_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  ans = .Call('R_swig_task_file_scan_info_ipad_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_file_scan_info_ipad_get`, 'returnType') = '_p_char'
attr(`task_file_scan_info_ipad_get`, "inputTypes") = c('_p_task_file_scan_info')
class(`task_file_scan_info_ipad_get`) = c("SWIGFunction", class('task_file_scan_info_ipad_get'))

# Start of new_task_file_scan_info

`task_file_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_file_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_file_scan_info"
  
  ans
  
}

attr(`task_file_scan_info`, 'returnType') = '_p_task_file_scan_info'
class(`task_file_scan_info`) = c("SWIGFunction", class('task_file_scan_info'))

# Start of delete_task_file_scan_info

`delete_task_file_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_file_scan_info") 
  .Call('R_swig_delete_task_file_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_task_file_scan_info`, 'returnType') = 'void'
attr(`delete_task_file_scan_info`, "inputTypes") = c('_p_task_file_scan_info')
class(`delete_task_file_scan_info`) = c("SWIGFunction", class('delete_task_file_scan_info'))

# Start of accessor method for task_file_scan_info
setMethod('$', '_p_task_file_scan_info', function(x, name)

{
  accessorFuns = list('ifirstaz' = task_file_scan_info_ifirstaz_get, 'ifirstel' = task_file_scan_info_ifirstel_get, 'scan_file' = task_file_scan_info_scan_file_get, 'ipad' = task_file_scan_info_ipad_get)
  vaccessors = c('ifirstaz', 'ifirstel', 'scan_file', 'ipad')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_file_scan_info
# Start of accessor method for task_file_scan_info
setMethod('$<-', '_p_task_file_scan_info', function(x, name, value)

{
  accessorFuns = list('ifirstaz' = task_file_scan_info_ifirstaz_set, 'ifirstel' = task_file_scan_info_ifirstel_set, 'scan_file' = task_file_scan_info_scan_file_set, 'ipad' = task_file_scan_info_ipad_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_file_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ifirstaz' = task_file_scan_info_ifirstaz_set, 'ifirstel' = task_file_scan_info_ifirstel_set, 'scan_file' = task_file_scan_info_scan_file_set, 'ipad' = task_file_scan_info_ipad_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_file_scan_info
setMethod('delete', '_p_task_file_scan_info', function(obj) {delete_task_file_scan_info(obj)})
# Start definition of copy functions & methods for task_file_scan_info
CopyToR_task_file_scan_info = function(value, obj = new("task_file_scan_info"))
{
  obj@scan_file = value$scan_file
  obj@ipad = value$ipad
  obj
}



CopyToC_task_file_scan_info = function(value, obj)
{
  obj$scan_file = value@scan_file
  obj$ipad = value@ipad
  obj
}



# Start definition of copy methods for task_file_scan_info
setMethod('copyToR', '_p_task_file_scan_info', CopyToR_task_file_scan_info)
setMethod('copyToC', 'task_file_scan_info', CopyToC_task_file_scan_info)

# End definition of copy methods for task_file_scan_info
# End definition of copy functions & methods for task_file_scan_info
# Start of task_manual_scan_info_iman_flags_set

`task_manual_scan_info_iman_flags_set` = function(self, s_iman_flags)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  s_iman_flags = coerceIfNotSubclass(s_iman_flags, "_p_unsigned_short") 
  .Call('R_swig_task_manual_scan_info_iman_flags_set', self, s_iman_flags, PACKAGE='iris')
  
}

attr(`task_manual_scan_info_iman_flags_set`, 'returnType') = 'void'
attr(`task_manual_scan_info_iman_flags_set`, "inputTypes") = c('_p_task_manual_scan_info', '_p_unsigned_short')
class(`task_manual_scan_info_iman_flags_set`) = c("SWIGFunction", class('task_manual_scan_info_iman_flags_set'))

# Start of task_manual_scan_info_iman_flags_get

`task_manual_scan_info_iman_flags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  ans = .Call('R_swig_task_manual_scan_info_iman_flags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_manual_scan_info_iman_flags_get`, 'returnType') = '_p_unsigned_short'
attr(`task_manual_scan_info_iman_flags_get`, "inputTypes") = c('_p_task_manual_scan_info')
class(`task_manual_scan_info_iman_flags_get`) = c("SWIGFunction", class('task_manual_scan_info_iman_flags_get'))

# Start of task_manual_scan_info_ipad2x2_set

`task_manual_scan_info_ipad2x2_set` = function(self, s_ipad2x2)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  
  if(is.list(s_ipad2x2))
  assert(all(sapply(s_ipad2x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad2x2) >= 2)
  
  .Call('R_swig_task_manual_scan_info_ipad2x2_set', self, s_ipad2x2, PACKAGE='iris')
  
}

attr(`task_manual_scan_info_ipad2x2_set`, 'returnType') = 'void'
attr(`task_manual_scan_info_ipad2x2_set`, "inputTypes") = c('_p_task_manual_scan_info', '_p_char')
class(`task_manual_scan_info_ipad2x2_set`) = c("SWIGFunction", class('task_manual_scan_info_ipad2x2_set'))

# Start of task_manual_scan_info_ipad2x2_get

`task_manual_scan_info_ipad2x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  ans = .Call('R_swig_task_manual_scan_info_ipad2x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_manual_scan_info_ipad2x2_get`, 'returnType') = '_p_char'
attr(`task_manual_scan_info_ipad2x2_get`, "inputTypes") = c('_p_task_manual_scan_info')
class(`task_manual_scan_info_ipad2x2_get`) = c("SWIGFunction", class('task_manual_scan_info_ipad2x2_get'))

# Start of task_manual_scan_info_iStartAz_set

`task_manual_scan_info_iStartAz_set` = function(self, s_iStartAz)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  s_iStartAz = as.numeric(s_iStartAz) 
  
  assert(length(s_iStartAz) == 1 && s_iStartAz >= 0, "All values must be non-negative")
  
  .Call('R_swig_task_manual_scan_info_iStartAz_set', self, s_iStartAz, PACKAGE='iris')
  
}

attr(`task_manual_scan_info_iStartAz_set`, 'returnType') = 'void'
attr(`task_manual_scan_info_iStartAz_set`, "inputTypes") = c('_p_task_manual_scan_info', 'numeric')
class(`task_manual_scan_info_iStartAz_set`) = c("SWIGFunction", class('task_manual_scan_info_iStartAz_set'))

# Start of task_manual_scan_info_iStartAz_get

`task_manual_scan_info_iStartAz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  .Call('R_swig_task_manual_scan_info_iStartAz_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_manual_scan_info_iStartAz_get`, 'returnType') = 'numeric'
attr(`task_manual_scan_info_iStartAz_get`, "inputTypes") = c('_p_task_manual_scan_info')
class(`task_manual_scan_info_iStartAz_get`) = c("SWIGFunction", class('task_manual_scan_info_iStartAz_get'))

# Start of task_manual_scan_info_iStartEl_set

`task_manual_scan_info_iStartEl_set` = function(self, s_iStartEl)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  s_iStartEl = as.numeric(s_iStartEl) 
  
  assert(length(s_iStartEl) == 1 && s_iStartEl >= 0, "All values must be non-negative")
  
  .Call('R_swig_task_manual_scan_info_iStartEl_set', self, s_iStartEl, PACKAGE='iris')
  
}

attr(`task_manual_scan_info_iStartEl_set`, 'returnType') = 'void'
attr(`task_manual_scan_info_iStartEl_set`, "inputTypes") = c('_p_task_manual_scan_info', 'numeric')
class(`task_manual_scan_info_iStartEl_set`) = c("SWIGFunction", class('task_manual_scan_info_iStartEl_set'))

# Start of task_manual_scan_info_iStartEl_get

`task_manual_scan_info_iStartEl_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  .Call('R_swig_task_manual_scan_info_iStartEl_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_manual_scan_info_iStartEl_get`, 'returnType') = 'numeric'
attr(`task_manual_scan_info_iStartEl_get`, "inputTypes") = c('_p_task_manual_scan_info')
class(`task_manual_scan_info_iStartEl_get`) = c("SWIGFunction", class('task_manual_scan_info_iStartEl_get'))

# Start of task_manual_scan_info_ipad_end_set

`task_manual_scan_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (188))
  
  .Call('R_swig_task_manual_scan_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_manual_scan_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_manual_scan_info_ipad_end_set`, "inputTypes") = c('_p_task_manual_scan_info', '_p_char')
class(`task_manual_scan_info_ipad_end_set`) = c("SWIGFunction", class('task_manual_scan_info_ipad_end_set'))

# Start of task_manual_scan_info_ipad_end_get

`task_manual_scan_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  ans = .Call('R_swig_task_manual_scan_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_manual_scan_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_manual_scan_info_ipad_end_get`, "inputTypes") = c('_p_task_manual_scan_info')
class(`task_manual_scan_info_ipad_end_get`) = c("SWIGFunction", class('task_manual_scan_info_ipad_end_get'))

# Start of new_task_manual_scan_info

`task_manual_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_manual_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_manual_scan_info"
  
  ans
  
}

attr(`task_manual_scan_info`, 'returnType') = '_p_task_manual_scan_info'
class(`task_manual_scan_info`) = c("SWIGFunction", class('task_manual_scan_info'))

# Start of delete_task_manual_scan_info

`delete_task_manual_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_manual_scan_info") 
  .Call('R_swig_delete_task_manual_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_task_manual_scan_info`, 'returnType') = 'void'
attr(`delete_task_manual_scan_info`, "inputTypes") = c('_p_task_manual_scan_info')
class(`delete_task_manual_scan_info`) = c("SWIGFunction", class('delete_task_manual_scan_info'))

# Start of accessor method for task_manual_scan_info
setMethod('$', '_p_task_manual_scan_info', function(x, name)

{
  accessorFuns = list('iman_flags' = task_manual_scan_info_iman_flags_get, 'ipad2x2' = task_manual_scan_info_ipad2x2_get, 'iStartAz' = task_manual_scan_info_iStartAz_get, 'iStartEl' = task_manual_scan_info_iStartEl_get, 'ipad_end' = task_manual_scan_info_ipad_end_get)
  vaccessors = c('iman_flags', 'ipad2x2', 'iStartAz', 'iStartEl', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_manual_scan_info
# Start of accessor method for task_manual_scan_info
setMethod('$<-', '_p_task_manual_scan_info', function(x, name, value)

{
  accessorFuns = list('iman_flags' = task_manual_scan_info_iman_flags_set, 'ipad2x2' = task_manual_scan_info_ipad2x2_set, 'iStartAz' = task_manual_scan_info_iStartAz_set, 'iStartEl' = task_manual_scan_info_iStartEl_set, 'ipad_end' = task_manual_scan_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_manual_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iman_flags' = task_manual_scan_info_iman_flags_set, 'ipad2x2' = task_manual_scan_info_ipad2x2_set, 'iStartAz' = task_manual_scan_info_iStartAz_set, 'iStartEl' = task_manual_scan_info_iStartEl_set, 'ipad_end' = task_manual_scan_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_manual_scan_info
setMethod('delete', '_p_task_manual_scan_info', function(obj) {delete_task_manual_scan_info(obj)})
# Start definition of copy functions & methods for task_manual_scan_info
CopyToR_task_manual_scan_info = function(value, obj = new("task_manual_scan_info"))
{
  obj@ipad2x2 = value$ipad2x2
  obj@iStartAz = value$iStartAz
  obj@iStartEl = value$iStartEl
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_manual_scan_info = function(value, obj)
{
  obj$ipad2x2 = value@ipad2x2
  obj$iStartAz = value@iStartAz
  obj$iStartEl = value@iStartEl
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_manual_scan_info
setMethod('copyToR', '_p_task_manual_scan_info', CopyToR_task_manual_scan_info)
setMethod('copyToC', 'task_manual_scan_info', CopyToC_task_manual_scan_info)

# End definition of copy methods for task_manual_scan_info
# End definition of copy functions & methods for task_manual_scan_info
# Start of task_exec_scan_info_sCommand_set

`task_exec_scan_info_sCommand_set` = function(self, s_sCommand)
{
  self = coerceIfNotSubclass(self, "_p_task_exec_scan_info") 
  
  if(is.list(s_sCommand))
  assert(all(sapply(s_sCommand, class) == "_p_char"))     
  
  
#  assert(length(s_sCommand) >= (160))
  
  .Call('R_swig_task_exec_scan_info_sCommand_set', self, s_sCommand, PACKAGE='iris')
  
}

attr(`task_exec_scan_info_sCommand_set`, 'returnType') = 'void'
attr(`task_exec_scan_info_sCommand_set`, "inputTypes") = c('_p_task_exec_scan_info', '_p_char')
class(`task_exec_scan_info_sCommand_set`) = c("SWIGFunction", class('task_exec_scan_info_sCommand_set'))

# Start of task_exec_scan_info_sCommand_get

`task_exec_scan_info_sCommand_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_exec_scan_info") 
  ans = .Call('R_swig_task_exec_scan_info_sCommand_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_exec_scan_info_sCommand_get`, 'returnType') = '_p_char'
attr(`task_exec_scan_info_sCommand_get`, "inputTypes") = c('_p_task_exec_scan_info')
class(`task_exec_scan_info_sCommand_get`) = c("SWIGFunction", class('task_exec_scan_info_sCommand_get'))

# Start of task_exec_scan_info_ipad_end_set

`task_exec_scan_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_exec_scan_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (40))
  
  .Call('R_swig_task_exec_scan_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_exec_scan_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_exec_scan_info_ipad_end_set`, "inputTypes") = c('_p_task_exec_scan_info', '_p_char')
class(`task_exec_scan_info_ipad_end_set`) = c("SWIGFunction", class('task_exec_scan_info_ipad_end_set'))

# Start of task_exec_scan_info_ipad_end_get

`task_exec_scan_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_exec_scan_info") 
  ans = .Call('R_swig_task_exec_scan_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_exec_scan_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_exec_scan_info_ipad_end_get`, "inputTypes") = c('_p_task_exec_scan_info')
class(`task_exec_scan_info_ipad_end_get`) = c("SWIGFunction", class('task_exec_scan_info_ipad_end_get'))

# Start of new_task_exec_scan_info

`task_exec_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_exec_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_exec_scan_info"
  
  ans
  
}

attr(`task_exec_scan_info`, 'returnType') = '_p_task_exec_scan_info'
class(`task_exec_scan_info`) = c("SWIGFunction", class('task_exec_scan_info'))

# Start of delete_task_exec_scan_info

`delete_task_exec_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_exec_scan_info") 
  .Call('R_swig_delete_task_exec_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_task_exec_scan_info`, 'returnType') = 'void'
attr(`delete_task_exec_scan_info`, "inputTypes") = c('_p_task_exec_scan_info')
class(`delete_task_exec_scan_info`) = c("SWIGFunction", class('delete_task_exec_scan_info'))

# Start of accessor method for task_exec_scan_info
setMethod('$', '_p_task_exec_scan_info', function(x, name)

{
  accessorFuns = list('sCommand' = task_exec_scan_info_sCommand_get, 'ipad_end' = task_exec_scan_info_ipad_end_get)
  vaccessors = c('sCommand', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_exec_scan_info
# Start of accessor method for task_exec_scan_info
setMethod('$<-', '_p_task_exec_scan_info', function(x, name, value)

{
  accessorFuns = list('sCommand' = task_exec_scan_info_sCommand_set, 'ipad_end' = task_exec_scan_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_exec_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('sCommand' = task_exec_scan_info_sCommand_set, 'ipad_end' = task_exec_scan_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_exec_scan_info
setMethod('delete', '_p_task_exec_scan_info', function(obj) {delete_task_exec_scan_info(obj)})
# Start definition of copy functions & methods for task_exec_scan_info
CopyToR_task_exec_scan_info = function(value, obj = new("task_exec_scan_info"))
{
  obj@sCommand = value$sCommand
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_exec_scan_info = function(value, obj)
{
  obj$sCommand = value@sCommand
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_exec_scan_info
setMethod('copyToR', '_p_task_exec_scan_info', CopyToR_task_exec_scan_info)
setMethod('copyToC', 'task_exec_scan_info', CopyToC_task_exec_scan_info)

# End definition of copy methods for task_exec_scan_info
# End definition of copy functions & methods for task_exec_scan_info
# Start of serv_task_file_scan_info_ifirstaz_set

`serv_task_file_scan_info_ifirstaz_set` = function(self, s_ifirstaz)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_file_scan_info") 
  s_ifirstaz = as.numeric(s_ifirstaz) 
  
  assert(length(s_ifirstaz) == 1 && s_ifirstaz >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_file_scan_info_ifirstaz_set', self, s_ifirstaz, PACKAGE='iris')
  
}

attr(`serv_task_file_scan_info_ifirstaz_set`, 'returnType') = 'void'
attr(`serv_task_file_scan_info_ifirstaz_set`, "inputTypes") = c('_p_serv_task_file_scan_info', 'numeric')
class(`serv_task_file_scan_info_ifirstaz_set`) = c("SWIGFunction", class('serv_task_file_scan_info_ifirstaz_set'))

# Start of serv_task_file_scan_info_ifirstaz_get

`serv_task_file_scan_info_ifirstaz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_file_scan_info") 
  .Call('R_swig_serv_task_file_scan_info_ifirstaz_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_file_scan_info_ifirstaz_get`, 'returnType') = 'numeric'
attr(`serv_task_file_scan_info_ifirstaz_get`, "inputTypes") = c('_p_serv_task_file_scan_info')
class(`serv_task_file_scan_info_ifirstaz_get`) = c("SWIGFunction", class('serv_task_file_scan_info_ifirstaz_get'))

# Start of serv_task_file_scan_info_ifirstel_set

`serv_task_file_scan_info_ifirstel_set` = function(self, s_ifirstel)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_file_scan_info") 
  s_ifirstel = as.numeric(s_ifirstel) 
  
  assert(length(s_ifirstel) == 1 && s_ifirstel >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_file_scan_info_ifirstel_set', self, s_ifirstel, PACKAGE='iris')
  
}

attr(`serv_task_file_scan_info_ifirstel_set`, 'returnType') = 'void'
attr(`serv_task_file_scan_info_ifirstel_set`, "inputTypes") = c('_p_serv_task_file_scan_info', 'numeric')
class(`serv_task_file_scan_info_ifirstel_set`) = c("SWIGFunction", class('serv_task_file_scan_info_ifirstel_set'))

# Start of serv_task_file_scan_info_ifirstel_get

`serv_task_file_scan_info_ifirstel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_file_scan_info") 
  .Call('R_swig_serv_task_file_scan_info_ifirstel_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_file_scan_info_ifirstel_get`, 'returnType') = 'numeric'
attr(`serv_task_file_scan_info_ifirstel_get`, "inputTypes") = c('_p_serv_task_file_scan_info')
class(`serv_task_file_scan_info_ifirstel_get`) = c("SWIGFunction", class('serv_task_file_scan_info_ifirstel_get'))

# Start of serv_task_file_scan_info_scan_file_set

`serv_task_file_scan_info_scan_file_set` = function(self, s_scan_file)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_file_scan_info") 
  
  if(is.list(s_scan_file))
  assert(all(sapply(s_scan_file, class) == "_p_char"))     
  
  
#  assert(length(s_scan_file) >= 12)
  
  .Call('R_swig_serv_task_file_scan_info_scan_file_set', self, s_scan_file, PACKAGE='iris')
  
}

attr(`serv_task_file_scan_info_scan_file_set`, 'returnType') = 'void'
attr(`serv_task_file_scan_info_scan_file_set`, "inputTypes") = c('_p_serv_task_file_scan_info', '_p_char')
class(`serv_task_file_scan_info_scan_file_set`) = c("SWIGFunction", class('serv_task_file_scan_info_scan_file_set'))

# Start of serv_task_file_scan_info_scan_file_get

`serv_task_file_scan_info_scan_file_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_file_scan_info") 
  ans = .Call('R_swig_serv_task_file_scan_info_scan_file_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`serv_task_file_scan_info_scan_file_get`, 'returnType') = '_p_char'
attr(`serv_task_file_scan_info_scan_file_get`, "inputTypes") = c('_p_serv_task_file_scan_info')
class(`serv_task_file_scan_info_scan_file_get`) = c("SWIGFunction", class('serv_task_file_scan_info_scan_file_get'))

# Start of new_serv_task_file_scan_info

`serv_task_file_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_serv_task_file_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_file_scan_info"
  
  ans
  
}

attr(`serv_task_file_scan_info`, 'returnType') = '_p_serv_task_file_scan_info'
class(`serv_task_file_scan_info`) = c("SWIGFunction", class('serv_task_file_scan_info'))

# Start of delete_serv_task_file_scan_info

`delete_serv_task_file_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_file_scan_info") 
  .Call('R_swig_delete_serv_task_file_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_serv_task_file_scan_info`, 'returnType') = 'void'
attr(`delete_serv_task_file_scan_info`, "inputTypes") = c('_p_serv_task_file_scan_info')
class(`delete_serv_task_file_scan_info`) = c("SWIGFunction", class('delete_serv_task_file_scan_info'))

# Start of accessor method for serv_task_file_scan_info
setMethod('$', '_p_serv_task_file_scan_info', function(x, name)

{
  accessorFuns = list('ifirstaz' = serv_task_file_scan_info_ifirstaz_get, 'ifirstel' = serv_task_file_scan_info_ifirstel_get, 'scan_file' = serv_task_file_scan_info_scan_file_get)
  vaccessors = c('ifirstaz', 'ifirstel', 'scan_file')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for serv_task_file_scan_info
# Start of accessor method for serv_task_file_scan_info
setMethod('$<-', '_p_serv_task_file_scan_info', function(x, name, value)

{
  accessorFuns = list('ifirstaz' = serv_task_file_scan_info_ifirstaz_set, 'ifirstel' = serv_task_file_scan_info_ifirstel_set, 'scan_file' = serv_task_file_scan_info_scan_file_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_serv_task_file_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ifirstaz' = serv_task_file_scan_info_ifirstaz_set, 'ifirstel' = serv_task_file_scan_info_ifirstel_set, 'scan_file' = serv_task_file_scan_info_scan_file_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for serv_task_file_scan_info
setMethod('delete', '_p_serv_task_file_scan_info', function(obj) {delete_serv_task_file_scan_info(obj)})
# Start definition of copy functions & methods for serv_task_file_scan_info
CopyToR_serv_task_file_scan_info = function(value, obj = new("serv_task_file_scan_info"))
{
  obj@ifirstaz = value$ifirstaz
  obj@ifirstel = value$ifirstel
  obj@scan_file = value$scan_file
  obj
}



CopyToC_serv_task_file_scan_info = function(value, obj)
{
  obj$ifirstaz = value@ifirstaz
  obj$ifirstel = value@ifirstel
  obj$scan_file = value@scan_file
  obj
}



# Start definition of copy methods for serv_task_file_scan_info
setMethod('copyToR', '_p_serv_task_file_scan_info', CopyToR_serv_task_file_scan_info)
setMethod('copyToC', 'serv_task_file_scan_info', CopyToC_serv_task_file_scan_info)

# End definition of copy methods for serv_task_file_scan_info
# End definition of copy functions & methods for serv_task_file_scan_info
# Start of serv_task_manual_scan_info_iman_flags_set

`serv_task_manual_scan_info_iman_flags_set` = function(self, s_iman_flags)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_manual_scan_info") 
  s_iman_flags = as.numeric(s_iman_flags) 
  
  assert(length(s_iman_flags) == 1 && s_iman_flags >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_manual_scan_info_iman_flags_set', self, s_iman_flags, PACKAGE='iris')
  
}

attr(`serv_task_manual_scan_info_iman_flags_set`, 'returnType') = 'void'
attr(`serv_task_manual_scan_info_iman_flags_set`, "inputTypes") = c('_p_serv_task_manual_scan_info', 'numeric')
class(`serv_task_manual_scan_info_iman_flags_set`) = c("SWIGFunction", class('serv_task_manual_scan_info_iman_flags_set'))

# Start of serv_task_manual_scan_info_iman_flags_get

`serv_task_manual_scan_info_iman_flags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_manual_scan_info") 
  .Call('R_swig_serv_task_manual_scan_info_iman_flags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_manual_scan_info_iman_flags_get`, 'returnType') = 'numeric'
attr(`serv_task_manual_scan_info_iman_flags_get`, "inputTypes") = c('_p_serv_task_manual_scan_info')
class(`serv_task_manual_scan_info_iman_flags_get`) = c("SWIGFunction", class('serv_task_manual_scan_info_iman_flags_get'))

# Start of serv_task_manual_scan_info_iStartAz_set

`serv_task_manual_scan_info_iStartAz_set` = function(self, s_iStartAz)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_manual_scan_info") 
  s_iStartAz = as.numeric(s_iStartAz) 
  
  assert(length(s_iStartAz) == 1 && s_iStartAz >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_manual_scan_info_iStartAz_set', self, s_iStartAz, PACKAGE='iris')
  
}

attr(`serv_task_manual_scan_info_iStartAz_set`, 'returnType') = 'void'
attr(`serv_task_manual_scan_info_iStartAz_set`, "inputTypes") = c('_p_serv_task_manual_scan_info', 'numeric')
class(`serv_task_manual_scan_info_iStartAz_set`) = c("SWIGFunction", class('serv_task_manual_scan_info_iStartAz_set'))

# Start of serv_task_manual_scan_info_iStartAz_get

`serv_task_manual_scan_info_iStartAz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_manual_scan_info") 
  .Call('R_swig_serv_task_manual_scan_info_iStartAz_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_manual_scan_info_iStartAz_get`, 'returnType') = 'numeric'
attr(`serv_task_manual_scan_info_iStartAz_get`, "inputTypes") = c('_p_serv_task_manual_scan_info')
class(`serv_task_manual_scan_info_iStartAz_get`) = c("SWIGFunction", class('serv_task_manual_scan_info_iStartAz_get'))

# Start of serv_task_manual_scan_info_iStartEl_set

`serv_task_manual_scan_info_iStartEl_set` = function(self, s_iStartEl)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_manual_scan_info") 
  s_iStartEl = as.numeric(s_iStartEl) 
  
  assert(length(s_iStartEl) == 1 && s_iStartEl >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_manual_scan_info_iStartEl_set', self, s_iStartEl, PACKAGE='iris')
  
}

attr(`serv_task_manual_scan_info_iStartEl_set`, 'returnType') = 'void'
attr(`serv_task_manual_scan_info_iStartEl_set`, "inputTypes") = c('_p_serv_task_manual_scan_info', 'numeric')
class(`serv_task_manual_scan_info_iStartEl_set`) = c("SWIGFunction", class('serv_task_manual_scan_info_iStartEl_set'))

# Start of serv_task_manual_scan_info_iStartEl_get

`serv_task_manual_scan_info_iStartEl_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_manual_scan_info") 
  .Call('R_swig_serv_task_manual_scan_info_iStartEl_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_manual_scan_info_iStartEl_get`, 'returnType') = 'numeric'
attr(`serv_task_manual_scan_info_iStartEl_get`, "inputTypes") = c('_p_serv_task_manual_scan_info')
class(`serv_task_manual_scan_info_iStartEl_get`) = c("SWIGFunction", class('serv_task_manual_scan_info_iStartEl_get'))

# Start of new_serv_task_manual_scan_info

`serv_task_manual_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_serv_task_manual_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_manual_scan_info"
  
  ans
  
}

attr(`serv_task_manual_scan_info`, 'returnType') = '_p_serv_task_manual_scan_info'
class(`serv_task_manual_scan_info`) = c("SWIGFunction", class('serv_task_manual_scan_info'))

# Start of delete_serv_task_manual_scan_info

`delete_serv_task_manual_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_manual_scan_info") 
  .Call('R_swig_delete_serv_task_manual_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_serv_task_manual_scan_info`, 'returnType') = 'void'
attr(`delete_serv_task_manual_scan_info`, "inputTypes") = c('_p_serv_task_manual_scan_info')
class(`delete_serv_task_manual_scan_info`) = c("SWIGFunction", class('delete_serv_task_manual_scan_info'))

# Start of accessor method for serv_task_manual_scan_info
setMethod('$', '_p_serv_task_manual_scan_info', function(x, name)

{
  accessorFuns = list('iman_flags' = serv_task_manual_scan_info_iman_flags_get, 'iStartAz' = serv_task_manual_scan_info_iStartAz_get, 'iStartEl' = serv_task_manual_scan_info_iStartEl_get)
  vaccessors = c('iman_flags', 'iStartAz', 'iStartEl')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for serv_task_manual_scan_info
# Start of accessor method for serv_task_manual_scan_info
setMethod('$<-', '_p_serv_task_manual_scan_info', function(x, name, value)

{
  accessorFuns = list('iman_flags' = serv_task_manual_scan_info_iman_flags_set, 'iStartAz' = serv_task_manual_scan_info_iStartAz_set, 'iStartEl' = serv_task_manual_scan_info_iStartEl_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_serv_task_manual_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iman_flags' = serv_task_manual_scan_info_iman_flags_set, 'iStartAz' = serv_task_manual_scan_info_iStartAz_set, 'iStartEl' = serv_task_manual_scan_info_iStartEl_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for serv_task_manual_scan_info
setMethod('delete', '_p_serv_task_manual_scan_info', function(obj) {delete_serv_task_manual_scan_info(obj)})
# Start definition of copy functions & methods for serv_task_manual_scan_info
CopyToR_serv_task_manual_scan_info = function(value, obj = new("serv_task_manual_scan_info"))
{
  obj@iman_flags = value$iman_flags
  obj@iStartAz = value$iStartAz
  obj@iStartEl = value$iStartEl
  obj
}



CopyToC_serv_task_manual_scan_info = function(value, obj)
{
  obj$iman_flags = value@iman_flags
  obj$iStartAz = value@iStartAz
  obj$iStartEl = value@iStartEl
  obj
}



# Start definition of copy methods for serv_task_manual_scan_info
setMethod('copyToR', '_p_serv_task_manual_scan_info', CopyToR_serv_task_manual_scan_info)
setMethod('copyToC', 'serv_task_manual_scan_info', CopyToC_serv_task_manual_scan_info)

# End definition of copy methods for serv_task_manual_scan_info
# End definition of copy functions & methods for serv_task_manual_scan_info
# Start of task_scan_info_u_rhi_set

`task_scan_info_u_rhi_set` = function(self, s_rhi)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  s_rhi = coerceIfNotSubclass(s_rhi, "_p_task_rhi_scan_info") 
  .Call('R_swig_task_scan_info_u_rhi_set', self, s_rhi, PACKAGE='iris')
  
}

attr(`task_scan_info_u_rhi_set`, 'returnType') = 'void'
attr(`task_scan_info_u_rhi_set`, "inputTypes") = c('_p_task_scan_info_u', '_p_task_rhi_scan_info')
class(`task_scan_info_u_rhi_set`) = c("SWIGFunction", class('task_scan_info_u_rhi_set'))

# Start of task_scan_info_u_rhi_get

`task_scan_info_u_rhi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  ans = .Call('R_swig_task_scan_info_u_rhi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_rhi_scan_info"
  
  ans
  
}

attr(`task_scan_info_u_rhi_get`, 'returnType') = '_p_task_rhi_scan_info'
attr(`task_scan_info_u_rhi_get`, "inputTypes") = c('_p_task_scan_info_u')
class(`task_scan_info_u_rhi_get`) = c("SWIGFunction", class('task_scan_info_u_rhi_get'))

# Start of task_scan_info_u_ppi_set

`task_scan_info_u_ppi_set` = function(self, s_ppi)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  s_ppi = coerceIfNotSubclass(s_ppi, "_p_task_ppi_scan_info") 
  .Call('R_swig_task_scan_info_u_ppi_set', self, s_ppi, PACKAGE='iris')
  
}

attr(`task_scan_info_u_ppi_set`, 'returnType') = 'void'
attr(`task_scan_info_u_ppi_set`, "inputTypes") = c('_p_task_scan_info_u', '_p_task_ppi_scan_info')
class(`task_scan_info_u_ppi_set`) = c("SWIGFunction", class('task_scan_info_u_ppi_set'))

# Start of task_scan_info_u_ppi_get

`task_scan_info_u_ppi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  ans = .Call('R_swig_task_scan_info_u_ppi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_ppi_scan_info"
  
  ans
  
}

attr(`task_scan_info_u_ppi_get`, 'returnType') = '_p_task_ppi_scan_info'
attr(`task_scan_info_u_ppi_get`, "inputTypes") = c('_p_task_scan_info_u')
class(`task_scan_info_u_ppi_get`) = c("SWIGFunction", class('task_scan_info_u_ppi_get'))

# Start of task_scan_info_u_fil_set

`task_scan_info_u_fil_set` = function(self, s_fil)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  s_fil = coerceIfNotSubclass(s_fil, "_p_task_file_scan_info") 
  .Call('R_swig_task_scan_info_u_fil_set', self, s_fil, PACKAGE='iris')
  
}

attr(`task_scan_info_u_fil_set`, 'returnType') = 'void'
attr(`task_scan_info_u_fil_set`, "inputTypes") = c('_p_task_scan_info_u', '_p_task_file_scan_info')
class(`task_scan_info_u_fil_set`) = c("SWIGFunction", class('task_scan_info_u_fil_set'))

# Start of task_scan_info_u_fil_get

`task_scan_info_u_fil_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  ans = .Call('R_swig_task_scan_info_u_fil_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_file_scan_info"
  
  ans
  
}

attr(`task_scan_info_u_fil_get`, 'returnType') = '_p_task_file_scan_info'
attr(`task_scan_info_u_fil_get`, "inputTypes") = c('_p_task_scan_info_u')
class(`task_scan_info_u_fil_get`) = c("SWIGFunction", class('task_scan_info_u_fil_get'))

# Start of task_scan_info_u_man_set

`task_scan_info_u_man_set` = function(self, s_man)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  s_man = coerceIfNotSubclass(s_man, "_p_task_manual_scan_info") 
  .Call('R_swig_task_scan_info_u_man_set', self, s_man, PACKAGE='iris')
  
}

attr(`task_scan_info_u_man_set`, 'returnType') = 'void'
attr(`task_scan_info_u_man_set`, "inputTypes") = c('_p_task_scan_info_u', '_p_task_manual_scan_info')
class(`task_scan_info_u_man_set`) = c("SWIGFunction", class('task_scan_info_u_man_set'))

# Start of task_scan_info_u_man_get

`task_scan_info_u_man_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  ans = .Call('R_swig_task_scan_info_u_man_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_manual_scan_info"
  
  ans
  
}

attr(`task_scan_info_u_man_get`, 'returnType') = '_p_task_manual_scan_info'
attr(`task_scan_info_u_man_get`, "inputTypes") = c('_p_task_scan_info_u')
class(`task_scan_info_u_man_get`) = c("SWIGFunction", class('task_scan_info_u_man_get'))

# Start of task_scan_info_u_exec_set

`task_scan_info_u_exec_set` = function(self, s_exec)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  s_exec = coerceIfNotSubclass(s_exec, "_p_task_exec_scan_info") 
  .Call('R_swig_task_scan_info_u_exec_set', self, s_exec, PACKAGE='iris')
  
}

attr(`task_scan_info_u_exec_set`, 'returnType') = 'void'
attr(`task_scan_info_u_exec_set`, "inputTypes") = c('_p_task_scan_info_u', '_p_task_exec_scan_info')
class(`task_scan_info_u_exec_set`) = c("SWIGFunction", class('task_scan_info_u_exec_set'))

# Start of task_scan_info_u_exec_get

`task_scan_info_u_exec_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  ans = .Call('R_swig_task_scan_info_u_exec_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_exec_scan_info"
  
  ans
  
}

attr(`task_scan_info_u_exec_get`, 'returnType') = '_p_task_exec_scan_info'
attr(`task_scan_info_u_exec_get`, "inputTypes") = c('_p_task_scan_info_u')
class(`task_scan_info_u_exec_get`) = c("SWIGFunction", class('task_scan_info_u_exec_get'))

# Start of new_task_scan_info_u

`task_scan_info_u` = function()
{
  ans = .Call('R_swig_new_task_scan_info_u', PACKAGE='iris')
  class(ans) <- "_p_task_scan_info_u"
  
  ans
  
}

attr(`task_scan_info_u`, 'returnType') = '_p_task_scan_info_u'
class(`task_scan_info_u`) = c("SWIGFunction", class('task_scan_info_u'))

# Start of delete_task_scan_info_u

`delete_task_scan_info_u` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info_u") 
  .Call('R_swig_delete_task_scan_info_u', self, PACKAGE='iris')
  
}

attr(`delete_task_scan_info_u`, 'returnType') = 'void'
attr(`delete_task_scan_info_u`, "inputTypes") = c('_p_task_scan_info_u')
class(`delete_task_scan_info_u`) = c("SWIGFunction", class('delete_task_scan_info_u'))

# Start of accessor method for task_scan_info_u
setMethod('$', '_p_task_scan_info_u', function(x, name)

{
  accessorFuns = list('rhi' = task_scan_info_u_rhi_get, 'ppi' = task_scan_info_u_ppi_get, 'fil' = task_scan_info_u_fil_get, 'man' = task_scan_info_u_man_get, 'exec' = task_scan_info_u_exec_get)
  vaccessors = c('rhi', 'ppi', 'fil', 'man', 'exec')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_scan_info_u
# Start of accessor method for task_scan_info_u
setMethod('$<-', '_p_task_scan_info_u', function(x, name, value)

{
  accessorFuns = list('rhi' = task_scan_info_u_rhi_set, 'ppi' = task_scan_info_u_ppi_set, 'fil' = task_scan_info_u_fil_set, 'man' = task_scan_info_u_man_set, 'exec' = task_scan_info_u_exec_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_scan_info_u', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('rhi' = task_scan_info_u_rhi_set, 'ppi' = task_scan_info_u_ppi_set, 'fil' = task_scan_info_u_fil_set, 'man' = task_scan_info_u_man_set, 'exec' = task_scan_info_u_exec_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_scan_info_u
setMethod('delete', '_p_task_scan_info_u', function(obj) {delete_task_scan_info_u(obj)})
# Start of task_range_info_ibin_first_set

`task_range_info_ibin_first_set` = function(self, s_ibin_first)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_first = as.integer(s_ibin_first) 
  
  if(length(s_ibin_first) > 1) {
    Rf_warning("using only the first element of s_ibin_first")
  }
  
  .Call('R_swig_task_range_info_ibin_first_set', self, s_ibin_first, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_first_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_first_set`, "inputTypes") = c('_p_task_range_info', 'numeric')
class(`task_range_info_ibin_first_set`) = c("SWIGFunction", class('task_range_info_ibin_first_set'))

# Start of task_range_info_ibin_first_get

`task_range_info_ibin_first_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  .Call('R_swig_task_range_info_ibin_first_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_range_info_ibin_first_get`, 'returnType') = 'numeric'
attr(`task_range_info_ibin_first_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_first_get`) = c("SWIGFunction", class('task_range_info_ibin_first_get'))

# Start of task_range_info_ibin_last_set

`task_range_info_ibin_last_set` = function(self, s_ibin_last)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_last = as.integer(s_ibin_last) 
  
  if(length(s_ibin_last) > 1) {
    Rf_warning("using only the first element of s_ibin_last")
  }
  
  .Call('R_swig_task_range_info_ibin_last_set', self, s_ibin_last, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_last_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_last_set`, "inputTypes") = c('_p_task_range_info', 'numeric')
class(`task_range_info_ibin_last_set`) = c("SWIGFunction", class('task_range_info_ibin_last_set'))

# Start of task_range_info_ibin_last_get

`task_range_info_ibin_last_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  .Call('R_swig_task_range_info_ibin_last_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_range_info_ibin_last_get`, 'returnType') = 'numeric'
attr(`task_range_info_ibin_last_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_last_get`) = c("SWIGFunction", class('task_range_info_ibin_last_get'))

# Start of task_range_info_ibin_in_num_set

`task_range_info_ibin_in_num_set` = function(self, s_ibin_in_num)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_in_num = coerceIfNotSubclass(s_ibin_in_num, "_p_short") 
  .Call('R_swig_task_range_info_ibin_in_num_set', self, s_ibin_in_num, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_in_num_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_in_num_set`, "inputTypes") = c('_p_task_range_info', '_p_short')
class(`task_range_info_ibin_in_num_set`) = c("SWIGFunction", class('task_range_info_ibin_in_num_set'))

# Start of task_range_info_ibin_in_num_get

`task_range_info_ibin_in_num_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  ans = .Call('R_swig_task_range_info_ibin_in_num_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_range_info_ibin_in_num_get`, 'returnType') = '_p_short'
attr(`task_range_info_ibin_in_num_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_in_num_get`) = c("SWIGFunction", class('task_range_info_ibin_in_num_get'))

# Start of task_range_info_ibin_out_num_set

`task_range_info_ibin_out_num_set` = function(self, s_ibin_out_num)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_out_num = coerceIfNotSubclass(s_ibin_out_num, "_p_short") 
  .Call('R_swig_task_range_info_ibin_out_num_set', self, s_ibin_out_num, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_out_num_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_out_num_set`, "inputTypes") = c('_p_task_range_info', '_p_short')
class(`task_range_info_ibin_out_num_set`) = c("SWIGFunction", class('task_range_info_ibin_out_num_set'))

# Start of task_range_info_ibin_out_num_get

`task_range_info_ibin_out_num_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  ans = .Call('R_swig_task_range_info_ibin_out_num_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_range_info_ibin_out_num_get`, 'returnType') = '_p_short'
attr(`task_range_info_ibin_out_num_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_out_num_get`) = c("SWIGFunction", class('task_range_info_ibin_out_num_get'))

# Start of task_range_info_ibin_in_step_set

`task_range_info_ibin_in_step_set` = function(self, s_ibin_in_step)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_in_step = as.integer(s_ibin_in_step) 
  
  if(length(s_ibin_in_step) > 1) {
    Rf_warning("using only the first element of s_ibin_in_step")
  }
  
  .Call('R_swig_task_range_info_ibin_in_step_set', self, s_ibin_in_step, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_in_step_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_in_step_set`, "inputTypes") = c('_p_task_range_info', 'numeric')
class(`task_range_info_ibin_in_step_set`) = c("SWIGFunction", class('task_range_info_ibin_in_step_set'))

# Start of task_range_info_ibin_in_step_get

`task_range_info_ibin_in_step_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  .Call('R_swig_task_range_info_ibin_in_step_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_range_info_ibin_in_step_get`, 'returnType') = 'numeric'
attr(`task_range_info_ibin_in_step_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_in_step_get`) = c("SWIGFunction", class('task_range_info_ibin_in_step_get'))

# Start of task_range_info_ibin_out_step_set

`task_range_info_ibin_out_step_set` = function(self, s_ibin_out_step)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_out_step = as.integer(s_ibin_out_step) 
  
  if(length(s_ibin_out_step) > 1) {
    Rf_warning("using only the first element of s_ibin_out_step")
  }
  
  .Call('R_swig_task_range_info_ibin_out_step_set', self, s_ibin_out_step, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_out_step_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_out_step_set`, "inputTypes") = c('_p_task_range_info', 'numeric')
class(`task_range_info_ibin_out_step_set`) = c("SWIGFunction", class('task_range_info_ibin_out_step_set'))

# Start of task_range_info_ibin_out_step_get

`task_range_info_ibin_out_step_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  .Call('R_swig_task_range_info_ibin_out_step_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_range_info_ibin_out_step_get`, 'returnType') = 'numeric'
attr(`task_range_info_ibin_out_step_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_out_step_get`) = c("SWIGFunction", class('task_range_info_ibin_out_step_get'))

# Start of task_range_info_ibin_var_set

`task_range_info_ibin_var_set` = function(self, s_ibin_var)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_var = coerceIfNotSubclass(s_ibin_var, "_p_unsigned_short") 
  .Call('R_swig_task_range_info_ibin_var_set', self, s_ibin_var, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_var_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_var_set`, "inputTypes") = c('_p_task_range_info', '_p_unsigned_short')
class(`task_range_info_ibin_var_set`) = c("SWIGFunction", class('task_range_info_ibin_var_set'))

# Start of task_range_info_ibin_var_get

`task_range_info_ibin_var_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  ans = .Call('R_swig_task_range_info_ibin_var_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_range_info_ibin_var_get`, 'returnType') = '_p_unsigned_short'
attr(`task_range_info_ibin_var_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_var_get`) = c("SWIGFunction", class('task_range_info_ibin_var_get'))

# Start of task_range_info_ibin_avg_set

`task_range_info_ibin_avg_set` = function(self, s_ibin_avg)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_avg = coerceIfNotSubclass(s_ibin_avg, "_p_short") 
  .Call('R_swig_task_range_info_ibin_avg_set', self, s_ibin_avg, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_avg_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_avg_set`, "inputTypes") = c('_p_task_range_info', '_p_short')
class(`task_range_info_ibin_avg_set`) = c("SWIGFunction", class('task_range_info_ibin_avg_set'))

# Start of task_range_info_ibin_avg_get

`task_range_info_ibin_avg_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  ans = .Call('R_swig_task_range_info_ibin_avg_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_range_info_ibin_avg_get`, 'returnType') = '_p_short'
attr(`task_range_info_ibin_avg_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_avg_get`) = c("SWIGFunction", class('task_range_info_ibin_avg_get'))

# Start of task_range_info_ibin_smooth_set

`task_range_info_ibin_smooth_set` = function(self, s_ibin_smooth)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  s_ibin_smooth = coerceIfNotSubclass(s_ibin_smooth, "_p_short") 
  .Call('R_swig_task_range_info_ibin_smooth_set', self, s_ibin_smooth, PACKAGE='iris')
  
}

attr(`task_range_info_ibin_smooth_set`, 'returnType') = 'void'
attr(`task_range_info_ibin_smooth_set`, "inputTypes") = c('_p_task_range_info', '_p_short')
class(`task_range_info_ibin_smooth_set`) = c("SWIGFunction", class('task_range_info_ibin_smooth_set'))

# Start of task_range_info_ibin_smooth_get

`task_range_info_ibin_smooth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  ans = .Call('R_swig_task_range_info_ibin_smooth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_range_info_ibin_smooth_get`, 'returnType') = '_p_short'
attr(`task_range_info_ibin_smooth_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ibin_smooth_get`) = c("SWIGFunction", class('task_range_info_ibin_smooth_get'))

# Start of task_range_info_ipad_end_set

`task_range_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (134))
  
  .Call('R_swig_task_range_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_range_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_range_info_ipad_end_set`, "inputTypes") = c('_p_task_range_info', '_p_char')
class(`task_range_info_ipad_end_set`) = c("SWIGFunction", class('task_range_info_ipad_end_set'))

# Start of task_range_info_ipad_end_get

`task_range_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  ans = .Call('R_swig_task_range_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_range_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_range_info_ipad_end_get`, "inputTypes") = c('_p_task_range_info')
class(`task_range_info_ipad_end_get`) = c("SWIGFunction", class('task_range_info_ipad_end_get'))

# Start of new_task_range_info

`task_range_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_range_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_range_info"
  
  ans
  
}

attr(`task_range_info`, 'returnType') = '_p_task_range_info'
class(`task_range_info`) = c("SWIGFunction", class('task_range_info'))

# Start of delete_task_range_info

`delete_task_range_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_range_info") 
  .Call('R_swig_delete_task_range_info', self, PACKAGE='iris')
  
}

attr(`delete_task_range_info`, 'returnType') = 'void'
attr(`delete_task_range_info`, "inputTypes") = c('_p_task_range_info')
class(`delete_task_range_info`) = c("SWIGFunction", class('delete_task_range_info'))

# Start of accessor method for task_range_info
setMethod('$', '_p_task_range_info', function(x, name)

{
  accessorFuns = list('ibin_first' = task_range_info_ibin_first_get, 'ibin_last' = task_range_info_ibin_last_get, 'ibin_in_num' = task_range_info_ibin_in_num_get, 'ibin_out_num' = task_range_info_ibin_out_num_get, 'ibin_in_step' = task_range_info_ibin_in_step_get, 'ibin_out_step' = task_range_info_ibin_out_step_get, 'ibin_var' = task_range_info_ibin_var_get, 'ibin_avg' = task_range_info_ibin_avg_get, 'ibin_smooth' = task_range_info_ibin_smooth_get, 'ipad_end' = task_range_info_ipad_end_get)
  vaccessors = c('ibin_first', 'ibin_last', 'ibin_in_num', 'ibin_out_num', 'ibin_in_step', 'ibin_out_step', 'ibin_var', 'ibin_avg', 'ibin_smooth', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_range_info
# Start of accessor method for task_range_info
setMethod('$<-', '_p_task_range_info', function(x, name, value)

{
  accessorFuns = list('ibin_first' = task_range_info_ibin_first_set, 'ibin_last' = task_range_info_ibin_last_set, 'ibin_in_num' = task_range_info_ibin_in_num_set, 'ibin_out_num' = task_range_info_ibin_out_num_set, 'ibin_in_step' = task_range_info_ibin_in_step_set, 'ibin_out_step' = task_range_info_ibin_out_step_set, 'ibin_var' = task_range_info_ibin_var_set, 'ibin_avg' = task_range_info_ibin_avg_set, 'ibin_smooth' = task_range_info_ibin_smooth_set, 'ipad_end' = task_range_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_range_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ibin_first' = task_range_info_ibin_first_set, 'ibin_last' = task_range_info_ibin_last_set, 'ibin_in_num' = task_range_info_ibin_in_num_set, 'ibin_out_num' = task_range_info_ibin_out_num_set, 'ibin_in_step' = task_range_info_ibin_in_step_set, 'ibin_out_step' = task_range_info_ibin_out_step_set, 'ibin_var' = task_range_info_ibin_var_set, 'ibin_avg' = task_range_info_ibin_avg_set, 'ibin_smooth' = task_range_info_ibin_smooth_set, 'ipad_end' = task_range_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_range_info
setMethod('delete', '_p_task_range_info', function(obj) {delete_task_range_info(obj)})
# Start definition of copy functions & methods for task_range_info
CopyToR_task_range_info = function(value, obj = new("task_range_info"))
{
  obj@ibin_first = value$ibin_first
  obj@ibin_last = value$ibin_last
  obj@ibin_in_step = value$ibin_in_step
  obj@ibin_out_step = value$ibin_out_step
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_range_info = function(value, obj)
{
  obj$ibin_first = value@ibin_first
  obj$ibin_last = value@ibin_last
  obj$ibin_in_step = value@ibin_in_step
  obj$ibin_out_step = value@ibin_out_step
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_range_info
setMethod('copyToR', '_p_task_range_info', CopyToR_task_range_info)
setMethod('copyToC', 'task_range_info', CopyToC_task_range_info)

# End definition of copy methods for task_range_info
# End definition of copy functions & methods for task_range_info
# Start of task_scan_info_iscan_set

`task_scan_info_iscan_set` = function(self, s_iscan)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  s_iscan = coerceIfNotSubclass(s_iscan, "_p_unsigned_short") 
  .Call('R_swig_task_scan_info_iscan_set', self, s_iscan, PACKAGE='iris')
  
}

attr(`task_scan_info_iscan_set`, 'returnType') = 'void'
attr(`task_scan_info_iscan_set`, "inputTypes") = c('_p_task_scan_info', '_p_unsigned_short')
class(`task_scan_info_iscan_set`) = c("SWIGFunction", class('task_scan_info_iscan_set'))

# Start of task_scan_info_iscan_get

`task_scan_info_iscan_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  ans = .Call('R_swig_task_scan_info_iscan_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_scan_info_iscan_get`, 'returnType') = '_p_unsigned_short'
attr(`task_scan_info_iscan_get`, "inputTypes") = c('_p_task_scan_info')
class(`task_scan_info_iscan_get`) = c("SWIGFunction", class('task_scan_info_iscan_get'))

# Start of task_scan_info_ires1000_set

`task_scan_info_ires1000_set` = function(self, s_ires1000)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  s_ires1000 = coerceIfNotSubclass(s_ires1000, "_p_short") 
  .Call('R_swig_task_scan_info_ires1000_set', self, s_ires1000, PACKAGE='iris')
  
}

attr(`task_scan_info_ires1000_set`, 'returnType') = 'void'
attr(`task_scan_info_ires1000_set`, "inputTypes") = c('_p_task_scan_info', '_p_short')
class(`task_scan_info_ires1000_set`) = c("SWIGFunction", class('task_scan_info_ires1000_set'))

# Start of task_scan_info_ires1000_get

`task_scan_info_ires1000_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  ans = .Call('R_swig_task_scan_info_ires1000_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_scan_info_ires1000_get`, 'returnType') = '_p_short'
attr(`task_scan_info_ires1000_get`, "inputTypes") = c('_p_task_scan_info')
class(`task_scan_info_ires1000_get`) = c("SWIGFunction", class('task_scan_info_ires1000_get'))

# Start of task_scan_info_iscan_speed_set

`task_scan_info_iscan_speed_set` = function(self, s_iscan_speed)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  s_iscan_speed = coerceIfNotSubclass(s_iscan_speed, "_p_unsigned_short") 
  .Call('R_swig_task_scan_info_iscan_speed_set', self, s_iscan_speed, PACKAGE='iris')
  
}

attr(`task_scan_info_iscan_speed_set`, 'returnType') = 'void'
attr(`task_scan_info_iscan_speed_set`, "inputTypes") = c('_p_task_scan_info', '_p_unsigned_short')
class(`task_scan_info_iscan_speed_set`) = c("SWIGFunction", class('task_scan_info_iscan_speed_set'))

# Start of task_scan_info_iscan_speed_get

`task_scan_info_iscan_speed_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  ans = .Call('R_swig_task_scan_info_iscan_speed_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_scan_info_iscan_speed_get`, 'returnType') = '_p_unsigned_short'
attr(`task_scan_info_iscan_speed_get`, "inputTypes") = c('_p_task_scan_info')
class(`task_scan_info_iscan_speed_get`) = c("SWIGFunction", class('task_scan_info_iscan_speed_get'))

# Start of task_scan_info_isweeps_set

`task_scan_info_isweeps_set` = function(self, s_isweeps)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  s_isweeps = coerceIfNotSubclass(s_isweeps, "_p_short") 
  .Call('R_swig_task_scan_info_isweeps_set', self, s_isweeps, PACKAGE='iris')
  
}

attr(`task_scan_info_isweeps_set`, 'returnType') = 'void'
attr(`task_scan_info_isweeps_set`, "inputTypes") = c('_p_task_scan_info', '_p_short')
class(`task_scan_info_isweeps_set`) = c("SWIGFunction", class('task_scan_info_isweeps_set'))

# Start of task_scan_info_isweeps_get

`task_scan_info_isweeps_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  ans = .Call('R_swig_task_scan_info_isweeps_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_scan_info_isweeps_get`, 'returnType') = '_p_short'
attr(`task_scan_info_isweeps_get`, "inputTypes") = c('_p_task_scan_info')
class(`task_scan_info_isweeps_get`) = c("SWIGFunction", class('task_scan_info_isweeps_get'))

# Start of task_scan_info_u_set

`task_scan_info_u_set` = function(self, s_u)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  s_u = coerceIfNotSubclass(s_u, "_p_task_scan_info_u") 
  .Call('R_swig_task_scan_info_u_set', self, s_u, PACKAGE='iris')
  
}

attr(`task_scan_info_u_set`, 'returnType') = 'void'
attr(`task_scan_info_u_set`, "inputTypes") = c('_p_task_scan_info', '_p_task_scan_info_u')
class(`task_scan_info_u_set`) = c("SWIGFunction", class('task_scan_info_u_set'))

# Start of task_scan_info_u_get

`task_scan_info_u_get` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  ans = .Call('R_swig_task_scan_info_u_get', self, PACKAGE='iris')
  class(ans) <- "_p_task_scan_info_u"
  
  ans
  
}

attr(`task_scan_info_u_get`, 'returnType') = '_p_task_scan_info_u'
attr(`task_scan_info_u_get`, "inputTypes") = c('_p_task_scan_info')
class(`task_scan_info_u_get`) = c("SWIGFunction", class('task_scan_info_u_get'))

# Start of task_scan_info_ipad_end_set

`task_scan_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (112))
  
  .Call('R_swig_task_scan_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_scan_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_scan_info_ipad_end_set`, "inputTypes") = c('_p_task_scan_info', '_p_char')
class(`task_scan_info_ipad_end_set`) = c("SWIGFunction", class('task_scan_info_ipad_end_set'))

# Start of task_scan_info_ipad_end_get

`task_scan_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  ans = .Call('R_swig_task_scan_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_scan_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_scan_info_ipad_end_get`, "inputTypes") = c('_p_task_scan_info')
class(`task_scan_info_ipad_end_get`) = c("SWIGFunction", class('task_scan_info_ipad_end_get'))

# Start of new_task_scan_info

`task_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_scan_info"
  
  ans
  
}

attr(`task_scan_info`, 'returnType') = '_p_task_scan_info'
class(`task_scan_info`) = c("SWIGFunction", class('task_scan_info'))

# Start of delete_task_scan_info

`delete_task_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_scan_info") 
  .Call('R_swig_delete_task_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_task_scan_info`, 'returnType') = 'void'
attr(`delete_task_scan_info`, "inputTypes") = c('_p_task_scan_info')
class(`delete_task_scan_info`) = c("SWIGFunction", class('delete_task_scan_info'))

# Start of accessor method for task_scan_info
setMethod('$', '_p_task_scan_info', function(x, name)

{
  accessorFuns = list('iscan' = task_scan_info_iscan_get, 'ires1000' = task_scan_info_ires1000_get, 'iscan_speed' = task_scan_info_iscan_speed_get, 'isweeps' = task_scan_info_isweeps_get, 'u' = task_scan_info_u_get, 'ipad_end' = task_scan_info_ipad_end_get)
  vaccessors = c('iscan', 'ires1000', 'iscan_speed', 'isweeps', 'u', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_scan_info
# Start of accessor method for task_scan_info
setMethod('$<-', '_p_task_scan_info', function(x, name, value)

{
  accessorFuns = list('iscan' = task_scan_info_iscan_set, 'ires1000' = task_scan_info_ires1000_set, 'iscan_speed' = task_scan_info_iscan_speed_set, 'isweeps' = task_scan_info_isweeps_set, 'u' = task_scan_info_u_set, 'ipad_end' = task_scan_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iscan' = task_scan_info_iscan_set, 'ires1000' = task_scan_info_ires1000_set, 'iscan_speed' = task_scan_info_iscan_speed_set, 'isweeps' = task_scan_info_isweeps_set, 'u' = task_scan_info_u_set, 'ipad_end' = task_scan_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_scan_info
setMethod('delete', '_p_task_scan_info', function(obj) {delete_task_scan_info(obj)})
# Start definition of copy functions & methods for task_scan_info
CopyToR_task_scan_info = function(value, obj = new("task_scan_info"))
{
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_scan_info = function(value, obj)
{
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_scan_info
setMethod('copyToR', '_p_task_scan_info', CopyToR_task_scan_info)
setMethod('copyToC', 'task_scan_info', CopyToC_task_scan_info)

# End definition of copy methods for task_scan_info
# End definition of copy functions & methods for task_scan_info
# Start of serv_task_scan_info_u_rhi_set

`serv_task_scan_info_u_rhi_set` = function(self, s_rhi)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  s_rhi = coerceIfNotSubclass(s_rhi, "_p_serv_task_rhi_scan_info") 
  .Call('R_swig_serv_task_scan_info_u_rhi_set', self, s_rhi, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_u_rhi_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_u_rhi_set`, "inputTypes") = c('_p_serv_task_scan_info_u', '_p_serv_task_rhi_scan_info')
class(`serv_task_scan_info_u_rhi_set`) = c("SWIGFunction", class('serv_task_scan_info_u_rhi_set'))

# Start of serv_task_scan_info_u_rhi_get

`serv_task_scan_info_u_rhi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  ans = .Call('R_swig_serv_task_scan_info_u_rhi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_rhi_scan_info"
  
  ans
  
}

attr(`serv_task_scan_info_u_rhi_get`, 'returnType') = '_p_serv_task_rhi_scan_info'
attr(`serv_task_scan_info_u_rhi_get`, "inputTypes") = c('_p_serv_task_scan_info_u')
class(`serv_task_scan_info_u_rhi_get`) = c("SWIGFunction", class('serv_task_scan_info_u_rhi_get'))

# Start of serv_task_scan_info_u_ppi_set

`serv_task_scan_info_u_ppi_set` = function(self, s_ppi)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  s_ppi = coerceIfNotSubclass(s_ppi, "_p_serv_task_ppi_scan_info") 
  .Call('R_swig_serv_task_scan_info_u_ppi_set', self, s_ppi, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_u_ppi_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_u_ppi_set`, "inputTypes") = c('_p_serv_task_scan_info_u', '_p_serv_task_ppi_scan_info')
class(`serv_task_scan_info_u_ppi_set`) = c("SWIGFunction", class('serv_task_scan_info_u_ppi_set'))

# Start of serv_task_scan_info_u_ppi_get

`serv_task_scan_info_u_ppi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  ans = .Call('R_swig_serv_task_scan_info_u_ppi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_ppi_scan_info"
  
  ans
  
}

attr(`serv_task_scan_info_u_ppi_get`, 'returnType') = '_p_serv_task_ppi_scan_info'
attr(`serv_task_scan_info_u_ppi_get`, "inputTypes") = c('_p_serv_task_scan_info_u')
class(`serv_task_scan_info_u_ppi_get`) = c("SWIGFunction", class('serv_task_scan_info_u_ppi_get'))

# Start of serv_task_scan_info_u_fil_set

`serv_task_scan_info_u_fil_set` = function(self, s_fil)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  s_fil = coerceIfNotSubclass(s_fil, "_p_serv_task_file_scan_info") 
  .Call('R_swig_serv_task_scan_info_u_fil_set', self, s_fil, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_u_fil_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_u_fil_set`, "inputTypes") = c('_p_serv_task_scan_info_u', '_p_serv_task_file_scan_info')
class(`serv_task_scan_info_u_fil_set`) = c("SWIGFunction", class('serv_task_scan_info_u_fil_set'))

# Start of serv_task_scan_info_u_fil_get

`serv_task_scan_info_u_fil_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  ans = .Call('R_swig_serv_task_scan_info_u_fil_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_file_scan_info"
  
  ans
  
}

attr(`serv_task_scan_info_u_fil_get`, 'returnType') = '_p_serv_task_file_scan_info'
attr(`serv_task_scan_info_u_fil_get`, "inputTypes") = c('_p_serv_task_scan_info_u')
class(`serv_task_scan_info_u_fil_get`) = c("SWIGFunction", class('serv_task_scan_info_u_fil_get'))

# Start of serv_task_scan_info_u_man_set

`serv_task_scan_info_u_man_set` = function(self, s_man)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  s_man = coerceIfNotSubclass(s_man, "_p_serv_task_manual_scan_info") 
  .Call('R_swig_serv_task_scan_info_u_man_set', self, s_man, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_u_man_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_u_man_set`, "inputTypes") = c('_p_serv_task_scan_info_u', '_p_serv_task_manual_scan_info')
class(`serv_task_scan_info_u_man_set`) = c("SWIGFunction", class('serv_task_scan_info_u_man_set'))

# Start of serv_task_scan_info_u_man_get

`serv_task_scan_info_u_man_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  ans = .Call('R_swig_serv_task_scan_info_u_man_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_manual_scan_info"
  
  ans
  
}

attr(`serv_task_scan_info_u_man_get`, 'returnType') = '_p_serv_task_manual_scan_info'
attr(`serv_task_scan_info_u_man_get`, "inputTypes") = c('_p_serv_task_scan_info_u')
class(`serv_task_scan_info_u_man_get`) = c("SWIGFunction", class('serv_task_scan_info_u_man_get'))

# Start of serv_task_scan_info_u_exec_set

`serv_task_scan_info_u_exec_set` = function(self, s_exec)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  s_exec = coerceIfNotSubclass(s_exec, "_p_task_exec_scan_info") 
  .Call('R_swig_serv_task_scan_info_u_exec_set', self, s_exec, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_u_exec_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_u_exec_set`, "inputTypes") = c('_p_serv_task_scan_info_u', '_p_task_exec_scan_info')
class(`serv_task_scan_info_u_exec_set`) = c("SWIGFunction", class('serv_task_scan_info_u_exec_set'))

# Start of serv_task_scan_info_u_exec_get

`serv_task_scan_info_u_exec_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  ans = .Call('R_swig_serv_task_scan_info_u_exec_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_exec_scan_info"
  
  ans
  
}

attr(`serv_task_scan_info_u_exec_get`, 'returnType') = '_p_task_exec_scan_info'
attr(`serv_task_scan_info_u_exec_get`, "inputTypes") = c('_p_serv_task_scan_info_u')
class(`serv_task_scan_info_u_exec_get`) = c("SWIGFunction", class('serv_task_scan_info_u_exec_get'))

# Start of new_serv_task_scan_info_u

`serv_task_scan_info_u` = function()
{
  ans = .Call('R_swig_new_serv_task_scan_info_u', PACKAGE='iris')
  class(ans) <- "_p_serv_task_scan_info_u"
  
  ans
  
}

attr(`serv_task_scan_info_u`, 'returnType') = '_p_serv_task_scan_info_u'
class(`serv_task_scan_info_u`) = c("SWIGFunction", class('serv_task_scan_info_u'))

# Start of delete_serv_task_scan_info_u

`delete_serv_task_scan_info_u` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info_u") 
  .Call('R_swig_delete_serv_task_scan_info_u', self, PACKAGE='iris')
  
}

attr(`delete_serv_task_scan_info_u`, 'returnType') = 'void'
attr(`delete_serv_task_scan_info_u`, "inputTypes") = c('_p_serv_task_scan_info_u')
class(`delete_serv_task_scan_info_u`) = c("SWIGFunction", class('delete_serv_task_scan_info_u'))

# Start of accessor method for serv_task_scan_info_u
setMethod('$', '_p_serv_task_scan_info_u', function(x, name)

{
  accessorFuns = list('rhi' = serv_task_scan_info_u_rhi_get, 'ppi' = serv_task_scan_info_u_ppi_get, 'fil' = serv_task_scan_info_u_fil_get, 'man' = serv_task_scan_info_u_man_get, 'exec' = serv_task_scan_info_u_exec_get)
  vaccessors = c('rhi', 'ppi', 'fil', 'man', 'exec')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for serv_task_scan_info_u
# Start of accessor method for serv_task_scan_info_u
setMethod('$<-', '_p_serv_task_scan_info_u', function(x, name, value)

{
  accessorFuns = list('rhi' = serv_task_scan_info_u_rhi_set, 'ppi' = serv_task_scan_info_u_ppi_set, 'fil' = serv_task_scan_info_u_fil_set, 'man' = serv_task_scan_info_u_man_set, 'exec' = serv_task_scan_info_u_exec_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_serv_task_scan_info_u', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('rhi' = serv_task_scan_info_u_rhi_set, 'ppi' = serv_task_scan_info_u_ppi_set, 'fil' = serv_task_scan_info_u_fil_set, 'man' = serv_task_scan_info_u_man_set, 'exec' = serv_task_scan_info_u_exec_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for serv_task_scan_info_u
setMethod('delete', '_p_serv_task_scan_info_u', function(obj) {delete_serv_task_scan_info_u(obj)})
# Start of serv_task_scan_info_iscan_set

`serv_task_scan_info_iscan_set` = function(self, s_iscan)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  s_iscan = as.numeric(s_iscan) 
  
  assert(length(s_iscan) == 1 && s_iscan >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_scan_info_iscan_set', self, s_iscan, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_iscan_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_iscan_set`, "inputTypes") = c('_p_serv_task_scan_info', 'numeric')
class(`serv_task_scan_info_iscan_set`) = c("SWIGFunction", class('serv_task_scan_info_iscan_set'))

# Start of serv_task_scan_info_iscan_get

`serv_task_scan_info_iscan_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  .Call('R_swig_serv_task_scan_info_iscan_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_scan_info_iscan_get`, 'returnType') = 'numeric'
attr(`serv_task_scan_info_iscan_get`, "inputTypes") = c('_p_serv_task_scan_info')
class(`serv_task_scan_info_iscan_get`) = c("SWIGFunction", class('serv_task_scan_info_iscan_get'))

# Start of serv_task_scan_info_ires1000_set

`serv_task_scan_info_ires1000_set` = function(self, s_ires1000)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  s_ires1000 = as.integer(s_ires1000) 
  
  if(length(s_ires1000) > 1) {
    Rf_warning("using only the first element of s_ires1000")
  }
  
  .Call('R_swig_serv_task_scan_info_ires1000_set', self, s_ires1000, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_ires1000_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_ires1000_set`, "inputTypes") = c('_p_serv_task_scan_info', 'numeric')
class(`serv_task_scan_info_ires1000_set`) = c("SWIGFunction", class('serv_task_scan_info_ires1000_set'))

# Start of serv_task_scan_info_ires1000_get

`serv_task_scan_info_ires1000_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  .Call('R_swig_serv_task_scan_info_ires1000_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_scan_info_ires1000_get`, 'returnType') = 'numeric'
attr(`serv_task_scan_info_ires1000_get`, "inputTypes") = c('_p_serv_task_scan_info')
class(`serv_task_scan_info_ires1000_get`) = c("SWIGFunction", class('serv_task_scan_info_ires1000_get'))

# Start of serv_task_scan_info_iscan_speed_set

`serv_task_scan_info_iscan_speed_set` = function(self, s_iscan_speed)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  s_iscan_speed = as.numeric(s_iscan_speed) 
  
  assert(length(s_iscan_speed) == 1 && s_iscan_speed >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_scan_info_iscan_speed_set', self, s_iscan_speed, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_iscan_speed_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_iscan_speed_set`, "inputTypes") = c('_p_serv_task_scan_info', 'numeric')
class(`serv_task_scan_info_iscan_speed_set`) = c("SWIGFunction", class('serv_task_scan_info_iscan_speed_set'))

# Start of serv_task_scan_info_iscan_speed_get

`serv_task_scan_info_iscan_speed_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  .Call('R_swig_serv_task_scan_info_iscan_speed_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_scan_info_iscan_speed_get`, 'returnType') = 'numeric'
attr(`serv_task_scan_info_iscan_speed_get`, "inputTypes") = c('_p_serv_task_scan_info')
class(`serv_task_scan_info_iscan_speed_get`) = c("SWIGFunction", class('serv_task_scan_info_iscan_speed_get'))

# Start of serv_task_scan_info_isweeps_set

`serv_task_scan_info_isweeps_set` = function(self, s_isweeps)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  s_isweeps = as.integer(s_isweeps) 
  
  if(length(s_isweeps) > 1) {
    Rf_warning("using only the first element of s_isweeps")
  }
  
  .Call('R_swig_serv_task_scan_info_isweeps_set', self, s_isweeps, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_isweeps_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_isweeps_set`, "inputTypes") = c('_p_serv_task_scan_info', 'numeric')
class(`serv_task_scan_info_isweeps_set`) = c("SWIGFunction", class('serv_task_scan_info_isweeps_set'))

# Start of serv_task_scan_info_isweeps_get

`serv_task_scan_info_isweeps_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  .Call('R_swig_serv_task_scan_info_isweeps_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_scan_info_isweeps_get`, 'returnType') = 'numeric'
attr(`serv_task_scan_info_isweeps_get`, "inputTypes") = c('_p_serv_task_scan_info')
class(`serv_task_scan_info_isweeps_get`) = c("SWIGFunction", class('serv_task_scan_info_isweeps_get'))

# Start of serv_task_scan_info_u_set

`serv_task_scan_info_u_set` = function(self, s_u)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  s_u = coerceIfNotSubclass(s_u, "_p_serv_task_scan_info_u") 
  .Call('R_swig_serv_task_scan_info_u_set', self, s_u, PACKAGE='iris')
  
}

attr(`serv_task_scan_info_u_set`, 'returnType') = 'void'
attr(`serv_task_scan_info_u_set`, "inputTypes") = c('_p_serv_task_scan_info', '_p_serv_task_scan_info_u')
class(`serv_task_scan_info_u_set`) = c("SWIGFunction", class('serv_task_scan_info_u_set'))

# Start of serv_task_scan_info_u_get

`serv_task_scan_info_u_get` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  ans = .Call('R_swig_serv_task_scan_info_u_get', self, PACKAGE='iris')
  class(ans) <- "_p_serv_task_scan_info_u"
  
  ans
  
}

attr(`serv_task_scan_info_u_get`, 'returnType') = '_p_serv_task_scan_info_u'
attr(`serv_task_scan_info_u_get`, "inputTypes") = c('_p_serv_task_scan_info')
class(`serv_task_scan_info_u_get`) = c("SWIGFunction", class('serv_task_scan_info_u_get'))

# Start of new_serv_task_scan_info

`serv_task_scan_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_serv_task_scan_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_scan_info"
  
  ans
  
}

attr(`serv_task_scan_info`, 'returnType') = '_p_serv_task_scan_info'
class(`serv_task_scan_info`) = c("SWIGFunction", class('serv_task_scan_info'))

# Start of delete_serv_task_scan_info

`delete_serv_task_scan_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_scan_info") 
  .Call('R_swig_delete_serv_task_scan_info', self, PACKAGE='iris')
  
}

attr(`delete_serv_task_scan_info`, 'returnType') = 'void'
attr(`delete_serv_task_scan_info`, "inputTypes") = c('_p_serv_task_scan_info')
class(`delete_serv_task_scan_info`) = c("SWIGFunction", class('delete_serv_task_scan_info'))

# Start of accessor method for serv_task_scan_info
setMethod('$', '_p_serv_task_scan_info', function(x, name)

{
  accessorFuns = list('iscan' = serv_task_scan_info_iscan_get, 'ires1000' = serv_task_scan_info_ires1000_get, 'iscan_speed' = serv_task_scan_info_iscan_speed_get, 'isweeps' = serv_task_scan_info_isweeps_get, 'u' = serv_task_scan_info_u_get)
  vaccessors = c('iscan', 'ires1000', 'iscan_speed', 'isweeps', 'u')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for serv_task_scan_info
# Start of accessor method for serv_task_scan_info
setMethod('$<-', '_p_serv_task_scan_info', function(x, name, value)

{
  accessorFuns = list('iscan' = serv_task_scan_info_iscan_set, 'ires1000' = serv_task_scan_info_ires1000_set, 'iscan_speed' = serv_task_scan_info_iscan_speed_set, 'isweeps' = serv_task_scan_info_isweeps_set, 'u' = serv_task_scan_info_u_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_serv_task_scan_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iscan' = serv_task_scan_info_iscan_set, 'ires1000' = serv_task_scan_info_ires1000_set, 'iscan_speed' = serv_task_scan_info_iscan_speed_set, 'isweeps' = serv_task_scan_info_isweeps_set, 'u' = serv_task_scan_info_u_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for serv_task_scan_info
setMethod('delete', '_p_serv_task_scan_info', function(obj) {delete_serv_task_scan_info(obj)})
# Start definition of copy functions & methods for serv_task_scan_info
CopyToR_serv_task_scan_info = function(value, obj = new("serv_task_scan_info"))
{
  obj@iscan = value$iscan
  obj@ires1000 = value$ires1000
  obj@iscan_speed = value$iscan_speed
  obj@isweeps = value$isweeps
  obj
}



CopyToC_serv_task_scan_info = function(value, obj)
{
  obj$iscan = value@iscan
  obj$ires1000 = value@ires1000
  obj$iscan_speed = value@iscan_speed
  obj$isweeps = value@isweeps
  obj
}



# Start definition of copy methods for serv_task_scan_info
setMethod('copyToR', '_p_serv_task_scan_info', CopyToR_serv_task_scan_info)
setMethod('copyToC', 'serv_task_scan_info', CopyToC_serv_task_scan_info)

# End definition of copy methods for serv_task_scan_info
# End definition of copy functions & methods for serv_task_scan_info
# Start of product_end_sprod_sitename_set

`product_end_sprod_sitename_set` = function(self, s_sprod_sitename)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_sprod_sitename))
  assert(all(sapply(s_sprod_sitename, class) == "_p_char"))     
  
  
#  assert(length(s_sprod_sitename) >= 16)
  
  .Call('R_swig_product_end_sprod_sitename_set', self, s_sprod_sitename, PACKAGE='iris')
  
}

attr(`product_end_sprod_sitename_set`, 'returnType') = 'void'
attr(`product_end_sprod_sitename_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_sprod_sitename_set`) = c("SWIGFunction", class('product_end_sprod_sitename_set'))

# Start of product_end_sprod_sitename_get

`product_end_sprod_sitename_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_sprod_sitename_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_sprod_sitename_get`, 'returnType') = '_p_char'
attr(`product_end_sprod_sitename_get`, "inputTypes") = c('_p_product_end')
class(`product_end_sprod_sitename_get`) = c("SWIGFunction", class('product_end_sprod_sitename_get'))

# Start of product_end_sprod_version_set

`product_end_sprod_version_set` = function(self, s_sprod_version)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_sprod_version))
  assert(all(sapply(s_sprod_version, class) == "_p_char"))     
  
  
#  assert(length(s_sprod_version) >= 8)
  
  .Call('R_swig_product_end_sprod_version_set', self, s_sprod_version, PACKAGE='iris')
  
}

attr(`product_end_sprod_version_set`, 'returnType') = 'void'
attr(`product_end_sprod_version_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_sprod_version_set`) = c("SWIGFunction", class('product_end_sprod_version_set'))

# Start of product_end_sprod_version_get

`product_end_sprod_version_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_sprod_version_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_sprod_version_get`, 'returnType') = '_p_char'
attr(`product_end_sprod_version_get`, "inputTypes") = c('_p_product_end')
class(`product_end_sprod_version_get`) = c("SWIGFunction", class('product_end_sprod_version_get'))

# Start of product_end_sing_version_set

`product_end_sing_version_set` = function(self, s_sing_version)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_sing_version))
  assert(all(sapply(s_sing_version, class) == "_p_char"))     
  
  
#  assert(length(s_sing_version) >= 8)
  
  .Call('R_swig_product_end_sing_version_set', self, s_sing_version, PACKAGE='iris')
  
}

attr(`product_end_sing_version_set`, 'returnType') = 'void'
attr(`product_end_sing_version_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_sing_version_set`) = c("SWIGFunction", class('product_end_sing_version_set'))

# Start of product_end_sing_version_get

`product_end_sing_version_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_sing_version_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_sing_version_get`, 'returnType') = '_p_char'
attr(`product_end_sing_version_get`, "inputTypes") = c('_p_product_end')
class(`product_end_sing_version_get`) = c("SWIGFunction", class('product_end_sing_version_get'))

# Start of product_end_old_ing_set

`product_end_old_ing_set` = function(self, s_old_ing)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_old_ing = coerceIfNotSubclass(s_old_ing, "_p_ymds_time") 
  .Call('R_swig_product_end_old_ing_set', self, s_old_ing, PACKAGE='iris')
  
}

attr(`product_end_old_ing_set`, 'returnType') = 'void'
attr(`product_end_old_ing_set`, "inputTypes") = c('_p_product_end', '_p_ymds_time')
class(`product_end_old_ing_set`) = c("SWIGFunction", class('product_end_old_ing_set'))

# Start of product_end_old_ing_get

`product_end_old_ing_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_old_ing_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`product_end_old_ing_get`, 'returnType') = '_p_ymds_time'
attr(`product_end_old_ing_get`, "inputTypes") = c('_p_product_end')
class(`product_end_old_ing_get`) = c("SWIGFunction", class('product_end_old_ing_get'))

# Start of product_end_ipad44x28_set

`product_end_ipad44x28_set` = function(self, s_ipad44x28)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_ipad44x28))
  assert(all(sapply(s_ipad44x28, class) == "_p_char"))     
  
  
#  assert(length(s_ipad44x28) >= 28)
  
  .Call('R_swig_product_end_ipad44x28_set', self, s_ipad44x28, PACKAGE='iris')
  
}

attr(`product_end_ipad44x28_set`, 'returnType') = 'void'
attr(`product_end_ipad44x28_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_ipad44x28_set`) = c("SWIGFunction", class('product_end_ipad44x28_set'))

# Start of product_end_ipad44x28_get

`product_end_ipad44x28_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_ipad44x28_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_ipad44x28_get`, 'returnType') = '_p_char'
attr(`product_end_ipad44x28_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ipad44x28_get`) = c("SWIGFunction", class('product_end_ipad44x28_get'))

# Start of product_end_iLocalWest_set

`product_end_iLocalWest_set` = function(self, s_iLocalWest)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iLocalWest = coerceIfNotSubclass(s_iLocalWest, "_p_short") 
  .Call('R_swig_product_end_iLocalWest_set', self, s_iLocalWest, PACKAGE='iris')
  
}

attr(`product_end_iLocalWest_set`, 'returnType') = 'void'
attr(`product_end_iLocalWest_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iLocalWest_set`) = c("SWIGFunction", class('product_end_iLocalWest_set'))

# Start of product_end_iLocalWest_get

`product_end_iLocalWest_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iLocalWest_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iLocalWest_get`, 'returnType') = '_p_short'
attr(`product_end_iLocalWest_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iLocalWest_get`) = c("SWIGFunction", class('product_end_iLocalWest_get'))

# Start of product_end_sIngHardwareName_set

`product_end_sIngHardwareName_set` = function(self, s_sIngHardwareName)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_sIngHardwareName))
  assert(all(sapply(s_sIngHardwareName, class) == "_p_char"))     
  
  
#  assert(length(s_sIngHardwareName) >= 16)
  
  .Call('R_swig_product_end_sIngHardwareName_set', self, s_sIngHardwareName, PACKAGE='iris')
  
}

attr(`product_end_sIngHardwareName_set`, 'returnType') = 'void'
attr(`product_end_sIngHardwareName_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_sIngHardwareName_set`) = c("SWIGFunction", class('product_end_sIngHardwareName_set'))

# Start of product_end_sIngHardwareName_get

`product_end_sIngHardwareName_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_sIngHardwareName_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_sIngHardwareName_get`, 'returnType') = '_p_char'
attr(`product_end_sIngHardwareName_get`, "inputTypes") = c('_p_product_end')
class(`product_end_sIngHardwareName_get`) = c("SWIGFunction", class('product_end_sIngHardwareName_get'))

# Start of product_end_sing_sitename_set

`product_end_sing_sitename_set` = function(self, s_sing_sitename)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_sing_sitename))
  assert(all(sapply(s_sing_sitename, class) == "_p_char"))     
  
  
#  assert(length(s_sing_sitename) >= 16)
  
  .Call('R_swig_product_end_sing_sitename_set', self, s_sing_sitename, PACKAGE='iris')
  
}

attr(`product_end_sing_sitename_set`, 'returnType') = 'void'
attr(`product_end_sing_sitename_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_sing_sitename_set`) = c("SWIGFunction", class('product_end_sing_sitename_set'))

# Start of product_end_sing_sitename_get

`product_end_sing_sitename_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_sing_sitename_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_sing_sitename_get`, 'returnType') = '_p_char'
attr(`product_end_sing_sitename_get`, "inputTypes") = c('_p_product_end')
class(`product_end_sing_sitename_get`) = c("SWIGFunction", class('product_end_sing_sitename_get'))

# Start of product_end_iMinutesWest_set

`product_end_iMinutesWest_set` = function(self, s_iMinutesWest)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iMinutesWest = coerceIfNotSubclass(s_iMinutesWest, "_p_short") 
  .Call('R_swig_product_end_iMinutesWest_set', self, s_iMinutesWest, PACKAGE='iris')
  
}

attr(`product_end_iMinutesWest_set`, 'returnType') = 'void'
attr(`product_end_iMinutesWest_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iMinutesWest_set`) = c("SWIGFunction", class('product_end_iMinutesWest_set'))

# Start of product_end_iMinutesWest_get

`product_end_iMinutesWest_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iMinutesWest_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iMinutesWest_get`, 'returnType') = '_p_short'
attr(`product_end_iMinutesWest_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iMinutesWest_get`) = c("SWIGFunction", class('product_end_iMinutesWest_get'))

# Start of product_end_ilat_center_set

`product_end_ilat_center_set` = function(self, s_ilat_center)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ilat_center = as.numeric(s_ilat_center) 
  
  assert(length(s_ilat_center) == 1 && s_ilat_center >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_ilat_center_set', self, s_ilat_center, PACKAGE='iris')
  
}

attr(`product_end_ilat_center_set`, 'returnType') = 'void'
attr(`product_end_ilat_center_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ilat_center_set`) = c("SWIGFunction", class('product_end_ilat_center_set'))

# Start of product_end_ilat_center_get

`product_end_ilat_center_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ilat_center_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ilat_center_get`, 'returnType') = 'numeric'
attr(`product_end_ilat_center_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ilat_center_get`) = c("SWIGFunction", class('product_end_ilat_center_get'))

# Start of product_end_ilon_center_set

`product_end_ilon_center_set` = function(self, s_ilon_center)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ilon_center = as.numeric(s_ilon_center) 
  
  assert(length(s_ilon_center) == 1 && s_ilon_center >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_ilon_center_set', self, s_ilon_center, PACKAGE='iris')
  
}

attr(`product_end_ilon_center_set`, 'returnType') = 'void'
attr(`product_end_ilon_center_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ilon_center_set`) = c("SWIGFunction", class('product_end_ilon_center_set'))

# Start of product_end_ilon_center_get

`product_end_ilon_center_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ilon_center_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ilon_center_get`, 'returnType') = 'numeric'
attr(`product_end_ilon_center_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ilon_center_get`) = c("SWIGFunction", class('product_end_ilon_center_get'))

# Start of product_end_ignd_hgt_set

`product_end_ignd_hgt_set` = function(self, s_ignd_hgt)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ignd_hgt = coerceIfNotSubclass(s_ignd_hgt, "_p_short") 
  .Call('R_swig_product_end_ignd_hgt_set', self, s_ignd_hgt, PACKAGE='iris')
  
}

attr(`product_end_ignd_hgt_set`, 'returnType') = 'void'
attr(`product_end_ignd_hgt_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_ignd_hgt_set`) = c("SWIGFunction", class('product_end_ignd_hgt_set'))

# Start of product_end_ignd_hgt_get

`product_end_ignd_hgt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_ignd_hgt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_ignd_hgt_get`, 'returnType') = '_p_short'
attr(`product_end_ignd_hgt_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ignd_hgt_get`) = c("SWIGFunction", class('product_end_ignd_hgt_get'))

# Start of product_end_irad_hgt_set

`product_end_irad_hgt_set` = function(self, s_irad_hgt)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_irad_hgt = coerceIfNotSubclass(s_irad_hgt, "_p_short") 
  .Call('R_swig_product_end_irad_hgt_set', self, s_irad_hgt, PACKAGE='iris')
  
}

attr(`product_end_irad_hgt_set`, 'returnType') = 'void'
attr(`product_end_irad_hgt_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_irad_hgt_set`) = c("SWIGFunction", class('product_end_irad_hgt_set'))

# Start of product_end_irad_hgt_get

`product_end_irad_hgt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_irad_hgt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_irad_hgt_get`, 'returnType') = '_p_short'
attr(`product_end_irad_hgt_get`, "inputTypes") = c('_p_product_end')
class(`product_end_irad_hgt_get`) = c("SWIGFunction", class('product_end_irad_hgt_get'))

# Start of product_end_iprf_set

`product_end_iprf_set` = function(self, s_iprf)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iprf = as.integer(s_iprf) 
  
  if(length(s_iprf) > 1) {
    Rf_warning("using only the first element of s_iprf")
  }
  
  .Call('R_swig_product_end_iprf_set', self, s_iprf, PACKAGE='iris')
  
}

attr(`product_end_iprf_set`, 'returnType') = 'void'
attr(`product_end_iprf_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_iprf_set`) = c("SWIGFunction", class('product_end_iprf_set'))

# Start of product_end_iprf_get

`product_end_iprf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_iprf_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_iprf_get`, 'returnType') = 'numeric'
attr(`product_end_iprf_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iprf_get`) = c("SWIGFunction", class('product_end_iprf_get'))

# Start of product_end_ipw_set

`product_end_ipw_set` = function(self, s_ipw)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ipw = as.integer(s_ipw) 
  
  if(length(s_ipw) > 1) {
    Rf_warning("using only the first element of s_ipw")
  }
  
  .Call('R_swig_product_end_ipw_set', self, s_ipw, PACKAGE='iris')
  
}

attr(`product_end_ipw_set`, 'returnType') = 'void'
attr(`product_end_ipw_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ipw_set`) = c("SWIGFunction", class('product_end_ipw_set'))

# Start of product_end_ipw_get

`product_end_ipw_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ipw_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ipw_get`, 'returnType') = 'numeric'
attr(`product_end_ipw_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ipw_get`) = c("SWIGFunction", class('product_end_ipw_get'))

# Start of product_end_idsptype_set

`product_end_idsptype_set` = function(self, s_idsptype)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_idsptype = coerceIfNotSubclass(s_idsptype, "_p_unsigned_short") 
  .Call('R_swig_product_end_idsptype_set', self, s_idsptype, PACKAGE='iris')
  
}

attr(`product_end_idsptype_set`, 'returnType') = 'void'
attr(`product_end_idsptype_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_idsptype_set`) = c("SWIGFunction", class('product_end_idsptype_set'))

# Start of product_end_idsptype_get

`product_end_idsptype_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_idsptype_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_idsptype_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_idsptype_get`, "inputTypes") = c('_p_product_end')
class(`product_end_idsptype_get`) = c("SWIGFunction", class('product_end_idsptype_get'))

# Start of product_end_itrig_set

`product_end_itrig_set` = function(self, s_itrig)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_itrig = coerceIfNotSubclass(s_itrig, "_p_unsigned_short") 
  .Call('R_swig_product_end_itrig_set', self, s_itrig, PACKAGE='iris')
  
}

attr(`product_end_itrig_set`, 'returnType') = 'void'
attr(`product_end_itrig_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_itrig_set`) = c("SWIGFunction", class('product_end_itrig_set'))

# Start of product_end_itrig_get

`product_end_itrig_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_itrig_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_itrig_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_itrig_get`, "inputTypes") = c('_p_product_end')
class(`product_end_itrig_get`) = c("SWIGFunction", class('product_end_itrig_get'))

# Start of product_end_isamp_set

`product_end_isamp_set` = function(self, s_isamp)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_isamp = coerceIfNotSubclass(s_isamp, "_p_short") 
  .Call('R_swig_product_end_isamp_set', self, s_isamp, PACKAGE='iris')
  
}

attr(`product_end_isamp_set`, 'returnType') = 'void'
attr(`product_end_isamp_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_isamp_set`) = c("SWIGFunction", class('product_end_isamp_set'))

# Start of product_end_isamp_get

`product_end_isamp_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_isamp_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_isamp_get`, 'returnType') = '_p_short'
attr(`product_end_isamp_get`, "inputTypes") = c('_p_product_end')
class(`product_end_isamp_get`) = c("SWIGFunction", class('product_end_isamp_get'))

# Start of product_end_sfilter_set

`product_end_sfilter_set` = function(self, s_sfilter)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_sfilter))
  assert(all(sapply(s_sfilter, class) == "_p_char"))     
  
  
#  assert(length(s_sfilter) >= 12)
  
  .Call('R_swig_product_end_sfilter_set', self, s_sfilter, PACKAGE='iris')
  
}

attr(`product_end_sfilter_set`, 'returnType') = 'void'
attr(`product_end_sfilter_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_sfilter_set`) = c("SWIGFunction", class('product_end_sfilter_set'))

# Start of product_end_sfilter_get

`product_end_sfilter_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_sfilter_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_sfilter_get`, 'returnType') = '_p_char'
attr(`product_end_sfilter_get`, "inputTypes") = c('_p_product_end')
class(`product_end_sfilter_get`) = c("SWIGFunction", class('product_end_sfilter_get'))

# Start of product_end_idop_filter_first_set

`product_end_idop_filter_first_set` = function(self, s_idop_filter_first)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_idop_filter_first = coerceIfNotSubclass(s_idop_filter_first, "_p_unsigned_short") 
  .Call('R_swig_product_end_idop_filter_first_set', self, s_idop_filter_first, PACKAGE='iris')
  
}

attr(`product_end_idop_filter_first_set`, 'returnType') = 'void'
attr(`product_end_idop_filter_first_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_idop_filter_first_set`) = c("SWIGFunction", class('product_end_idop_filter_first_set'))

# Start of product_end_idop_filter_first_get

`product_end_idop_filter_first_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_idop_filter_first_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_idop_filter_first_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_idop_filter_first_get`, "inputTypes") = c('_p_product_end')
class(`product_end_idop_filter_first_get`) = c("SWIGFunction", class('product_end_idop_filter_first_get'))

# Start of product_end_ilambda_set

`product_end_ilambda_set` = function(self, s_ilambda)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ilambda = as.integer(s_ilambda) 
  
  if(length(s_ilambda) > 1) {
    Rf_warning("using only the first element of s_ilambda")
  }
  
  .Call('R_swig_product_end_ilambda_set', self, s_ilambda, PACKAGE='iris')
  
}

attr(`product_end_ilambda_set`, 'returnType') = 'void'
attr(`product_end_ilambda_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ilambda_set`) = c("SWIGFunction", class('product_end_ilambda_set'))

# Start of product_end_ilambda_get

`product_end_ilambda_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ilambda_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ilambda_get`, 'returnType') = 'numeric'
attr(`product_end_ilambda_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ilambda_get`) = c("SWIGFunction", class('product_end_ilambda_get'))

# Start of product_end_itrunc_set

`product_end_itrunc_set` = function(self, s_itrunc)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_itrunc = as.integer(s_itrunc) 
  
  if(length(s_itrunc) > 1) {
    Rf_warning("using only the first element of s_itrunc")
  }
  
  .Call('R_swig_product_end_itrunc_set', self, s_itrunc, PACKAGE='iris')
  
}

attr(`product_end_itrunc_set`, 'returnType') = 'void'
attr(`product_end_itrunc_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_itrunc_set`) = c("SWIGFunction", class('product_end_itrunc_set'))

# Start of product_end_itrunc_get

`product_end_itrunc_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_itrunc_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_itrunc_get`, 'returnType') = 'numeric'
attr(`product_end_itrunc_get`, "inputTypes") = c('_p_product_end')
class(`product_end_itrunc_get`) = c("SWIGFunction", class('product_end_itrunc_get'))

# Start of product_end_ibin_first_set

`product_end_ibin_first_set` = function(self, s_ibin_first)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ibin_first = as.integer(s_ibin_first) 
  
  if(length(s_ibin_first) > 1) {
    Rf_warning("using only the first element of s_ibin_first")
  }
  
  .Call('R_swig_product_end_ibin_first_set', self, s_ibin_first, PACKAGE='iris')
  
}

attr(`product_end_ibin_first_set`, 'returnType') = 'void'
attr(`product_end_ibin_first_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ibin_first_set`) = c("SWIGFunction", class('product_end_ibin_first_set'))

# Start of product_end_ibin_first_get

`product_end_ibin_first_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ibin_first_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ibin_first_get`, 'returnType') = 'numeric'
attr(`product_end_ibin_first_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ibin_first_get`) = c("SWIGFunction", class('product_end_ibin_first_get'))

# Start of product_end_ibin_last_set

`product_end_ibin_last_set` = function(self, s_ibin_last)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ibin_last = as.integer(s_ibin_last) 
  
  if(length(s_ibin_last) > 1) {
    Rf_warning("using only the first element of s_ibin_last")
  }
  
  .Call('R_swig_product_end_ibin_last_set', self, s_ibin_last, PACKAGE='iris')
  
}

attr(`product_end_ibin_last_set`, 'returnType') = 'void'
attr(`product_end_ibin_last_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ibin_last_set`) = c("SWIGFunction", class('product_end_ibin_last_set'))

# Start of product_end_ibin_last_get

`product_end_ibin_last_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ibin_last_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ibin_last_get`, 'returnType') = 'numeric'
attr(`product_end_ibin_last_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ibin_last_get`) = c("SWIGFunction", class('product_end_ibin_last_get'))

# Start of product_end_ibin_out_num_set

`product_end_ibin_out_num_set` = function(self, s_ibin_out_num)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ibin_out_num = as.integer(s_ibin_out_num) 
  
  if(length(s_ibin_out_num) > 1) {
    Rf_warning("using only the first element of s_ibin_out_num")
  }
  
  .Call('R_swig_product_end_ibin_out_num_set', self, s_ibin_out_num, PACKAGE='iris')
  
}

attr(`product_end_ibin_out_num_set`, 'returnType') = 'void'
attr(`product_end_ibin_out_num_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ibin_out_num_set`) = c("SWIGFunction", class('product_end_ibin_out_num_set'))

# Start of product_end_ibin_out_num_get

`product_end_ibin_out_num_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ibin_out_num_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ibin_out_num_get`, 'returnType') = 'numeric'
attr(`product_end_ibin_out_num_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ibin_out_num_get`) = c("SWIGFunction", class('product_end_ibin_out_num_get'))

# Start of product_end_iPEFlags_set

`product_end_iPEFlags_set` = function(self, s_iPEFlags)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iPEFlags = coerceIfNotSubclass(s_iPEFlags, "_p_short") 
  .Call('R_swig_product_end_iPEFlags_set', self, s_iPEFlags, PACKAGE='iris')
  
}

attr(`product_end_iPEFlags_set`, 'returnType') = 'void'
attr(`product_end_iPEFlags_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iPEFlags_set`) = c("SWIGFunction", class('product_end_iPEFlags_set'))

# Start of product_end_iPEFlags_get

`product_end_iPEFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iPEFlags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iPEFlags_get`, 'returnType') = '_p_short'
attr(`product_end_iPEFlags_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iPEFlags_get`) = c("SWIGFunction", class('product_end_iPEFlags_get'))

# Start of product_end_input_cnt_set

`product_end_input_cnt_set` = function(self, s_input_cnt)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_input_cnt = coerceIfNotSubclass(s_input_cnt, "_p_short") 
  .Call('R_swig_product_end_input_cnt_set', self, s_input_cnt, PACKAGE='iris')
  
}

attr(`product_end_input_cnt_set`, 'returnType') = 'void'
attr(`product_end_input_cnt_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_input_cnt_set`) = c("SWIGFunction", class('product_end_input_cnt_set'))

# Start of product_end_input_cnt_get

`product_end_input_cnt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_input_cnt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_input_cnt_get`, 'returnType') = '_p_short'
attr(`product_end_input_cnt_get`, "inputTypes") = c('_p_product_end')
class(`product_end_input_cnt_get`) = c("SWIGFunction", class('product_end_input_cnt_get'))

# Start of product_end_ipolar_set

`product_end_ipolar_set` = function(self, s_ipolar)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ipolar = coerceIfNotSubclass(s_ipolar, "_p_unsigned_short") 
  .Call('R_swig_product_end_ipolar_set', self, s_ipolar, PACKAGE='iris')
  
}

attr(`product_end_ipolar_set`, 'returnType') = 'void'
attr(`product_end_ipolar_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_ipolar_set`) = c("SWIGFunction", class('product_end_ipolar_set'))

# Start of product_end_ipolar_get

`product_end_ipolar_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_ipolar_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_ipolar_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_ipolar_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ipolar_get`) = c("SWIGFunction", class('product_end_ipolar_get'))

# Start of product_end_iI0Horiz_set

`product_end_iI0Horiz_set` = function(self, s_iI0Horiz)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iI0Horiz = coerceIfNotSubclass(s_iI0Horiz, "_p_short") 
  .Call('R_swig_product_end_iI0Horiz_set', self, s_iI0Horiz, PACKAGE='iris')
  
}

attr(`product_end_iI0Horiz_set`, 'returnType') = 'void'
attr(`product_end_iI0Horiz_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iI0Horiz_set`) = c("SWIGFunction", class('product_end_iI0Horiz_set'))

# Start of product_end_iI0Horiz_get

`product_end_iI0Horiz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iI0Horiz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iI0Horiz_get`, 'returnType') = '_p_short'
attr(`product_end_iI0Horiz_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iI0Horiz_get`) = c("SWIGFunction", class('product_end_iI0Horiz_get'))

# Start of product_end_iCalNoiseHoriz_set

`product_end_iCalNoiseHoriz_set` = function(self, s_iCalNoiseHoriz)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iCalNoiseHoriz = coerceIfNotSubclass(s_iCalNoiseHoriz, "_p_short") 
  .Call('R_swig_product_end_iCalNoiseHoriz_set', self, s_iCalNoiseHoriz, PACKAGE='iris')
  
}

attr(`product_end_iCalNoiseHoriz_set`, 'returnType') = 'void'
attr(`product_end_iCalNoiseHoriz_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iCalNoiseHoriz_set`) = c("SWIGFunction", class('product_end_iCalNoiseHoriz_set'))

# Start of product_end_iCalNoiseHoriz_get

`product_end_iCalNoiseHoriz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iCalNoiseHoriz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iCalNoiseHoriz_get`, 'returnType') = '_p_short'
attr(`product_end_iCalNoiseHoriz_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iCalNoiseHoriz_get`) = c("SWIGFunction", class('product_end_iCalNoiseHoriz_get'))

# Start of product_end_iRadarConstantHoriz_set

`product_end_iRadarConstantHoriz_set` = function(self, s_iRadarConstantHoriz)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iRadarConstantHoriz = coerceIfNotSubclass(s_iRadarConstantHoriz, "_p_short") 
  .Call('R_swig_product_end_iRadarConstantHoriz_set', self, s_iRadarConstantHoriz, PACKAGE='iris')
  
}

attr(`product_end_iRadarConstantHoriz_set`, 'returnType') = 'void'
attr(`product_end_iRadarConstantHoriz_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iRadarConstantHoriz_set`) = c("SWIGFunction", class('product_end_iRadarConstantHoriz_set'))

# Start of product_end_iRadarConstantHoriz_get

`product_end_iRadarConstantHoriz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iRadarConstantHoriz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iRadarConstantHoriz_get`, 'returnType') = '_p_short'
attr(`product_end_iRadarConstantHoriz_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iRadarConstantHoriz_get`) = c("SWIGFunction", class('product_end_iRadarConstantHoriz_get'))

# Start of product_end_iReceiverBandwidth_set

`product_end_iReceiverBandwidth_set` = function(self, s_iReceiverBandwidth)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iReceiverBandwidth = coerceIfNotSubclass(s_iReceiverBandwidth, "_p_unsigned_short") 
  .Call('R_swig_product_end_iReceiverBandwidth_set', self, s_iReceiverBandwidth, PACKAGE='iris')
  
}

attr(`product_end_iReceiverBandwidth_set`, 'returnType') = 'void'
attr(`product_end_iReceiverBandwidth_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_iReceiverBandwidth_set`) = c("SWIGFunction", class('product_end_iReceiverBandwidth_set'))

# Start of product_end_iReceiverBandwidth_get

`product_end_iReceiverBandwidth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iReceiverBandwidth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_iReceiverBandwidth_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_iReceiverBandwidth_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iReceiverBandwidth_get`) = c("SWIGFunction", class('product_end_iReceiverBandwidth_get'))

# Start of product_end_iActNoiseHoriz_set

`product_end_iActNoiseHoriz_set` = function(self, s_iActNoiseHoriz)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iActNoiseHoriz = coerceIfNotSubclass(s_iActNoiseHoriz, "_p_short") 
  .Call('R_swig_product_end_iActNoiseHoriz_set', self, s_iActNoiseHoriz, PACKAGE='iris')
  
}

attr(`product_end_iActNoiseHoriz_set`, 'returnType') = 'void'
attr(`product_end_iActNoiseHoriz_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iActNoiseHoriz_set`) = c("SWIGFunction", class('product_end_iActNoiseHoriz_set'))

# Start of product_end_iActNoiseHoriz_get

`product_end_iActNoiseHoriz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iActNoiseHoriz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iActNoiseHoriz_get`, 'returnType') = '_p_short'
attr(`product_end_iActNoiseHoriz_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iActNoiseHoriz_get`) = c("SWIGFunction", class('product_end_iActNoiseHoriz_get'))

# Start of product_end_ipad184x28_set

`product_end_ipad184x28_set` = function(self, s_ipad184x28)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_ipad184x28))
  assert(all(sapply(s_ipad184x28, class) == "_p_char"))     
  
  
#  assert(length(s_ipad184x28) >= 28)
  
  .Call('R_swig_product_end_ipad184x28_set', self, s_ipad184x28, PACKAGE='iris')
  
}

attr(`product_end_ipad184x28_set`, 'returnType') = 'void'
attr(`product_end_ipad184x28_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_ipad184x28_set`) = c("SWIGFunction", class('product_end_ipad184x28_set'))

# Start of product_end_ipad184x28_get

`product_end_ipad184x28_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_ipad184x28_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_ipad184x28_get`, 'returnType') = '_p_char'
attr(`product_end_ipad184x28_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ipad184x28_get`) = c("SWIGFunction", class('product_end_ipad184x28_get'))

# Start of product_end_iStdParallel1_set

`product_end_iStdParallel1_set` = function(self, s_iStdParallel1)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iStdParallel1 = as.numeric(s_iStdParallel1) 
  
  assert(length(s_iStdParallel1) == 1 && s_iStdParallel1 >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_iStdParallel1_set', self, s_iStdParallel1, PACKAGE='iris')
  
}

attr(`product_end_iStdParallel1_set`, 'returnType') = 'void'
attr(`product_end_iStdParallel1_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_iStdParallel1_set`) = c("SWIGFunction", class('product_end_iStdParallel1_set'))

# Start of product_end_iStdParallel1_get

`product_end_iStdParallel1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_iStdParallel1_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_iStdParallel1_get`, 'returnType') = 'numeric'
attr(`product_end_iStdParallel1_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iStdParallel1_get`) = c("SWIGFunction", class('product_end_iStdParallel1_get'))

# Start of product_end_iStdParallel2_set

`product_end_iStdParallel2_set` = function(self, s_iStdParallel2)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iStdParallel2 = as.numeric(s_iStdParallel2) 
  
  assert(length(s_iStdParallel2) == 1 && s_iStdParallel2 >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_iStdParallel2_set', self, s_iStdParallel2, PACKAGE='iris')
  
}

attr(`product_end_iStdParallel2_set`, 'returnType') = 'void'
attr(`product_end_iStdParallel2_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_iStdParallel2_set`) = c("SWIGFunction", class('product_end_iStdParallel2_set'))

# Start of product_end_iStdParallel2_get

`product_end_iStdParallel2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_iStdParallel2_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_iStdParallel2_get`, 'returnType') = 'numeric'
attr(`product_end_iStdParallel2_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iStdParallel2_get`) = c("SWIGFunction", class('product_end_iStdParallel2_get'))

# Start of product_end_iEarthRadius_set

`product_end_iEarthRadius_set` = function(self, s_iEarthRadius)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iEarthRadius = as.numeric(s_iEarthRadius) 
  
  assert(length(s_iEarthRadius) == 1 && s_iEarthRadius >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_iEarthRadius_set', self, s_iEarthRadius, PACKAGE='iris')
  
}

attr(`product_end_iEarthRadius_set`, 'returnType') = 'void'
attr(`product_end_iEarthRadius_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_iEarthRadius_set`) = c("SWIGFunction", class('product_end_iEarthRadius_set'))

# Start of product_end_iEarthRadius_get

`product_end_iEarthRadius_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_iEarthRadius_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_iEarthRadius_get`, 'returnType') = 'numeric'
attr(`product_end_iEarthRadius_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iEarthRadius_get`) = c("SWIGFunction", class('product_end_iEarthRadius_get'))

# Start of product_end_iFlattening_set

`product_end_iFlattening_set` = function(self, s_iFlattening)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iFlattening = as.numeric(s_iFlattening) 
  
  assert(length(s_iFlattening) == 1 && s_iFlattening >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_iFlattening_set', self, s_iFlattening, PACKAGE='iris')
  
}

attr(`product_end_iFlattening_set`, 'returnType') = 'void'
attr(`product_end_iFlattening_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_iFlattening_set`) = c("SWIGFunction", class('product_end_iFlattening_set'))

# Start of product_end_iFlattening_get

`product_end_iFlattening_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_iFlattening_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_iFlattening_get`, 'returnType') = 'numeric'
attr(`product_end_iFlattening_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iFlattening_get`) = c("SWIGFunction", class('product_end_iFlattening_get'))

# Start of product_end_iFaultBits_set

`product_end_iFaultBits_set` = function(self, s_iFaultBits)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iFaultBits = as.numeric(s_iFaultBits) 
  
  assert(length(s_iFaultBits) == 1 && s_iFaultBits >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_iFaultBits_set', self, s_iFaultBits, PACKAGE='iris')
  
}

attr(`product_end_iFaultBits_set`, 'returnType') = 'void'
attr(`product_end_iFaultBits_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_iFaultBits_set`) = c("SWIGFunction", class('product_end_iFaultBits_set'))

# Start of product_end_iFaultBits_get

`product_end_iFaultBits_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_iFaultBits_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_iFaultBits_get`, 'returnType') = 'numeric'
attr(`product_end_iFaultBits_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iFaultBits_get`) = c("SWIGFunction", class('product_end_iFaultBits_get'))

# Start of product_end_iSiteMask_set

`product_end_iSiteMask_set` = function(self, s_iSiteMask)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iSiteMask = as.numeric(s_iSiteMask) 
  
  assert(length(s_iSiteMask) == 1 && s_iSiteMask >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_iSiteMask_set', self, s_iSiteMask, PACKAGE='iris')
  
}

attr(`product_end_iSiteMask_set`, 'returnType') = 'void'
attr(`product_end_iSiteMask_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_iSiteMask_set`) = c("SWIGFunction", class('product_end_iSiteMask_set'))

# Start of product_end_iSiteMask_get

`product_end_iSiteMask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_iSiteMask_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_iSiteMask_get`, 'returnType') = 'numeric'
attr(`product_end_iSiteMask_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iSiteMask_get`) = c("SWIGFunction", class('product_end_iSiteMask_get'))

# Start of product_end_ilog_filter_first_set

`product_end_ilog_filter_first_set` = function(self, s_ilog_filter_first)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ilog_filter_first = coerceIfNotSubclass(s_ilog_filter_first, "_p_unsigned_short") 
  .Call('R_swig_product_end_ilog_filter_first_set', self, s_ilog_filter_first, PACKAGE='iris')
  
}

attr(`product_end_ilog_filter_first_set`, 'returnType') = 'void'
attr(`product_end_ilog_filter_first_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_ilog_filter_first_set`) = c("SWIGFunction", class('product_end_ilog_filter_first_set'))

# Start of product_end_ilog_filter_first_get

`product_end_ilog_filter_first_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_ilog_filter_first_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_ilog_filter_first_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_ilog_filter_first_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ilog_filter_first_get`) = c("SWIGFunction", class('product_end_ilog_filter_first_get'))

# Start of product_end_lclutmap_used_set

`product_end_lclutmap_used_set` = function(self, s_lclutmap_used)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_lclutmap_used = coerceIfNotSubclass(s_lclutmap_used, "_p_unsigned_short") 
  .Call('R_swig_product_end_lclutmap_used_set', self, s_lclutmap_used, PACKAGE='iris')
  
}

attr(`product_end_lclutmap_used_set`, 'returnType') = 'void'
attr(`product_end_lclutmap_used_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_lclutmap_used_set`) = c("SWIGFunction", class('product_end_lclutmap_used_set'))

# Start of product_end_lclutmap_used_get

`product_end_lclutmap_used_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_lclutmap_used_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_lclutmap_used_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_lclutmap_used_get`, "inputTypes") = c('_p_product_end')
class(`product_end_lclutmap_used_get`) = c("SWIGFunction", class('product_end_lclutmap_used_get'))

# Start of product_end_ilat_ref_set

`product_end_ilat_ref_set` = function(self, s_ilat_ref)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ilat_ref = as.numeric(s_ilat_ref) 
  
  assert(length(s_ilat_ref) == 1 && s_ilat_ref >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_ilat_ref_set', self, s_ilat_ref, PACKAGE='iris')
  
}

attr(`product_end_ilat_ref_set`, 'returnType') = 'void'
attr(`product_end_ilat_ref_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ilat_ref_set`) = c("SWIGFunction", class('product_end_ilat_ref_set'))

# Start of product_end_ilat_ref_get

`product_end_ilat_ref_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ilat_ref_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ilat_ref_get`, 'returnType') = 'numeric'
attr(`product_end_ilat_ref_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ilat_ref_get`) = c("SWIGFunction", class('product_end_ilat_ref_get'))

# Start of product_end_ilon_ref_set

`product_end_ilon_ref_set` = function(self, s_ilon_ref)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_ilon_ref = as.numeric(s_ilon_ref) 
  
  assert(length(s_ilon_ref) == 1 && s_ilon_ref >= 0, "All values must be non-negative")
  
  .Call('R_swig_product_end_ilon_ref_set', self, s_ilon_ref, PACKAGE='iris')
  
}

attr(`product_end_ilon_ref_set`, 'returnType') = 'void'
attr(`product_end_ilon_ref_set`, "inputTypes") = c('_p_product_end', 'numeric')
class(`product_end_ilon_ref_set`) = c("SWIGFunction", class('product_end_ilon_ref_set'))

# Start of product_end_ilon_ref_get

`product_end_ilon_ref_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_product_end_ilon_ref_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`product_end_ilon_ref_get`, 'returnType') = 'numeric'
attr(`product_end_ilon_ref_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ilon_ref_get`) = c("SWIGFunction", class('product_end_ilon_ref_get'))

# Start of product_end_isequence_num_set

`product_end_isequence_num_set` = function(self, s_isequence_num)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_isequence_num = coerceIfNotSubclass(s_isequence_num, "_p_unsigned_short") 
  .Call('R_swig_product_end_isequence_num_set', self, s_isequence_num, PACKAGE='iris')
  
}

attr(`product_end_isequence_num_set`, 'returnType') = 'void'
attr(`product_end_isequence_num_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_isequence_num_set`) = c("SWIGFunction", class('product_end_isequence_num_set'))

# Start of product_end_isequence_num_get

`product_end_isequence_num_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_isequence_num_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_isequence_num_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_isequence_num_get`, "inputTypes") = c('_p_product_end')
class(`product_end_isequence_num_get`) = c("SWIGFunction", class('product_end_isequence_num_get'))

# Start of product_end_istep_colors_set

`product_end_istep_colors_set` = function(self, s_istep_colors)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_istep_colors))
  assert(all(sapply(s_istep_colors, class) == "_p_unsigned_short"))     
  
  
#  assert(length(s_istep_colors) >= 16)
  
  .Call('R_swig_product_end_istep_colors_set', self, s_istep_colors, PACKAGE='iris')
  
}

attr(`product_end_istep_colors_set`, 'returnType') = 'void'
attr(`product_end_istep_colors_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_short')
class(`product_end_istep_colors_set`) = c("SWIGFunction", class('product_end_istep_colors_set'))

# Start of product_end_istep_colors_get

`product_end_istep_colors_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_istep_colors_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`product_end_istep_colors_get`, 'returnType') = '_p_unsigned_short'
attr(`product_end_istep_colors_get`, "inputTypes") = c('_p_product_end')
class(`product_end_istep_colors_get`) = c("SWIGFunction", class('product_end_istep_colors_get'))

# Start of product_end_iMeltingHeight_set

`product_end_iMeltingHeight_set` = function(self, s_iMeltingHeight)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iMeltingHeight = coerceIfNotSubclass(s_iMeltingHeight, "_p_short") 
  .Call('R_swig_product_end_iMeltingHeight_set', self, s_iMeltingHeight, PACKAGE='iris')
  
}

attr(`product_end_iMeltingHeight_set`, 'returnType') = 'void'
attr(`product_end_iMeltingHeight_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iMeltingHeight_set`) = c("SWIGFunction", class('product_end_iMeltingHeight_set'))

# Start of product_end_iMeltingHeight_get

`product_end_iMeltingHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iMeltingHeight_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iMeltingHeight_get`, 'returnType') = '_p_short'
attr(`product_end_iMeltingHeight_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iMeltingHeight_get`) = c("SWIGFunction", class('product_end_iMeltingHeight_get'))

# Start of product_end_iReferenceOffset_set

`product_end_iReferenceOffset_set` = function(self, s_iReferenceOffset)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iReferenceOffset = coerceIfNotSubclass(s_iReferenceOffset, "_p_short") 
  .Call('R_swig_product_end_iReferenceOffset_set', self, s_iReferenceOffset, PACKAGE='iris')
  
}

attr(`product_end_iReferenceOffset_set`, 'returnType') = 'void'
attr(`product_end_iReferenceOffset_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iReferenceOffset_set`) = c("SWIGFunction", class('product_end_iReferenceOffset_set'))

# Start of product_end_iReferenceOffset_get

`product_end_iReferenceOffset_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iReferenceOffset_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iReferenceOffset_get`, 'returnType') = '_p_short'
attr(`product_end_iReferenceOffset_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iReferenceOffset_get`) = c("SWIGFunction", class('product_end_iReferenceOffset_get'))

# Start of product_end_iresults_count_set

`product_end_iresults_count_set` = function(self, s_iresults_count)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iresults_count = coerceIfNotSubclass(s_iresults_count, "_p_short") 
  .Call('R_swig_product_end_iresults_count_set', self, s_iresults_count, PACKAGE='iris')
  
}

attr(`product_end_iresults_count_set`, 'returnType') = 'void'
attr(`product_end_iresults_count_set`, "inputTypes") = c('_p_product_end', '_p_short')
class(`product_end_iresults_count_set`) = c("SWIGFunction", class('product_end_iresults_count_set'))

# Start of product_end_iresults_count_get

`product_end_iresults_count_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iresults_count_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`product_end_iresults_count_get`, 'returnType') = '_p_short'
attr(`product_end_iresults_count_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iresults_count_get`) = c("SWIGFunction", class('product_end_iresults_count_get'))

# Start of product_end_iWindSpeed_set

`product_end_iWindSpeed_set` = function(self, s_iWindSpeed)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iWindSpeed = coerceIfNotSubclass(s_iWindSpeed, "_p_unsigned_char") 
  .Call('R_swig_product_end_iWindSpeed_set', self, s_iWindSpeed, PACKAGE='iris')
  
}

attr(`product_end_iWindSpeed_set`, 'returnType') = 'void'
attr(`product_end_iWindSpeed_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_char')
class(`product_end_iWindSpeed_set`) = c("SWIGFunction", class('product_end_iWindSpeed_set'))

# Start of product_end_iWindSpeed_get

`product_end_iWindSpeed_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iWindSpeed_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`product_end_iWindSpeed_get`, 'returnType') = '_p_unsigned_char'
attr(`product_end_iWindSpeed_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iWindSpeed_get`) = c("SWIGFunction", class('product_end_iWindSpeed_get'))

# Start of product_end_iWindDirection_set

`product_end_iWindDirection_set` = function(self, s_iWindDirection)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  s_iWindDirection = coerceIfNotSubclass(s_iWindDirection, "_p_unsigned_char") 
  .Call('R_swig_product_end_iWindDirection_set', self, s_iWindDirection, PACKAGE='iris')
  
}

attr(`product_end_iWindDirection_set`, 'returnType') = 'void'
attr(`product_end_iWindDirection_set`, "inputTypes") = c('_p_product_end', '_p_unsigned_char')
class(`product_end_iWindDirection_set`) = c("SWIGFunction", class('product_end_iWindDirection_set'))

# Start of product_end_iWindDirection_get

`product_end_iWindDirection_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_iWindDirection_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`product_end_iWindDirection_get`, 'returnType') = '_p_unsigned_char'
attr(`product_end_iWindDirection_get`, "inputTypes") = c('_p_product_end')
class(`product_end_iWindDirection_get`) = c("SWIGFunction", class('product_end_iWindDirection_get'))

# Start of product_end_ipad290x2_set

`product_end_ipad290x2_set` = function(self, s_ipad290x2)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_ipad290x2))
  assert(all(sapply(s_ipad290x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad290x2) >= 2)
  
  .Call('R_swig_product_end_ipad290x2_set', self, s_ipad290x2, PACKAGE='iris')
  
}

attr(`product_end_ipad290x2_set`, 'returnType') = 'void'
attr(`product_end_ipad290x2_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_ipad290x2_set`) = c("SWIGFunction", class('product_end_ipad290x2_set'))

# Start of product_end_ipad290x2_get

`product_end_ipad290x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_ipad290x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_ipad290x2_get`, 'returnType') = '_p_char'
attr(`product_end_ipad290x2_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ipad290x2_get`) = c("SWIGFunction", class('product_end_ipad290x2_get'))

# Start of product_end_sLocalTZName_set

`product_end_sLocalTZName_set` = function(self, s_sLocalTZName)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_sLocalTZName))
  assert(all(sapply(s_sLocalTZName, class) == "_p_char"))     
  
  
#  assert(length(s_sLocalTZName) >= 8)
  
  .Call('R_swig_product_end_sLocalTZName_set', self, s_sLocalTZName, PACKAGE='iris')
  
}

attr(`product_end_sLocalTZName_set`, 'returnType') = 'void'
attr(`product_end_sLocalTZName_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_sLocalTZName_set`) = c("SWIGFunction", class('product_end_sLocalTZName_set'))

# Start of product_end_sLocalTZName_get

`product_end_sLocalTZName_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_sLocalTZName_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_sLocalTZName_get`, 'returnType') = '_p_char'
attr(`product_end_sLocalTZName_get`, "inputTypes") = c('_p_product_end')
class(`product_end_sLocalTZName_get`) = c("SWIGFunction", class('product_end_sLocalTZName_get'))

# Start of product_end_ipad300x8_set

`product_end_ipad300x8_set` = function(self, s_ipad300x8)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  
  if(is.list(s_ipad300x8))
  assert(all(sapply(s_ipad300x8, class) == "_p_char"))     
  
  
#  assert(length(s_ipad300x8) >= 8)
  
  .Call('R_swig_product_end_ipad300x8_set', self, s_ipad300x8, PACKAGE='iris')
  
}

attr(`product_end_ipad300x8_set`, 'returnType') = 'void'
attr(`product_end_ipad300x8_set`, "inputTypes") = c('_p_product_end', '_p_char')
class(`product_end_ipad300x8_set`) = c("SWIGFunction", class('product_end_ipad300x8_set'))

# Start of product_end_ipad300x8_get

`product_end_ipad300x8_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  ans = .Call('R_swig_product_end_ipad300x8_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`product_end_ipad300x8_get`, 'returnType') = '_p_char'
attr(`product_end_ipad300x8_get`, "inputTypes") = c('_p_product_end')
class(`product_end_ipad300x8_get`) = c("SWIGFunction", class('product_end_ipad300x8_get'))

# Start of new_product_end

`product_end` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_product_end', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_product_end"
  
  ans
  
}

attr(`product_end`, 'returnType') = '_p_product_end'
class(`product_end`) = c("SWIGFunction", class('product_end'))

# Start of delete_product_end

`delete_product_end` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_product_end") 
  .Call('R_swig_delete_product_end', self, PACKAGE='iris')
  
}

attr(`delete_product_end`, 'returnType') = 'void'
attr(`delete_product_end`, "inputTypes") = c('_p_product_end')
class(`delete_product_end`) = c("SWIGFunction", class('delete_product_end'))

# Start of accessor method for product_end
setMethod('$', '_p_product_end', function(x, name)

{
  accessorFuns = list('sprod_sitename' = product_end_sprod_sitename_get, 'sprod_version' = product_end_sprod_version_get, 'sing_version' = product_end_sing_version_get, 'old_ing' = product_end_old_ing_get, 'ipad44x28' = product_end_ipad44x28_get, 'iLocalWest' = product_end_iLocalWest_get, 'sIngHardwareName' = product_end_sIngHardwareName_get, 'sing_sitename' = product_end_sing_sitename_get, 'iMinutesWest' = product_end_iMinutesWest_get, 'ilat_center' = product_end_ilat_center_get, 'ilon_center' = product_end_ilon_center_get, 'ignd_hgt' = product_end_ignd_hgt_get, 'irad_hgt' = product_end_irad_hgt_get, 'iprf' = product_end_iprf_get, 'ipw' = product_end_ipw_get, 'idsptype' = product_end_idsptype_get, 'itrig' = product_end_itrig_get, 'isamp' = product_end_isamp_get, 'sfilter' = product_end_sfilter_get, 'idop_filter_first' = product_end_idop_filter_first_get, 'ilambda' = product_end_ilambda_get, 'itrunc' = product_end_itrunc_get, 'ibin_first' = product_end_ibin_first_get, 'ibin_last' = product_end_ibin_last_get, 'ibin_out_num' = product_end_ibin_out_num_get, 'iPEFlags' = product_end_iPEFlags_get, 'input_cnt' = product_end_input_cnt_get, 'ipolar' = product_end_ipolar_get, 'iI0Horiz' = product_end_iI0Horiz_get, 'iCalNoiseHoriz' = product_end_iCalNoiseHoriz_get, 'iRadarConstantHoriz' = product_end_iRadarConstantHoriz_get, 'iReceiverBandwidth' = product_end_iReceiverBandwidth_get, 'iActNoiseHoriz' = product_end_iActNoiseHoriz_get, 'ipad184x28' = product_end_ipad184x28_get, 'iStdParallel1' = product_end_iStdParallel1_get, 'iStdParallel2' = product_end_iStdParallel2_get, 'iEarthRadius' = product_end_iEarthRadius_get, 'iFlattening' = product_end_iFlattening_get, 'iFaultBits' = product_end_iFaultBits_get, 'iSiteMask' = product_end_iSiteMask_get, 'ilog_filter_first' = product_end_ilog_filter_first_get, 'lclutmap_used' = product_end_lclutmap_used_get, 'ilat_ref' = product_end_ilat_ref_get, 'ilon_ref' = product_end_ilon_ref_get, 'isequence_num' = product_end_isequence_num_get, 'istep_colors' = product_end_istep_colors_get, 'iMeltingHeight' = product_end_iMeltingHeight_get, 'iReferenceOffset' = product_end_iReferenceOffset_get, 'iresults_count' = product_end_iresults_count_get, 'iWindSpeed' = product_end_iWindSpeed_get, 'iWindDirection' = product_end_iWindDirection_get, 'ipad290x2' = product_end_ipad290x2_get, 'sLocalTZName' = product_end_sLocalTZName_get, 'ipad300x8' = product_end_ipad300x8_get)
  vaccessors = c('sprod_sitename', 'sprod_version', 'sing_version', 'old_ing', 'ipad44x28', 'iLocalWest', 'sIngHardwareName', 'sing_sitename', 'iMinutesWest', 'ilat_center', 'ilon_center', 'ignd_hgt', 'irad_hgt', 'iprf', 'ipw', 'idsptype', 'itrig', 'isamp', 'sfilter', 'idop_filter_first', 'ilambda', 'itrunc', 'ibin_first', 'ibin_last', 'ibin_out_num', 'iPEFlags', 'input_cnt', 'ipolar', 'iI0Horiz', 'iCalNoiseHoriz', 'iRadarConstantHoriz', 'iReceiverBandwidth', 'iActNoiseHoriz', 'ipad184x28', 'iStdParallel1', 'iStdParallel2', 'iEarthRadius', 'iFlattening', 'iFaultBits', 'iSiteMask', 'ilog_filter_first', 'lclutmap_used', 'ilat_ref', 'ilon_ref', 'isequence_num', 'istep_colors', 'iMeltingHeight', 'iReferenceOffset', 'iresults_count', 'iWindSpeed', 'iWindDirection', 'ipad290x2', 'sLocalTZName', 'ipad300x8')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for product_end
# Start of accessor method for product_end
setMethod('$<-', '_p_product_end', function(x, name, value)

{
  accessorFuns = list('sprod_sitename' = product_end_sprod_sitename_set, 'sprod_version' = product_end_sprod_version_set, 'sing_version' = product_end_sing_version_set, 'old_ing' = product_end_old_ing_set, 'ipad44x28' = product_end_ipad44x28_set, 'iLocalWest' = product_end_iLocalWest_set, 'sIngHardwareName' = product_end_sIngHardwareName_set, 'sing_sitename' = product_end_sing_sitename_set, 'iMinutesWest' = product_end_iMinutesWest_set, 'ilat_center' = product_end_ilat_center_set, 'ilon_center' = product_end_ilon_center_set, 'ignd_hgt' = product_end_ignd_hgt_set, 'irad_hgt' = product_end_irad_hgt_set, 'iprf' = product_end_iprf_set, 'ipw' = product_end_ipw_set, 'idsptype' = product_end_idsptype_set, 'itrig' = product_end_itrig_set, 'isamp' = product_end_isamp_set, 'sfilter' = product_end_sfilter_set, 'idop_filter_first' = product_end_idop_filter_first_set, 'ilambda' = product_end_ilambda_set, 'itrunc' = product_end_itrunc_set, 'ibin_first' = product_end_ibin_first_set, 'ibin_last' = product_end_ibin_last_set, 'ibin_out_num' = product_end_ibin_out_num_set, 'iPEFlags' = product_end_iPEFlags_set, 'input_cnt' = product_end_input_cnt_set, 'ipolar' = product_end_ipolar_set, 'iI0Horiz' = product_end_iI0Horiz_set, 'iCalNoiseHoriz' = product_end_iCalNoiseHoriz_set, 'iRadarConstantHoriz' = product_end_iRadarConstantHoriz_set, 'iReceiverBandwidth' = product_end_iReceiverBandwidth_set, 'iActNoiseHoriz' = product_end_iActNoiseHoriz_set, 'ipad184x28' = product_end_ipad184x28_set, 'iStdParallel1' = product_end_iStdParallel1_set, 'iStdParallel2' = product_end_iStdParallel2_set, 'iEarthRadius' = product_end_iEarthRadius_set, 'iFlattening' = product_end_iFlattening_set, 'iFaultBits' = product_end_iFaultBits_set, 'iSiteMask' = product_end_iSiteMask_set, 'ilog_filter_first' = product_end_ilog_filter_first_set, 'lclutmap_used' = product_end_lclutmap_used_set, 'ilat_ref' = product_end_ilat_ref_set, 'ilon_ref' = product_end_ilon_ref_set, 'isequence_num' = product_end_isequence_num_set, 'istep_colors' = product_end_istep_colors_set, 'iMeltingHeight' = product_end_iMeltingHeight_set, 'iReferenceOffset' = product_end_iReferenceOffset_set, 'iresults_count' = product_end_iresults_count_set, 'iWindSpeed' = product_end_iWindSpeed_set, 'iWindDirection' = product_end_iWindDirection_set, 'ipad290x2' = product_end_ipad290x2_set, 'sLocalTZName' = product_end_sLocalTZName_set, 'ipad300x8' = product_end_ipad300x8_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_product_end', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('sprod_sitename' = product_end_sprod_sitename_set, 'sprod_version' = product_end_sprod_version_set, 'sing_version' = product_end_sing_version_set, 'old_ing' = product_end_old_ing_set, 'ipad44x28' = product_end_ipad44x28_set, 'iLocalWest' = product_end_iLocalWest_set, 'sIngHardwareName' = product_end_sIngHardwareName_set, 'sing_sitename' = product_end_sing_sitename_set, 'iMinutesWest' = product_end_iMinutesWest_set, 'ilat_center' = product_end_ilat_center_set, 'ilon_center' = product_end_ilon_center_set, 'ignd_hgt' = product_end_ignd_hgt_set, 'irad_hgt' = product_end_irad_hgt_set, 'iprf' = product_end_iprf_set, 'ipw' = product_end_ipw_set, 'idsptype' = product_end_idsptype_set, 'itrig' = product_end_itrig_set, 'isamp' = product_end_isamp_set, 'sfilter' = product_end_sfilter_set, 'idop_filter_first' = product_end_idop_filter_first_set, 'ilambda' = product_end_ilambda_set, 'itrunc' = product_end_itrunc_set, 'ibin_first' = product_end_ibin_first_set, 'ibin_last' = product_end_ibin_last_set, 'ibin_out_num' = product_end_ibin_out_num_set, 'iPEFlags' = product_end_iPEFlags_set, 'input_cnt' = product_end_input_cnt_set, 'ipolar' = product_end_ipolar_set, 'iI0Horiz' = product_end_iI0Horiz_set, 'iCalNoiseHoriz' = product_end_iCalNoiseHoriz_set, 'iRadarConstantHoriz' = product_end_iRadarConstantHoriz_set, 'iReceiverBandwidth' = product_end_iReceiverBandwidth_set, 'iActNoiseHoriz' = product_end_iActNoiseHoriz_set, 'ipad184x28' = product_end_ipad184x28_set, 'iStdParallel1' = product_end_iStdParallel1_set, 'iStdParallel2' = product_end_iStdParallel2_set, 'iEarthRadius' = product_end_iEarthRadius_set, 'iFlattening' = product_end_iFlattening_set, 'iFaultBits' = product_end_iFaultBits_set, 'iSiteMask' = product_end_iSiteMask_set, 'ilog_filter_first' = product_end_ilog_filter_first_set, 'lclutmap_used' = product_end_lclutmap_used_set, 'ilat_ref' = product_end_ilat_ref_set, 'ilon_ref' = product_end_ilon_ref_set, 'isequence_num' = product_end_isequence_num_set, 'istep_colors' = product_end_istep_colors_set, 'iMeltingHeight' = product_end_iMeltingHeight_set, 'iReferenceOffset' = product_end_iReferenceOffset_set, 'iresults_count' = product_end_iresults_count_set, 'iWindSpeed' = product_end_iWindSpeed_set, 'iWindDirection' = product_end_iWindDirection_set, 'ipad290x2' = product_end_ipad290x2_set, 'sLocalTZName' = product_end_sLocalTZName_set, 'ipad300x8' = product_end_ipad300x8_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for product_end
setMethod('delete', '_p_product_end', function(obj) {delete_product_end(obj)})
# Start definition of copy functions & methods for product_end
CopyToR_product_end = function(value, obj = new("product_end"))
{
  obj@sprod_sitename = value$sprod_sitename
  obj@sprod_version = value$sprod_version
  obj@sing_version = value$sing_version
  obj@ipad44x28 = value$ipad44x28
  obj@sIngHardwareName = value$sIngHardwareName
  obj@sing_sitename = value$sing_sitename
  obj@ilat_center = value$ilat_center
  obj@ilon_center = value$ilon_center
  obj@iprf = value$iprf
  obj@ipw = value$ipw
  obj@sfilter = value$sfilter
  obj@ilambda = value$ilambda
  obj@itrunc = value$itrunc
  obj@ibin_first = value$ibin_first
  obj@ibin_last = value$ibin_last
  obj@ibin_out_num = value$ibin_out_num
  obj@ipad184x28 = value$ipad184x28
  obj@iStdParallel1 = value$iStdParallel1
  obj@iStdParallel2 = value$iStdParallel2
  obj@iEarthRadius = value$iEarthRadius
  obj@iFlattening = value$iFlattening
  obj@iFaultBits = value$iFaultBits
  obj@iSiteMask = value$iSiteMask
  obj@ilat_ref = value$ilat_ref
  obj@ilon_ref = value$ilon_ref
  obj@ipad290x2 = value$ipad290x2
  obj@sLocalTZName = value$sLocalTZName
  obj@ipad300x8 = value$ipad300x8
  obj
}



CopyToC_product_end = function(value, obj)
{
  obj$sprod_sitename = value@sprod_sitename
  obj$sprod_version = value@sprod_version
  obj$sing_version = value@sing_version
  obj$ipad44x28 = value@ipad44x28
  obj$sIngHardwareName = value@sIngHardwareName
  obj$sing_sitename = value@sing_sitename
  obj$ilat_center = value@ilat_center
  obj$ilon_center = value@ilon_center
  obj$iprf = value@iprf
  obj$ipw = value@ipw
  obj$sfilter = value@sfilter
  obj$ilambda = value@ilambda
  obj$itrunc = value@itrunc
  obj$ibin_first = value@ibin_first
  obj$ibin_last = value@ibin_last
  obj$ibin_out_num = value@ibin_out_num
  obj$ipad184x28 = value@ipad184x28
  obj$iStdParallel1 = value@iStdParallel1
  obj$iStdParallel2 = value@iStdParallel2
  obj$iEarthRadius = value@iEarthRadius
  obj$iFlattening = value@iFlattening
  obj$iFaultBits = value@iFaultBits
  obj$iSiteMask = value@iSiteMask
  obj$ilat_ref = value@ilat_ref
  obj$ilon_ref = value@ilon_ref
  obj$ipad290x2 = value@ipad290x2
  obj$sLocalTZName = value@sLocalTZName
  obj$ipad300x8 = value@ipad300x8
  obj
}



# Start definition of copy methods for product_end
setMethod('copyToR', '_p_product_end', CopyToR_product_end)
setMethod('copyToC', 'product_end', CopyToC_product_end)

# End definition of copy methods for product_end
# End definition of copy functions & methods for product_end
# Start of product_hdr_hdr_set

`product_hdr_hdr_set` = function(self, s_hdr)
{
  self = coerceIfNotSubclass(self, "_p_product_hdr") 
  s_hdr = coerceIfNotSubclass(s_hdr, "_p_structure_header") 
  .Call('R_swig_product_hdr_hdr_set', self, s_hdr, PACKAGE='iris')
  
}

attr(`product_hdr_hdr_set`, 'returnType') = 'void'
attr(`product_hdr_hdr_set`, "inputTypes") = c('_p_product_hdr', '_p_structure_header')
class(`product_hdr_hdr_set`) = c("SWIGFunction", class('product_hdr_hdr_set'))

# Start of product_hdr_hdr_get

`product_hdr_hdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_hdr") 
  ans = .Call('R_swig_product_hdr_hdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_structure_header"
  
  ans
  
}

attr(`product_hdr_hdr_get`, 'returnType') = '_p_structure_header'
attr(`product_hdr_hdr_get`, "inputTypes") = c('_p_product_hdr')
class(`product_hdr_hdr_get`) = c("SWIGFunction", class('product_hdr_hdr_get'))

# Start of product_hdr_pcf_set

`product_hdr_pcf_set` = function(self, s_pcf)
{
  self = coerceIfNotSubclass(self, "_p_product_hdr") 
  s_pcf = coerceIfNotSubclass(s_pcf, "_p_product_configuration") 
  .Call('R_swig_product_hdr_pcf_set', self, s_pcf, PACKAGE='iris')
  
}

attr(`product_hdr_pcf_set`, 'returnType') = 'void'
attr(`product_hdr_pcf_set`, "inputTypes") = c('_p_product_hdr', '_p_product_configuration')
class(`product_hdr_pcf_set`) = c("SWIGFunction", class('product_hdr_pcf_set'))

# Start of product_hdr_pcf_get

`product_hdr_pcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_hdr") 
  ans = .Call('R_swig_product_hdr_pcf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_product_configuration"
  
  ans
  
}

attr(`product_hdr_pcf_get`, 'returnType') = '_p_product_configuration'
attr(`product_hdr_pcf_get`, "inputTypes") = c('_p_product_hdr')
class(`product_hdr_pcf_get`) = c("SWIGFunction", class('product_hdr_pcf_get'))

# Start of product_hdr_end_set

`product_hdr_end_set` = function(self, s_end)
{
  self = coerceIfNotSubclass(self, "_p_product_hdr") 
  s_end = coerceIfNotSubclass(s_end, "_p_product_end") 
  .Call('R_swig_product_hdr_end_set', self, s_end, PACKAGE='iris')
  
}

attr(`product_hdr_end_set`, 'returnType') = 'void'
attr(`product_hdr_end_set`, "inputTypes") = c('_p_product_hdr', '_p_product_end')
class(`product_hdr_end_set`) = c("SWIGFunction", class('product_hdr_end_set'))

# Start of product_hdr_end_get

`product_hdr_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_product_hdr") 
  ans = .Call('R_swig_product_hdr_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_product_end"
  
  ans
  
}

attr(`product_hdr_end_get`, 'returnType') = '_p_product_end'
attr(`product_hdr_end_get`, "inputTypes") = c('_p_product_hdr')
class(`product_hdr_end_get`) = c("SWIGFunction", class('product_hdr_end_get'))

# Start of new_product_hdr

`product_hdr` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_product_hdr', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_product_hdr"
  
  ans
  
}

attr(`product_hdr`, 'returnType') = '_p_product_hdr'
class(`product_hdr`) = c("SWIGFunction", class('product_hdr'))

# Start of delete_product_hdr

`delete_product_hdr` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_product_hdr") 
  .Call('R_swig_delete_product_hdr', self, PACKAGE='iris')
  
}

attr(`delete_product_hdr`, 'returnType') = 'void'
attr(`delete_product_hdr`, "inputTypes") = c('_p_product_hdr')
class(`delete_product_hdr`) = c("SWIGFunction", class('delete_product_hdr'))

# Start of accessor method for product_hdr
setMethod('$', '_p_product_hdr', function(x, name)

{
  accessorFuns = list('hdr' = product_hdr_hdr_get, 'pcf' = product_hdr_pcf_get, 'end' = product_hdr_end_get)
  vaccessors = c('hdr', 'pcf', 'end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for product_hdr
# Start of accessor method for product_hdr
setMethod('$<-', '_p_product_hdr', function(x, name, value)

{
  accessorFuns = list('hdr' = product_hdr_hdr_set, 'pcf' = product_hdr_pcf_set, 'end' = product_hdr_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_product_hdr', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('hdr' = product_hdr_hdr_set, 'pcf' = product_hdr_pcf_set, 'end' = product_hdr_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for product_hdr
setMethod('delete', '_p_product_hdr', function(obj) {delete_product_hdr(obj)})
# Start definition of copy functions & methods for product_hdr
CopyToR_product_hdr = function(value, obj = new("product_hdr"))
{
  obj
}



CopyToC_product_hdr = function(value, obj)
{
  obj
}



# Start definition of copy methods for product_hdr
setMethod('copyToR', '_p_product_hdr', CopyToR_product_hdr)
setMethod('copyToC', 'product_hdr', CopyToC_product_hdr)

# End definition of copy methods for product_hdr
# End definition of copy functions & methods for product_hdr
# Start of task_misc_info_ilambda_set

`task_misc_info_ilambda_set` = function(self, s_ilambda)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_ilambda = as.integer(s_ilambda) 
  
  if(length(s_ilambda) > 1) {
    Rf_warning("using only the first element of s_ilambda")
  }
  
  .Call('R_swig_task_misc_info_ilambda_set', self, s_ilambda, PACKAGE='iris')
  
}

attr(`task_misc_info_ilambda_set`, 'returnType') = 'void'
attr(`task_misc_info_ilambda_set`, "inputTypes") = c('_p_task_misc_info', 'numeric')
class(`task_misc_info_ilambda_set`) = c("SWIGFunction", class('task_misc_info_ilambda_set'))

# Start of task_misc_info_ilambda_get

`task_misc_info_ilambda_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  .Call('R_swig_task_misc_info_ilambda_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_misc_info_ilambda_get`, 'returnType') = 'numeric'
attr(`task_misc_info_ilambda_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_ilambda_get`) = c("SWIGFunction", class('task_misc_info_ilambda_get'))

# Start of task_misc_info_str_id_set

`task_misc_info_str_id_set` = function(self, s_str_id)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  
  if(is.list(s_str_id))
  assert(all(sapply(s_str_id, class) == "_p_char"))     
  
  
#  assert(length(s_str_id) >= 16)
  
  .Call('R_swig_task_misc_info_str_id_set', self, s_str_id, PACKAGE='iris')
  
}

attr(`task_misc_info_str_id_set`, 'returnType') = 'void'
attr(`task_misc_info_str_id_set`, "inputTypes") = c('_p_task_misc_info', '_p_char')
class(`task_misc_info_str_id_set`) = c("SWIGFunction", class('task_misc_info_str_id_set'))

# Start of task_misc_info_str_id_get

`task_misc_info_str_id_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_str_id_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_misc_info_str_id_get`, 'returnType') = '_p_char'
attr(`task_misc_info_str_id_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_str_id_get`) = c("SWIGFunction", class('task_misc_info_str_id_get'))

# Start of task_misc_info_ixmt_pwr_set

`task_misc_info_ixmt_pwr_set` = function(self, s_ixmt_pwr)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_ixmt_pwr = as.integer(s_ixmt_pwr) 
  
  if(length(s_ixmt_pwr) > 1) {
    Rf_warning("using only the first element of s_ixmt_pwr")
  }
  
  .Call('R_swig_task_misc_info_ixmt_pwr_set', self, s_ixmt_pwr, PACKAGE='iris')
  
}

attr(`task_misc_info_ixmt_pwr_set`, 'returnType') = 'void'
attr(`task_misc_info_ixmt_pwr_set`, "inputTypes") = c('_p_task_misc_info', 'numeric')
class(`task_misc_info_ixmt_pwr_set`) = c("SWIGFunction", class('task_misc_info_ixmt_pwr_set'))

# Start of task_misc_info_ixmt_pwr_get

`task_misc_info_ixmt_pwr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  .Call('R_swig_task_misc_info_ixmt_pwr_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_misc_info_ixmt_pwr_get`, 'returnType') = 'numeric'
attr(`task_misc_info_ixmt_pwr_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_ixmt_pwr_get`) = c("SWIGFunction", class('task_misc_info_ixmt_pwr_get'))

# Start of task_misc_info_iflags_set

`task_misc_info_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_unsigned_short") 
  .Call('R_swig_task_misc_info_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`task_misc_info_iflags_set`, 'returnType') = 'void'
attr(`task_misc_info_iflags_set`, "inputTypes") = c('_p_task_misc_info', '_p_unsigned_short')
class(`task_misc_info_iflags_set`) = c("SWIGFunction", class('task_misc_info_iflags_set'))

# Start of task_misc_info_iflags_get

`task_misc_info_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_misc_info_iflags_get`, 'returnType') = '_p_unsigned_short'
attr(`task_misc_info_iflags_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_iflags_get`) = c("SWIGFunction", class('task_misc_info_iflags_get'))

# Start of task_misc_info_ipolar_set

`task_misc_info_ipolar_set` = function(self, s_ipolar)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_ipolar = coerceIfNotSubclass(s_ipolar, "_p_unsigned_short") 
  .Call('R_swig_task_misc_info_ipolar_set', self, s_ipolar, PACKAGE='iris')
  
}

attr(`task_misc_info_ipolar_set`, 'returnType') = 'void'
attr(`task_misc_info_ipolar_set`, "inputTypes") = c('_p_task_misc_info', '_p_unsigned_short')
class(`task_misc_info_ipolar_set`) = c("SWIGFunction", class('task_misc_info_ipolar_set'))

# Start of task_misc_info_ipolar_get

`task_misc_info_ipolar_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_ipolar_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_misc_info_ipolar_get`, 'returnType') = '_p_unsigned_short'
attr(`task_misc_info_ipolar_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_ipolar_get`) = c("SWIGFunction", class('task_misc_info_ipolar_get'))

# Start of task_misc_info_itrunc_set

`task_misc_info_itrunc_set` = function(self, s_itrunc)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_itrunc = as.integer(s_itrunc) 
  
  if(length(s_itrunc) > 1) {
    Rf_warning("using only the first element of s_itrunc")
  }
  
  .Call('R_swig_task_misc_info_itrunc_set', self, s_itrunc, PACKAGE='iris')
  
}

attr(`task_misc_info_itrunc_set`, 'returnType') = 'void'
attr(`task_misc_info_itrunc_set`, "inputTypes") = c('_p_task_misc_info', 'numeric')
class(`task_misc_info_itrunc_set`) = c("SWIGFunction", class('task_misc_info_itrunc_set'))

# Start of task_misc_info_itrunc_get

`task_misc_info_itrunc_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  .Call('R_swig_task_misc_info_itrunc_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_misc_info_itrunc_get`, 'returnType') = 'numeric'
attr(`task_misc_info_itrunc_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_itrunc_get`) = c("SWIGFunction", class('task_misc_info_itrunc_get'))

# Start of task_misc_info_ipad32x18_set

`task_misc_info_ipad32x18_set` = function(self, s_ipad32x18)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  
  if(is.list(s_ipad32x18))
  assert(all(sapply(s_ipad32x18, class) == "_p_char"))     
  
  
#  assert(length(s_ipad32x18) >= 18)
  
  .Call('R_swig_task_misc_info_ipad32x18_set', self, s_ipad32x18, PACKAGE='iris')
  
}

attr(`task_misc_info_ipad32x18_set`, 'returnType') = 'void'
attr(`task_misc_info_ipad32x18_set`, "inputTypes") = c('_p_task_misc_info', '_p_char')
class(`task_misc_info_ipad32x18_set`) = c("SWIGFunction", class('task_misc_info_ipad32x18_set'))

# Start of task_misc_info_ipad32x18_get

`task_misc_info_ipad32x18_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_ipad32x18_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_misc_info_ipad32x18_get`, 'returnType') = '_p_char'
attr(`task_misc_info_ipad32x18_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_ipad32x18_get`) = c("SWIGFunction", class('task_misc_info_ipad32x18_get'))

# Start of task_misc_info_ipad50x12_set

`task_misc_info_ipad50x12_set` = function(self, s_ipad50x12)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  
  if(is.list(s_ipad50x12))
  assert(all(sapply(s_ipad50x12, class) == "_p_char"))     
  
  
#  assert(length(s_ipad50x12) >= 12)
  
  .Call('R_swig_task_misc_info_ipad50x12_set', self, s_ipad50x12, PACKAGE='iris')
  
}

attr(`task_misc_info_ipad50x12_set`, 'returnType') = 'void'
attr(`task_misc_info_ipad50x12_set`, "inputTypes") = c('_p_task_misc_info', '_p_char')
class(`task_misc_info_ipad50x12_set`) = c("SWIGFunction", class('task_misc_info_ipad50x12_set'))

# Start of task_misc_info_ipad50x12_get

`task_misc_info_ipad50x12_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_ipad50x12_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_misc_info_ipad50x12_get`, 'returnType') = '_p_char'
attr(`task_misc_info_ipad50x12_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_ipad50x12_get`) = c("SWIGFunction", class('task_misc_info_ipad50x12_get'))

# Start of task_misc_info_icomnt_num_set

`task_misc_info_icomnt_num_set` = function(self, s_icomnt_num)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_icomnt_num = coerceIfNotSubclass(s_icomnt_num, "_p_short") 
  .Call('R_swig_task_misc_info_icomnt_num_set', self, s_icomnt_num, PACKAGE='iris')
  
}

attr(`task_misc_info_icomnt_num_set`, 'returnType') = 'void'
attr(`task_misc_info_icomnt_num_set`, "inputTypes") = c('_p_task_misc_info', '_p_short')
class(`task_misc_info_icomnt_num_set`) = c("SWIGFunction", class('task_misc_info_icomnt_num_set'))

# Start of task_misc_info_icomnt_num_get

`task_misc_info_icomnt_num_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_icomnt_num_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_misc_info_icomnt_num_get`, 'returnType') = '_p_short'
attr(`task_misc_info_icomnt_num_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_icomnt_num_get`) = c("SWIGFunction", class('task_misc_info_icomnt_num_get'))

# Start of task_misc_info_iHorzBeamWidth_set

`task_misc_info_iHorzBeamWidth_set` = function(self, s_iHorzBeamWidth)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_iHorzBeamWidth = as.numeric(s_iHorzBeamWidth) 
  
  assert(length(s_iHorzBeamWidth) == 1 && s_iHorzBeamWidth >= 0, "All values must be non-negative")
  
  .Call('R_swig_task_misc_info_iHorzBeamWidth_set', self, s_iHorzBeamWidth, PACKAGE='iris')
  
}

attr(`task_misc_info_iHorzBeamWidth_set`, 'returnType') = 'void'
attr(`task_misc_info_iHorzBeamWidth_set`, "inputTypes") = c('_p_task_misc_info', 'numeric')
class(`task_misc_info_iHorzBeamWidth_set`) = c("SWIGFunction", class('task_misc_info_iHorzBeamWidth_set'))

# Start of task_misc_info_iHorzBeamWidth_get

`task_misc_info_iHorzBeamWidth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  .Call('R_swig_task_misc_info_iHorzBeamWidth_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_misc_info_iHorzBeamWidth_get`, 'returnType') = 'numeric'
attr(`task_misc_info_iHorzBeamWidth_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_iHorzBeamWidth_get`) = c("SWIGFunction", class('task_misc_info_iHorzBeamWidth_get'))

# Start of task_misc_info_iVertBeamWidth_set

`task_misc_info_iVertBeamWidth_set` = function(self, s_iVertBeamWidth)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_iVertBeamWidth = as.numeric(s_iVertBeamWidth) 
  
  assert(length(s_iVertBeamWidth) == 1 && s_iVertBeamWidth >= 0, "All values must be non-negative")
  
  .Call('R_swig_task_misc_info_iVertBeamWidth_set', self, s_iVertBeamWidth, PACKAGE='iris')
  
}

attr(`task_misc_info_iVertBeamWidth_set`, 'returnType') = 'void'
attr(`task_misc_info_iVertBeamWidth_set`, "inputTypes") = c('_p_task_misc_info', 'numeric')
class(`task_misc_info_iVertBeamWidth_set`) = c("SWIGFunction", class('task_misc_info_iVertBeamWidth_set'))

# Start of task_misc_info_iVertBeamWidth_get

`task_misc_info_iVertBeamWidth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  .Call('R_swig_task_misc_info_iVertBeamWidth_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_misc_info_iVertBeamWidth_get`, 'returnType') = 'numeric'
attr(`task_misc_info_iVertBeamWidth_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_iVertBeamWidth_get`) = c("SWIGFunction", class('task_misc_info_iVertBeamWidth_get'))

# Start of task_misc_info_iUser_set

`task_misc_info_iUser_set` = function(self, s_iUser)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  s_iUser = as.numeric(s_iUser) 
  
#  assert(length(s_iUser) >= 10)
  
  .Call('R_swig_task_misc_info_iUser_set', self, s_iUser, PACKAGE='iris')
  
}

attr(`task_misc_info_iUser_set`, 'returnType') = 'void'
attr(`task_misc_info_iUser_set`, "inputTypes") = c('_p_task_misc_info', '_p_unsigned_int')
class(`task_misc_info_iUser_set`) = c("SWIGFunction", class('task_misc_info_iUser_set'))

# Start of task_misc_info_iUser_get

`task_misc_info_iUser_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_iUser_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_int"
  
  ans
  
}

attr(`task_misc_info_iUser_get`, 'returnType') = '_p_unsigned_int'
attr(`task_misc_info_iUser_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_iUser_get`) = c("SWIGFunction", class('task_misc_info_iUser_get'))

# Start of task_misc_info_ipad_end_set

`task_misc_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (208))
  
  .Call('R_swig_task_misc_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_misc_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_misc_info_ipad_end_set`, "inputTypes") = c('_p_task_misc_info', '_p_char')
class(`task_misc_info_ipad_end_set`) = c("SWIGFunction", class('task_misc_info_ipad_end_set'))

# Start of task_misc_info_ipad_end_get

`task_misc_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  ans = .Call('R_swig_task_misc_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_misc_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_misc_info_ipad_end_get`, "inputTypes") = c('_p_task_misc_info')
class(`task_misc_info_ipad_end_get`) = c("SWIGFunction", class('task_misc_info_ipad_end_get'))

# Start of new_task_misc_info

`task_misc_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_misc_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_misc_info"
  
  ans
  
}

attr(`task_misc_info`, 'returnType') = '_p_task_misc_info'
class(`task_misc_info`) = c("SWIGFunction", class('task_misc_info'))

# Start of delete_task_misc_info

`delete_task_misc_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_misc_info") 
  .Call('R_swig_delete_task_misc_info', self, PACKAGE='iris')
  
}

attr(`delete_task_misc_info`, 'returnType') = 'void'
attr(`delete_task_misc_info`, "inputTypes") = c('_p_task_misc_info')
class(`delete_task_misc_info`) = c("SWIGFunction", class('delete_task_misc_info'))

# Start of accessor method for task_misc_info
setMethod('$', '_p_task_misc_info', function(x, name)

{
  accessorFuns = list('ilambda' = task_misc_info_ilambda_get, 'str_id' = task_misc_info_str_id_get, 'ixmt_pwr' = task_misc_info_ixmt_pwr_get, 'iflags' = task_misc_info_iflags_get, 'ipolar' = task_misc_info_ipolar_get, 'itrunc' = task_misc_info_itrunc_get, 'ipad32x18' = task_misc_info_ipad32x18_get, 'ipad50x12' = task_misc_info_ipad50x12_get, 'icomnt_num' = task_misc_info_icomnt_num_get, 'iHorzBeamWidth' = task_misc_info_iHorzBeamWidth_get, 'iVertBeamWidth' = task_misc_info_iVertBeamWidth_get, 'iUser' = task_misc_info_iUser_get, 'ipad_end' = task_misc_info_ipad_end_get)
  vaccessors = c('ilambda', 'str_id', 'ixmt_pwr', 'iflags', 'ipolar', 'itrunc', 'ipad32x18', 'ipad50x12', 'icomnt_num', 'iHorzBeamWidth', 'iVertBeamWidth', 'iUser', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_misc_info
# Start of accessor method for task_misc_info
setMethod('$<-', '_p_task_misc_info', function(x, name, value)

{
  accessorFuns = list('ilambda' = task_misc_info_ilambda_set, 'str_id' = task_misc_info_str_id_set, 'ixmt_pwr' = task_misc_info_ixmt_pwr_set, 'iflags' = task_misc_info_iflags_set, 'ipolar' = task_misc_info_ipolar_set, 'itrunc' = task_misc_info_itrunc_set, 'ipad32x18' = task_misc_info_ipad32x18_set, 'ipad50x12' = task_misc_info_ipad50x12_set, 'icomnt_num' = task_misc_info_icomnt_num_set, 'iHorzBeamWidth' = task_misc_info_iHorzBeamWidth_set, 'iVertBeamWidth' = task_misc_info_iVertBeamWidth_set, 'iUser' = task_misc_info_iUser_set, 'ipad_end' = task_misc_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_misc_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('ilambda' = task_misc_info_ilambda_set, 'str_id' = task_misc_info_str_id_set, 'ixmt_pwr' = task_misc_info_ixmt_pwr_set, 'iflags' = task_misc_info_iflags_set, 'ipolar' = task_misc_info_ipolar_set, 'itrunc' = task_misc_info_itrunc_set, 'ipad32x18' = task_misc_info_ipad32x18_set, 'ipad50x12' = task_misc_info_ipad50x12_set, 'icomnt_num' = task_misc_info_icomnt_num_set, 'iHorzBeamWidth' = task_misc_info_iHorzBeamWidth_set, 'iVertBeamWidth' = task_misc_info_iVertBeamWidth_set, 'iUser' = task_misc_info_iUser_set, 'ipad_end' = task_misc_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_misc_info
setMethod('delete', '_p_task_misc_info', function(obj) {delete_task_misc_info(obj)})
# Start definition of copy functions & methods for task_misc_info
CopyToR_task_misc_info = function(value, obj = new("task_misc_info"))
{
  obj@ilambda = value$ilambda
  obj@str_id = value$str_id
  obj@ixmt_pwr = value$ixmt_pwr
  obj@itrunc = value$itrunc
  obj@ipad32x18 = value$ipad32x18
  obj@ipad50x12 = value$ipad50x12
  obj@iHorzBeamWidth = value$iHorzBeamWidth
  obj@iVertBeamWidth = value$iVertBeamWidth
  obj@iUser = value$iUser
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_misc_info = function(value, obj)
{
  obj$ilambda = value@ilambda
  obj$str_id = value@str_id
  obj$ixmt_pwr = value@ixmt_pwr
  obj$itrunc = value@itrunc
  obj$ipad32x18 = value@ipad32x18
  obj$ipad50x12 = value@ipad50x12
  obj$iHorzBeamWidth = value@iHorzBeamWidth
  obj$iVertBeamWidth = value@iVertBeamWidth
  obj$iUser = value@iUser
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_misc_info
setMethod('copyToR', '_p_task_misc_info', CopyToR_task_misc_info)
setMethod('copyToC', 'task_misc_info', CopyToC_task_misc_info)

# End definition of copy methods for task_misc_info
# End definition of copy functions & methods for task_misc_info
# Start of task_end_info_id_major_set

`task_end_info_id_major_set` = function(self, s_id_major)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  s_id_major = coerceIfNotSubclass(s_id_major, "_p_short") 
  .Call('R_swig_task_end_info_id_major_set', self, s_id_major, PACKAGE='iris')
  
}

attr(`task_end_info_id_major_set`, 'returnType') = 'void'
attr(`task_end_info_id_major_set`, "inputTypes") = c('_p_task_end_info', '_p_short')
class(`task_end_info_id_major_set`) = c("SWIGFunction", class('task_end_info_id_major_set'))

# Start of task_end_info_id_major_get

`task_end_info_id_major_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_id_major_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_end_info_id_major_get`, 'returnType') = '_p_short'
attr(`task_end_info_id_major_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_id_major_get`) = c("SWIGFunction", class('task_end_info_id_major_get'))

# Start of task_end_info_id_minor_set

`task_end_info_id_minor_set` = function(self, s_id_minor)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  s_id_minor = coerceIfNotSubclass(s_id_minor, "_p_short") 
  .Call('R_swig_task_end_info_id_minor_set', self, s_id_minor, PACKAGE='iris')
  
}

attr(`task_end_info_id_minor_set`, 'returnType') = 'void'
attr(`task_end_info_id_minor_set`, "inputTypes") = c('_p_task_end_info', '_p_short')
class(`task_end_info_id_minor_set`) = c("SWIGFunction", class('task_end_info_id_minor_set'))

# Start of task_end_info_id_minor_get

`task_end_info_id_minor_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_id_minor_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_end_info_id_minor_get`, 'returnType') = '_p_short'
attr(`task_end_info_id_minor_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_id_minor_get`) = c("SWIGFunction", class('task_end_info_id_minor_get'))

# Start of task_end_info_stname_set

`task_end_info_stname_set` = function(self, s_stname)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  
  if(is.list(s_stname))
  assert(all(sapply(s_stname, class) == "_p_char"))     
  
  
#  assert(length(s_stname) >= 12)
  
  .Call('R_swig_task_end_info_stname_set', self, s_stname, PACKAGE='iris')
  
}

attr(`task_end_info_stname_set`, 'returnType') = 'void'
attr(`task_end_info_stname_set`, "inputTypes") = c('_p_task_end_info', '_p_char')
class(`task_end_info_stname_set`) = c("SWIGFunction", class('task_end_info_stname_set'))

# Start of task_end_info_stname_get

`task_end_info_stname_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_stname_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_end_info_stname_get`, 'returnType') = '_p_char'
attr(`task_end_info_stname_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_stname_get`) = c("SWIGFunction", class('task_end_info_stname_get'))

# Start of task_end_info_sdscript_set

`task_end_info_sdscript_set` = function(self, s_sdscript)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  
  if(is.list(s_sdscript))
  assert(all(sapply(s_sdscript, class) == "_p_char"))     
  
  
#  assert(length(s_sdscript) >= 80)
  
  .Call('R_swig_task_end_info_sdscript_set', self, s_sdscript, PACKAGE='iris')
  
}

attr(`task_end_info_sdscript_set`, 'returnType') = 'void'
attr(`task_end_info_sdscript_set`, "inputTypes") = c('_p_task_end_info', '_p_char')
class(`task_end_info_sdscript_set`) = c("SWIGFunction", class('task_end_info_sdscript_set'))

# Start of task_end_info_sdscript_get

`task_end_info_sdscript_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_sdscript_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_end_info_sdscript_get`, 'returnType') = '_p_char'
attr(`task_end_info_sdscript_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_sdscript_get`) = c("SWIGFunction", class('task_end_info_sdscript_get'))

# Start of task_end_info_ihybrid_count_set

`task_end_info_ihybrid_count_set` = function(self, s_ihybrid_count)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  s_ihybrid_count = as.integer(s_ihybrid_count) 
  
  if(length(s_ihybrid_count) > 1) {
    Rf_warning("using only the first element of s_ihybrid_count")
  }
  
  .Call('R_swig_task_end_info_ihybrid_count_set', self, s_ihybrid_count, PACKAGE='iris')
  
}

attr(`task_end_info_ihybrid_count_set`, 'returnType') = 'void'
attr(`task_end_info_ihybrid_count_set`, "inputTypes") = c('_p_task_end_info', 'numeric')
class(`task_end_info_ihybrid_count_set`) = c("SWIGFunction", class('task_end_info_ihybrid_count_set'))

# Start of task_end_info_ihybrid_count_get

`task_end_info_ihybrid_count_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  .Call('R_swig_task_end_info_ihybrid_count_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_end_info_ihybrid_count_get`, 'returnType') = 'numeric'
attr(`task_end_info_ihybrid_count_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_ihybrid_count_get`) = c("SWIGFunction", class('task_end_info_ihybrid_count_get'))

# Start of task_end_info_istate_set

`task_end_info_istate_set` = function(self, s_istate)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  s_istate = coerceIfNotSubclass(s_istate, "_p_unsigned_short") 
  .Call('R_swig_task_end_info_istate_set', self, s_istate, PACKAGE='iris')
  
}

attr(`task_end_info_istate_set`, 'returnType') = 'void'
attr(`task_end_info_istate_set`, "inputTypes") = c('_p_task_end_info', '_p_unsigned_short')
class(`task_end_info_istate_set`) = c("SWIGFunction", class('task_end_info_istate_set'))

# Start of task_end_info_istate_get

`task_end_info_istate_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_istate_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_end_info_istate_get`, 'returnType') = '_p_unsigned_short'
attr(`task_end_info_istate_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_istate_get`) = c("SWIGFunction", class('task_end_info_istate_get'))

# Start of task_end_info_ipad102x2_set

`task_end_info_ipad102x2_set` = function(self, s_ipad102x2)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  
  if(is.list(s_ipad102x2))
  assert(all(sapply(s_ipad102x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad102x2) >= 2)
  
  .Call('R_swig_task_end_info_ipad102x2_set', self, s_ipad102x2, PACKAGE='iris')
  
}

attr(`task_end_info_ipad102x2_set`, 'returnType') = 'void'
attr(`task_end_info_ipad102x2_set`, "inputTypes") = c('_p_task_end_info', '_p_char')
class(`task_end_info_ipad102x2_set`) = c("SWIGFunction", class('task_end_info_ipad102x2_set'))

# Start of task_end_info_ipad102x2_get

`task_end_info_ipad102x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_ipad102x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_end_info_ipad102x2_get`, 'returnType') = '_p_char'
attr(`task_end_info_ipad102x2_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_ipad102x2_get`) = c("SWIGFunction", class('task_end_info_ipad102x2_get'))

# Start of task_end_info_ing_time_set

`task_end_info_ing_time_set` = function(self, s_ing_time)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  s_ing_time = coerceIfNotSubclass(s_ing_time, "_p_ymds_time") 
  .Call('R_swig_task_end_info_ing_time_set', self, s_ing_time, PACKAGE='iris')
  
}

attr(`task_end_info_ing_time_set`, 'returnType') = 'void'
attr(`task_end_info_ing_time_set`, "inputTypes") = c('_p_task_end_info', '_p_ymds_time')
class(`task_end_info_ing_time_set`) = c("SWIGFunction", class('task_end_info_ing_time_set'))

# Start of task_end_info_ing_time_get

`task_end_info_ing_time_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_ing_time_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`task_end_info_ing_time_get`, 'returnType') = '_p_ymds_time'
attr(`task_end_info_ing_time_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_ing_time_get`) = c("SWIGFunction", class('task_end_info_ing_time_get'))

# Start of task_end_info_ipad_end_set

`task_end_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (204))
  
  .Call('R_swig_task_end_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_end_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_end_info_ipad_end_set`, "inputTypes") = c('_p_task_end_info', '_p_char')
class(`task_end_info_ipad_end_set`) = c("SWIGFunction", class('task_end_info_ipad_end_set'))

# Start of task_end_info_ipad_end_get

`task_end_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  ans = .Call('R_swig_task_end_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_end_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_end_info_ipad_end_get`, "inputTypes") = c('_p_task_end_info')
class(`task_end_info_ipad_end_get`) = c("SWIGFunction", class('task_end_info_ipad_end_get'))

# Start of new_task_end_info

`task_end_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_end_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_end_info"
  
  ans
  
}

attr(`task_end_info`, 'returnType') = '_p_task_end_info'
class(`task_end_info`) = c("SWIGFunction", class('task_end_info'))

# Start of delete_task_end_info

`delete_task_end_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_end_info") 
  .Call('R_swig_delete_task_end_info', self, PACKAGE='iris')
  
}

attr(`delete_task_end_info`, 'returnType') = 'void'
attr(`delete_task_end_info`, "inputTypes") = c('_p_task_end_info')
class(`delete_task_end_info`) = c("SWIGFunction", class('delete_task_end_info'))

# Start of accessor method for task_end_info
setMethod('$', '_p_task_end_info', function(x, name)

{
  accessorFuns = list('id_major' = task_end_info_id_major_get, 'id_minor' = task_end_info_id_minor_get, 'stname' = task_end_info_stname_get, 'sdscript' = task_end_info_sdscript_get, 'ihybrid_count' = task_end_info_ihybrid_count_get, 'istate' = task_end_info_istate_get, 'ipad102x2' = task_end_info_ipad102x2_get, 'ing_time' = task_end_info_ing_time_get, 'ipad_end' = task_end_info_ipad_end_get)
  vaccessors = c('id_major', 'id_minor', 'stname', 'sdscript', 'ihybrid_count', 'istate', 'ipad102x2', 'ing_time', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_end_info
# Start of accessor method for task_end_info
setMethod('$<-', '_p_task_end_info', function(x, name, value)

{
  accessorFuns = list('id_major' = task_end_info_id_major_set, 'id_minor' = task_end_info_id_minor_set, 'stname' = task_end_info_stname_set, 'sdscript' = task_end_info_sdscript_set, 'ihybrid_count' = task_end_info_ihybrid_count_set, 'istate' = task_end_info_istate_set, 'ipad102x2' = task_end_info_ipad102x2_set, 'ing_time' = task_end_info_ing_time_set, 'ipad_end' = task_end_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_end_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('id_major' = task_end_info_id_major_set, 'id_minor' = task_end_info_id_minor_set, 'stname' = task_end_info_stname_set, 'sdscript' = task_end_info_sdscript_set, 'ihybrid_count' = task_end_info_ihybrid_count_set, 'istate' = task_end_info_istate_set, 'ipad102x2' = task_end_info_ipad102x2_set, 'ing_time' = task_end_info_ing_time_set, 'ipad_end' = task_end_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_end_info
setMethod('delete', '_p_task_end_info', function(obj) {delete_task_end_info(obj)})
# Start definition of copy functions & methods for task_end_info
CopyToR_task_end_info = function(value, obj = new("task_end_info"))
{
  obj@stname = value$stname
  obj@sdscript = value$sdscript
  obj@ihybrid_count = value$ihybrid_count
  obj@ipad102x2 = value$ipad102x2
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_end_info = function(value, obj)
{
  obj$stname = value@stname
  obj$sdscript = value@sdscript
  obj$ihybrid_count = value@ihybrid_count
  obj$ipad102x2 = value@ipad102x2
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_end_info
setMethod('copyToR', '_p_task_end_info', CopyToR_task_end_info)
setMethod('copyToC', 'task_end_info', CopyToC_task_end_info)

# End definition of copy methods for task_end_info
# End definition of copy functions & methods for task_end_info
# Start of task_sched_info_istart_set

`task_sched_info_istart_set` = function(self, s_istart)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  s_istart = as.integer(s_istart) 
  
  if(length(s_istart) > 1) {
    Rf_warning("using only the first element of s_istart")
  }
  
  .Call('R_swig_task_sched_info_istart_set', self, s_istart, PACKAGE='iris')
  
}

attr(`task_sched_info_istart_set`, 'returnType') = 'void'
attr(`task_sched_info_istart_set`, "inputTypes") = c('_p_task_sched_info', 'numeric')
class(`task_sched_info_istart_set`) = c("SWIGFunction", class('task_sched_info_istart_set'))

# Start of task_sched_info_istart_get

`task_sched_info_istart_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  .Call('R_swig_task_sched_info_istart_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_sched_info_istart_get`, 'returnType') = 'numeric'
attr(`task_sched_info_istart_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_istart_get`) = c("SWIGFunction", class('task_sched_info_istart_get'))

# Start of task_sched_info_istop_set

`task_sched_info_istop_set` = function(self, s_istop)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  s_istop = as.integer(s_istop) 
  
  if(length(s_istop) > 1) {
    Rf_warning("using only the first element of s_istop")
  }
  
  .Call('R_swig_task_sched_info_istop_set', self, s_istop, PACKAGE='iris')
  
}

attr(`task_sched_info_istop_set`, 'returnType') = 'void'
attr(`task_sched_info_istop_set`, "inputTypes") = c('_p_task_sched_info', 'numeric')
class(`task_sched_info_istop_set`) = c("SWIGFunction", class('task_sched_info_istop_set'))

# Start of task_sched_info_istop_get

`task_sched_info_istop_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  .Call('R_swig_task_sched_info_istop_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_sched_info_istop_get`, 'returnType') = 'numeric'
attr(`task_sched_info_istop_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_istop_get`) = c("SWIGFunction", class('task_sched_info_istop_get'))

# Start of task_sched_info_iskip_set

`task_sched_info_iskip_set` = function(self, s_iskip)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  s_iskip = as.integer(s_iskip) 
  
  if(length(s_iskip) > 1) {
    Rf_warning("using only the first element of s_iskip")
  }
  
  .Call('R_swig_task_sched_info_iskip_set', self, s_iskip, PACKAGE='iris')
  
}

attr(`task_sched_info_iskip_set`, 'returnType') = 'void'
attr(`task_sched_info_iskip_set`, "inputTypes") = c('_p_task_sched_info', 'numeric')
class(`task_sched_info_iskip_set`) = c("SWIGFunction", class('task_sched_info_iskip_set'))

# Start of task_sched_info_iskip_get

`task_sched_info_iskip_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  .Call('R_swig_task_sched_info_iskip_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_sched_info_iskip_get`, 'returnType') = 'numeric'
attr(`task_sched_info_iskip_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_iskip_get`) = c("SWIGFunction", class('task_sched_info_iskip_get'))

# Start of task_sched_info_ilast_run_sec_set

`task_sched_info_ilast_run_sec_set` = function(self, s_ilast_run_sec)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  s_ilast_run_sec = as.integer(s_ilast_run_sec) 
  
  if(length(s_ilast_run_sec) > 1) {
    Rf_warning("using only the first element of s_ilast_run_sec")
  }
  
  .Call('R_swig_task_sched_info_ilast_run_sec_set', self, s_ilast_run_sec, PACKAGE='iris')
  
}

attr(`task_sched_info_ilast_run_sec_set`, 'returnType') = 'void'
attr(`task_sched_info_ilast_run_sec_set`, "inputTypes") = c('_p_task_sched_info', 'numeric')
class(`task_sched_info_ilast_run_sec_set`) = c("SWIGFunction", class('task_sched_info_ilast_run_sec_set'))

# Start of task_sched_info_ilast_run_sec_get

`task_sched_info_ilast_run_sec_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  .Call('R_swig_task_sched_info_ilast_run_sec_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_sched_info_ilast_run_sec_get`, 'returnType') = 'numeric'
attr(`task_sched_info_ilast_run_sec_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_ilast_run_sec_get`) = c("SWIGFunction", class('task_sched_info_ilast_run_sec_get'))

# Start of task_sched_info_itime_used_sec_set

`task_sched_info_itime_used_sec_set` = function(self, s_itime_used_sec)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  s_itime_used_sec = as.integer(s_itime_used_sec) 
  
  if(length(s_itime_used_sec) > 1) {
    Rf_warning("using only the first element of s_itime_used_sec")
  }
  
  .Call('R_swig_task_sched_info_itime_used_sec_set', self, s_itime_used_sec, PACKAGE='iris')
  
}

attr(`task_sched_info_itime_used_sec_set`, 'returnType') = 'void'
attr(`task_sched_info_itime_used_sec_set`, "inputTypes") = c('_p_task_sched_info', 'numeric')
class(`task_sched_info_itime_used_sec_set`) = c("SWIGFunction", class('task_sched_info_itime_used_sec_set'))

# Start of task_sched_info_itime_used_sec_get

`task_sched_info_itime_used_sec_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  .Call('R_swig_task_sched_info_itime_used_sec_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_sched_info_itime_used_sec_get`, 'returnType') = 'numeric'
attr(`task_sched_info_itime_used_sec_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_itime_used_sec_get`) = c("SWIGFunction", class('task_sched_info_itime_used_sec_get'))

# Start of task_sched_info_ilast_run_day_set

`task_sched_info_ilast_run_day_set` = function(self, s_ilast_run_day)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  s_ilast_run_day = as.integer(s_ilast_run_day) 
  
  if(length(s_ilast_run_day) > 1) {
    Rf_warning("using only the first element of s_ilast_run_day")
  }
  
  .Call('R_swig_task_sched_info_ilast_run_day_set', self, s_ilast_run_day, PACKAGE='iris')
  
}

attr(`task_sched_info_ilast_run_day_set`, 'returnType') = 'void'
attr(`task_sched_info_ilast_run_day_set`, "inputTypes") = c('_p_task_sched_info', 'numeric')
class(`task_sched_info_ilast_run_day_set`) = c("SWIGFunction", class('task_sched_info_ilast_run_day_set'))

# Start of task_sched_info_ilast_run_day_get

`task_sched_info_ilast_run_day_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  .Call('R_swig_task_sched_info_ilast_run_day_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_sched_info_ilast_run_day_get`, 'returnType') = 'numeric'
attr(`task_sched_info_ilast_run_day_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_ilast_run_day_get`) = c("SWIGFunction", class('task_sched_info_ilast_run_day_get'))

# Start of task_sched_info_iflag_set

`task_sched_info_iflag_set` = function(self, s_iflag)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  s_iflag = coerceIfNotSubclass(s_iflag, "_p_unsigned_short") 
  .Call('R_swig_task_sched_info_iflag_set', self, s_iflag, PACKAGE='iris')
  
}

attr(`task_sched_info_iflag_set`, 'returnType') = 'void'
attr(`task_sched_info_iflag_set`, "inputTypes") = c('_p_task_sched_info', '_p_unsigned_short')
class(`task_sched_info_iflag_set`) = c("SWIGFunction", class('task_sched_info_iflag_set'))

# Start of task_sched_info_iflag_get

`task_sched_info_iflag_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  ans = .Call('R_swig_task_sched_info_iflag_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_sched_info_iflag_get`, 'returnType') = '_p_unsigned_short'
attr(`task_sched_info_iflag_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_iflag_get`) = c("SWIGFunction", class('task_sched_info_iflag_get'))

# Start of task_sched_info_ipad_end_set

`task_sched_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (94))
  
  .Call('R_swig_task_sched_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_sched_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_sched_info_ipad_end_set`, "inputTypes") = c('_p_task_sched_info', '_p_char')
class(`task_sched_info_ipad_end_set`) = c("SWIGFunction", class('task_sched_info_ipad_end_set'))

# Start of task_sched_info_ipad_end_get

`task_sched_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  ans = .Call('R_swig_task_sched_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_sched_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_sched_info_ipad_end_get`, "inputTypes") = c('_p_task_sched_info')
class(`task_sched_info_ipad_end_get`) = c("SWIGFunction", class('task_sched_info_ipad_end_get'))

# Start of new_task_sched_info

`task_sched_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_sched_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_sched_info"
  
  ans
  
}

attr(`task_sched_info`, 'returnType') = '_p_task_sched_info'
class(`task_sched_info`) = c("SWIGFunction", class('task_sched_info'))

# Start of delete_task_sched_info

`delete_task_sched_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_sched_info") 
  .Call('R_swig_delete_task_sched_info', self, PACKAGE='iris')
  
}

attr(`delete_task_sched_info`, 'returnType') = 'void'
attr(`delete_task_sched_info`, "inputTypes") = c('_p_task_sched_info')
class(`delete_task_sched_info`) = c("SWIGFunction", class('delete_task_sched_info'))

# Start of accessor method for task_sched_info
setMethod('$', '_p_task_sched_info', function(x, name)

{
  accessorFuns = list('istart' = task_sched_info_istart_get, 'istop' = task_sched_info_istop_get, 'iskip' = task_sched_info_iskip_get, 'ilast_run_sec' = task_sched_info_ilast_run_sec_get, 'itime_used_sec' = task_sched_info_itime_used_sec_get, 'ilast_run_day' = task_sched_info_ilast_run_day_get, 'iflag' = task_sched_info_iflag_get, 'ipad_end' = task_sched_info_ipad_end_get)
  vaccessors = c('istart', 'istop', 'iskip', 'ilast_run_sec', 'itime_used_sec', 'ilast_run_day', 'iflag', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_sched_info
# Start of accessor method for task_sched_info
setMethod('$<-', '_p_task_sched_info', function(x, name, value)

{
  accessorFuns = list('istart' = task_sched_info_istart_set, 'istop' = task_sched_info_istop_set, 'iskip' = task_sched_info_iskip_set, 'ilast_run_sec' = task_sched_info_ilast_run_sec_set, 'itime_used_sec' = task_sched_info_itime_used_sec_set, 'ilast_run_day' = task_sched_info_ilast_run_day_set, 'iflag' = task_sched_info_iflag_set, 'ipad_end' = task_sched_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_sched_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('istart' = task_sched_info_istart_set, 'istop' = task_sched_info_istop_set, 'iskip' = task_sched_info_iskip_set, 'ilast_run_sec' = task_sched_info_ilast_run_sec_set, 'itime_used_sec' = task_sched_info_itime_used_sec_set, 'ilast_run_day' = task_sched_info_ilast_run_day_set, 'iflag' = task_sched_info_iflag_set, 'ipad_end' = task_sched_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_sched_info
setMethod('delete', '_p_task_sched_info', function(obj) {delete_task_sched_info(obj)})
# Start definition of copy functions & methods for task_sched_info
CopyToR_task_sched_info = function(value, obj = new("task_sched_info"))
{
  obj@istart = value$istart
  obj@istop = value$istop
  obj@iskip = value$iskip
  obj@ilast_run_sec = value$ilast_run_sec
  obj@itime_used_sec = value$itime_used_sec
  obj@ilast_run_day = value$ilast_run_day
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_sched_info = function(value, obj)
{
  obj$istart = value@istart
  obj$istop = value@istop
  obj$iskip = value@iskip
  obj$ilast_run_sec = value@ilast_run_sec
  obj$itime_used_sec = value@itime_used_sec
  obj$ilast_run_day = value@ilast_run_day
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_sched_info
setMethod('copyToR', '_p_task_sched_info', CopyToR_task_sched_info)
setMethod('copyToC', 'task_sched_info', CopyToC_task_sched_info)

# End definition of copy methods for task_sched_info
# End definition of copy functions & methods for task_sched_info
# Start of task_dsp_mode_batch_iLoPrf_set

`task_dsp_mode_batch_iLoPrf_set` = function(self, s_iLoPrf)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  s_iLoPrf = coerceIfNotSubclass(s_iLoPrf, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_mode_batch_iLoPrf_set', self, s_iLoPrf, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_iLoPrf_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_iLoPrf_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_unsigned_short')
class(`task_dsp_mode_batch_iLoPrf_set`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoPrf_set'))

# Start of task_dsp_mode_batch_iLoPrf_get

`task_dsp_mode_batch_iLoPrf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_iLoPrf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_mode_batch_iLoPrf_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_mode_batch_iLoPrf_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_iLoPrf_get`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoPrf_get'))

# Start of task_dsp_mode_batch_iLoPrfFract_set

`task_dsp_mode_batch_iLoPrfFract_set` = function(self, s_iLoPrfFract)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  s_iLoPrfFract = coerceIfNotSubclass(s_iLoPrfFract, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_mode_batch_iLoPrfFract_set', self, s_iLoPrfFract, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_iLoPrfFract_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_iLoPrfFract_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_unsigned_short')
class(`task_dsp_mode_batch_iLoPrfFract_set`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoPrfFract_set'))

# Start of task_dsp_mode_batch_iLoPrfFract_get

`task_dsp_mode_batch_iLoPrfFract_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_iLoPrfFract_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_mode_batch_iLoPrfFract_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_mode_batch_iLoPrfFract_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_iLoPrfFract_get`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoPrfFract_get'))

# Start of task_dsp_mode_batch_iLoSampleSize_set

`task_dsp_mode_batch_iLoSampleSize_set` = function(self, s_iLoSampleSize)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  s_iLoSampleSize = coerceIfNotSubclass(s_iLoSampleSize, "_p_short") 
  .Call('R_swig_task_dsp_mode_batch_iLoSampleSize_set', self, s_iLoSampleSize, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_iLoSampleSize_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_iLoSampleSize_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_short')
class(`task_dsp_mode_batch_iLoSampleSize_set`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoSampleSize_set'))

# Start of task_dsp_mode_batch_iLoSampleSize_get

`task_dsp_mode_batch_iLoSampleSize_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_iLoSampleSize_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_mode_batch_iLoSampleSize_get`, 'returnType') = '_p_short'
attr(`task_dsp_mode_batch_iLoSampleSize_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_iLoSampleSize_get`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoSampleSize_get'))

# Start of task_dsp_mode_batch_iLoAvgSide_set

`task_dsp_mode_batch_iLoAvgSide_set` = function(self, s_iLoAvgSide)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  s_iLoAvgSide = coerceIfNotSubclass(s_iLoAvgSide, "_p_short") 
  .Call('R_swig_task_dsp_mode_batch_iLoAvgSide_set', self, s_iLoAvgSide, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_iLoAvgSide_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_iLoAvgSide_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_short')
class(`task_dsp_mode_batch_iLoAvgSide_set`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoAvgSide_set'))

# Start of task_dsp_mode_batch_iLoAvgSide_get

`task_dsp_mode_batch_iLoAvgSide_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_iLoAvgSide_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_mode_batch_iLoAvgSide_get`, 'returnType') = '_p_short'
attr(`task_dsp_mode_batch_iLoAvgSide_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_iLoAvgSide_get`) = c("SWIGFunction", class('task_dsp_mode_batch_iLoAvgSide_get'))

# Start of task_dsp_mode_batch_idBOverRefl_set

`task_dsp_mode_batch_idBOverRefl_set` = function(self, s_idBOverRefl)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  s_idBOverRefl = coerceIfNotSubclass(s_idBOverRefl, "_p_short") 
  .Call('R_swig_task_dsp_mode_batch_idBOverRefl_set', self, s_idBOverRefl, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_idBOverRefl_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_idBOverRefl_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_short')
class(`task_dsp_mode_batch_idBOverRefl_set`) = c("SWIGFunction", class('task_dsp_mode_batch_idBOverRefl_set'))

# Start of task_dsp_mode_batch_idBOverRefl_get

`task_dsp_mode_batch_idBOverRefl_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_idBOverRefl_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_mode_batch_idBOverRefl_get`, 'returnType') = '_p_short'
attr(`task_dsp_mode_batch_idBOverRefl_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_idBOverRefl_get`) = c("SWIGFunction", class('task_dsp_mode_batch_idBOverRefl_get'))

# Start of task_dsp_mode_batch_idBOverVel_set

`task_dsp_mode_batch_idBOverVel_set` = function(self, s_idBOverVel)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  s_idBOverVel = coerceIfNotSubclass(s_idBOverVel, "_p_short") 
  .Call('R_swig_task_dsp_mode_batch_idBOverVel_set', self, s_idBOverVel, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_idBOverVel_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_idBOverVel_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_short')
class(`task_dsp_mode_batch_idBOverVel_set`) = c("SWIGFunction", class('task_dsp_mode_batch_idBOverVel_set'))

# Start of task_dsp_mode_batch_idBOverVel_get

`task_dsp_mode_batch_idBOverVel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_idBOverVel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_mode_batch_idBOverVel_get`, 'returnType') = '_p_short'
attr(`task_dsp_mode_batch_idBOverVel_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_idBOverVel_get`) = c("SWIGFunction", class('task_dsp_mode_batch_idBOverVel_get'))

# Start of task_dsp_mode_batch_idBOverWid_set

`task_dsp_mode_batch_idBOverWid_set` = function(self, s_idBOverWid)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  s_idBOverWid = coerceIfNotSubclass(s_idBOverWid, "_p_short") 
  .Call('R_swig_task_dsp_mode_batch_idBOverWid_set', self, s_idBOverWid, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_idBOverWid_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_idBOverWid_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_short')
class(`task_dsp_mode_batch_idBOverWid_set`) = c("SWIGFunction", class('task_dsp_mode_batch_idBOverWid_set'))

# Start of task_dsp_mode_batch_idBOverWid_get

`task_dsp_mode_batch_idBOverWid_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_idBOverWid_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_mode_batch_idBOverWid_get`, 'returnType') = '_p_short'
attr(`task_dsp_mode_batch_idBOverWid_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_idBOverWid_get`) = c("SWIGFunction", class('task_dsp_mode_batch_idBOverWid_get'))

# Start of task_dsp_mode_batch_ipad_end_set

`task_dsp_mode_batch_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (18))
  
  .Call('R_swig_task_dsp_mode_batch_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_dsp_mode_batch_ipad_end_set`, 'returnType') = 'void'
attr(`task_dsp_mode_batch_ipad_end_set`, "inputTypes") = c('_p_task_dsp_mode_batch', '_p_char')
class(`task_dsp_mode_batch_ipad_end_set`) = c("SWIGFunction", class('task_dsp_mode_batch_ipad_end_set'))

# Start of task_dsp_mode_batch_ipad_end_get

`task_dsp_mode_batch_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  ans = .Call('R_swig_task_dsp_mode_batch_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_dsp_mode_batch_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_dsp_mode_batch_ipad_end_get`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`task_dsp_mode_batch_ipad_end_get`) = c("SWIGFunction", class('task_dsp_mode_batch_ipad_end_get'))

# Start of new_task_dsp_mode_batch

`task_dsp_mode_batch` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_dsp_mode_batch', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_dsp_mode_batch"
  
  ans
  
}

attr(`task_dsp_mode_batch`, 'returnType') = '_p_task_dsp_mode_batch'
class(`task_dsp_mode_batch`) = c("SWIGFunction", class('task_dsp_mode_batch'))

# Start of delete_task_dsp_mode_batch

`delete_task_dsp_mode_batch` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_batch") 
  .Call('R_swig_delete_task_dsp_mode_batch', self, PACKAGE='iris')
  
}

attr(`delete_task_dsp_mode_batch`, 'returnType') = 'void'
attr(`delete_task_dsp_mode_batch`, "inputTypes") = c('_p_task_dsp_mode_batch')
class(`delete_task_dsp_mode_batch`) = c("SWIGFunction", class('delete_task_dsp_mode_batch'))

# Start of accessor method for task_dsp_mode_batch
setMethod('$', '_p_task_dsp_mode_batch', function(x, name)

{
  accessorFuns = list('iLoPrf' = task_dsp_mode_batch_iLoPrf_get, 'iLoPrfFract' = task_dsp_mode_batch_iLoPrfFract_get, 'iLoSampleSize' = task_dsp_mode_batch_iLoSampleSize_get, 'iLoAvgSide' = task_dsp_mode_batch_iLoAvgSide_get, 'idBOverRefl' = task_dsp_mode_batch_idBOverRefl_get, 'idBOverVel' = task_dsp_mode_batch_idBOverVel_get, 'idBOverWid' = task_dsp_mode_batch_idBOverWid_get, 'ipad_end' = task_dsp_mode_batch_ipad_end_get)
  vaccessors = c('iLoPrf', 'iLoPrfFract', 'iLoSampleSize', 'iLoAvgSide', 'idBOverRefl', 'idBOverVel', 'idBOverWid', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_dsp_mode_batch
# Start of accessor method for task_dsp_mode_batch
setMethod('$<-', '_p_task_dsp_mode_batch', function(x, name, value)

{
  accessorFuns = list('iLoPrf' = task_dsp_mode_batch_iLoPrf_set, 'iLoPrfFract' = task_dsp_mode_batch_iLoPrfFract_set, 'iLoSampleSize' = task_dsp_mode_batch_iLoSampleSize_set, 'iLoAvgSide' = task_dsp_mode_batch_iLoAvgSide_set, 'idBOverRefl' = task_dsp_mode_batch_idBOverRefl_set, 'idBOverVel' = task_dsp_mode_batch_idBOverVel_set, 'idBOverWid' = task_dsp_mode_batch_idBOverWid_set, 'ipad_end' = task_dsp_mode_batch_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_dsp_mode_batch', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iLoPrf' = task_dsp_mode_batch_iLoPrf_set, 'iLoPrfFract' = task_dsp_mode_batch_iLoPrfFract_set, 'iLoSampleSize' = task_dsp_mode_batch_iLoSampleSize_set, 'iLoAvgSide' = task_dsp_mode_batch_iLoAvgSide_set, 'idBOverRefl' = task_dsp_mode_batch_idBOverRefl_set, 'idBOverVel' = task_dsp_mode_batch_idBOverVel_set, 'idBOverWid' = task_dsp_mode_batch_idBOverWid_set, 'ipad_end' = task_dsp_mode_batch_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_dsp_mode_batch
setMethod('delete', '_p_task_dsp_mode_batch', function(obj) {delete_task_dsp_mode_batch(obj)})
# Start definition of copy functions & methods for task_dsp_mode_batch
CopyToR_task_dsp_mode_batch = function(value, obj = new("task_dsp_mode_batch"))
{
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_dsp_mode_batch = function(value, obj)
{
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_dsp_mode_batch
setMethod('copyToR', '_p_task_dsp_mode_batch', CopyToR_task_dsp_mode_batch)
setMethod('copyToC', 'task_dsp_mode_batch', CopyToC_task_dsp_mode_batch)

# End definition of copy methods for task_dsp_mode_batch
# End definition of copy functions & methods for task_dsp_mode_batch
# Start of task_dsp_mode_other_imisc_set

`task_dsp_mode_other_imisc_set` = function(self, s_imisc)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_other") 
  
  if(is.list(s_imisc))
  assert(all(sapply(s_imisc, class) == "_p_short"))     
  
  
#  assert(length(s_imisc) >= 32/2)
  
  .Call('R_swig_task_dsp_mode_other_imisc_set', self, s_imisc, PACKAGE='iris')
  
}

attr(`task_dsp_mode_other_imisc_set`, 'returnType') = 'void'
attr(`task_dsp_mode_other_imisc_set`, "inputTypes") = c('_p_task_dsp_mode_other', '_p_short')
class(`task_dsp_mode_other_imisc_set`) = c("SWIGFunction", class('task_dsp_mode_other_imisc_set'))

# Start of task_dsp_mode_other_imisc_get

`task_dsp_mode_other_imisc_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_other") 
  ans = .Call('R_swig_task_dsp_mode_other_imisc_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_mode_other_imisc_get`, 'returnType') = '_p_short'
attr(`task_dsp_mode_other_imisc_get`, "inputTypes") = c('_p_task_dsp_mode_other')
class(`task_dsp_mode_other_imisc_get`) = c("SWIGFunction", class('task_dsp_mode_other_imisc_get'))

# Start of new_task_dsp_mode_other

`task_dsp_mode_other` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_dsp_mode_other', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_dsp_mode_other"
  
  ans
  
}

attr(`task_dsp_mode_other`, 'returnType') = '_p_task_dsp_mode_other'
class(`task_dsp_mode_other`) = c("SWIGFunction", class('task_dsp_mode_other'))

# Start of delete_task_dsp_mode_other

`delete_task_dsp_mode_other` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_other") 
  .Call('R_swig_delete_task_dsp_mode_other', self, PACKAGE='iris')
  
}

attr(`delete_task_dsp_mode_other`, 'returnType') = 'void'
attr(`delete_task_dsp_mode_other`, "inputTypes") = c('_p_task_dsp_mode_other')
class(`delete_task_dsp_mode_other`) = c("SWIGFunction", class('delete_task_dsp_mode_other'))

# Start of accessor method for task_dsp_mode_other
setMethod('$', '_p_task_dsp_mode_other', function(x, name)

{
  accessorFuns = list('imisc' = task_dsp_mode_other_imisc_get)
  vaccessors = c('imisc')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_dsp_mode_other
# Start of accessor method for task_dsp_mode_other
setMethod('$<-', '_p_task_dsp_mode_other', function(x, name, value)

{
  accessorFuns = list('imisc' = task_dsp_mode_other_imisc_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_dsp_mode_other', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('imisc' = task_dsp_mode_other_imisc_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_dsp_mode_other
setMethod('delete', '_p_task_dsp_mode_other', function(obj) {delete_task_dsp_mode_other(obj)})
# Start definition of copy functions & methods for task_dsp_mode_other
CopyToR_task_dsp_mode_other = function(value, obj = new("task_dsp_mode_other"))
{
  obj
}



CopyToC_task_dsp_mode_other = function(value, obj)
{
  obj
}



# Start definition of copy methods for task_dsp_mode_other
setMethod('copyToR', '_p_task_dsp_mode_other', CopyToR_task_dsp_mode_other)
setMethod('copyToC', 'task_dsp_mode_other', CopyToC_task_dsp_mode_other)

# End definition of copy methods for task_dsp_mode_other
# End definition of copy functions & methods for task_dsp_mode_other
# Start of task_dsp_mode_u_batch_set

`task_dsp_mode_u_batch_set` = function(self, s_batch)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_u") 
  s_batch = coerceIfNotSubclass(s_batch, "_p_task_dsp_mode_batch") 
  .Call('R_swig_task_dsp_mode_u_batch_set', self, s_batch, PACKAGE='iris')
  
}

attr(`task_dsp_mode_u_batch_set`, 'returnType') = 'void'
attr(`task_dsp_mode_u_batch_set`, "inputTypes") = c('_p_task_dsp_mode_u', '_p_task_dsp_mode_batch')
class(`task_dsp_mode_u_batch_set`) = c("SWIGFunction", class('task_dsp_mode_u_batch_set'))

# Start of task_dsp_mode_u_batch_get

`task_dsp_mode_u_batch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_u") 
  ans = .Call('R_swig_task_dsp_mode_u_batch_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_dsp_mode_batch"
  
  ans
  
}

attr(`task_dsp_mode_u_batch_get`, 'returnType') = '_p_task_dsp_mode_batch'
attr(`task_dsp_mode_u_batch_get`, "inputTypes") = c('_p_task_dsp_mode_u')
class(`task_dsp_mode_u_batch_get`) = c("SWIGFunction", class('task_dsp_mode_u_batch_get'))

# Start of task_dsp_mode_u_other_set

`task_dsp_mode_u_other_set` = function(self, s_other)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_u") 
  s_other = coerceIfNotSubclass(s_other, "_p_task_dsp_mode_other") 
  .Call('R_swig_task_dsp_mode_u_other_set', self, s_other, PACKAGE='iris')
  
}

attr(`task_dsp_mode_u_other_set`, 'returnType') = 'void'
attr(`task_dsp_mode_u_other_set`, "inputTypes") = c('_p_task_dsp_mode_u', '_p_task_dsp_mode_other')
class(`task_dsp_mode_u_other_set`) = c("SWIGFunction", class('task_dsp_mode_u_other_set'))

# Start of task_dsp_mode_u_other_get

`task_dsp_mode_u_other_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_u") 
  ans = .Call('R_swig_task_dsp_mode_u_other_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_dsp_mode_other"
  
  ans
  
}

attr(`task_dsp_mode_u_other_get`, 'returnType') = '_p_task_dsp_mode_other'
attr(`task_dsp_mode_u_other_get`, "inputTypes") = c('_p_task_dsp_mode_u')
class(`task_dsp_mode_u_other_get`) = c("SWIGFunction", class('task_dsp_mode_u_other_get'))

# Start of new_task_dsp_mode_u

`task_dsp_mode_u` = function()
{
  ans = .Call('R_swig_new_task_dsp_mode_u', PACKAGE='iris')
  class(ans) <- "_p_task_dsp_mode_u"
  
  ans
  
}

attr(`task_dsp_mode_u`, 'returnType') = '_p_task_dsp_mode_u'
class(`task_dsp_mode_u`) = c("SWIGFunction", class('task_dsp_mode_u'))

# Start of delete_task_dsp_mode_u

`delete_task_dsp_mode_u` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_mode_u") 
  .Call('R_swig_delete_task_dsp_mode_u', self, PACKAGE='iris')
  
}

attr(`delete_task_dsp_mode_u`, 'returnType') = 'void'
attr(`delete_task_dsp_mode_u`, "inputTypes") = c('_p_task_dsp_mode_u')
class(`delete_task_dsp_mode_u`) = c("SWIGFunction", class('delete_task_dsp_mode_u'))

# Start of accessor method for task_dsp_mode_u
setMethod('$', '_p_task_dsp_mode_u', function(x, name)

{
  accessorFuns = list('batch' = task_dsp_mode_u_batch_get, 'other' = task_dsp_mode_u_other_get)
  vaccessors = c('batch', 'other')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_dsp_mode_u
# Start of accessor method for task_dsp_mode_u
setMethod('$<-', '_p_task_dsp_mode_u', function(x, name, value)

{
  accessorFuns = list('batch' = task_dsp_mode_u_batch_set, 'other' = task_dsp_mode_u_other_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_dsp_mode_u', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('batch' = task_dsp_mode_u_batch_set, 'other' = task_dsp_mode_u_other_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_dsp_mode_u
setMethod('delete', '_p_task_dsp_mode_u', function(obj) {delete_task_dsp_mode_u(obj)})
# Start of dsp_data_mask_iWord0_set

`dsp_data_mask_iWord0_set` = function(self, s_iWord0)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  s_iWord0 = as.numeric(s_iWord0) 
  
  assert(length(s_iWord0) == 1 && s_iWord0 >= 0, "All values must be non-negative")
  
  .Call('R_swig_dsp_data_mask_iWord0_set', self, s_iWord0, PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord0_set`, 'returnType') = 'void'
attr(`dsp_data_mask_iWord0_set`, "inputTypes") = c('_p_dsp_data_mask', 'numeric')
class(`dsp_data_mask_iWord0_set`) = c("SWIGFunction", class('dsp_data_mask_iWord0_set'))

# Start of dsp_data_mask_iWord0_get

`dsp_data_mask_iWord0_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  .Call('R_swig_dsp_data_mask_iWord0_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord0_get`, 'returnType') = 'numeric'
attr(`dsp_data_mask_iWord0_get`, "inputTypes") = c('_p_dsp_data_mask')
class(`dsp_data_mask_iWord0_get`) = c("SWIGFunction", class('dsp_data_mask_iWord0_get'))

# Start of dsp_data_mask_iXhdrType_set

`dsp_data_mask_iXhdrType_set` = function(self, s_iXhdrType)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  s_iXhdrType = as.numeric(s_iXhdrType) 
  
  assert(length(s_iXhdrType) == 1 && s_iXhdrType >= 0, "All values must be non-negative")
  
  .Call('R_swig_dsp_data_mask_iXhdrType_set', self, s_iXhdrType, PACKAGE='iris')
  
}

attr(`dsp_data_mask_iXhdrType_set`, 'returnType') = 'void'
attr(`dsp_data_mask_iXhdrType_set`, "inputTypes") = c('_p_dsp_data_mask', 'numeric')
class(`dsp_data_mask_iXhdrType_set`) = c("SWIGFunction", class('dsp_data_mask_iXhdrType_set'))

# Start of dsp_data_mask_iXhdrType_get

`dsp_data_mask_iXhdrType_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  .Call('R_swig_dsp_data_mask_iXhdrType_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dsp_data_mask_iXhdrType_get`, 'returnType') = 'numeric'
attr(`dsp_data_mask_iXhdrType_get`, "inputTypes") = c('_p_dsp_data_mask')
class(`dsp_data_mask_iXhdrType_get`) = c("SWIGFunction", class('dsp_data_mask_iXhdrType_get'))

# Start of dsp_data_mask_iWord1_set

`dsp_data_mask_iWord1_set` = function(self, s_iWord1)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  s_iWord1 = as.numeric(s_iWord1) 
  
  assert(length(s_iWord1) == 1 && s_iWord1 >= 0, "All values must be non-negative")
  
  .Call('R_swig_dsp_data_mask_iWord1_set', self, s_iWord1, PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord1_set`, 'returnType') = 'void'
attr(`dsp_data_mask_iWord1_set`, "inputTypes") = c('_p_dsp_data_mask', 'numeric')
class(`dsp_data_mask_iWord1_set`) = c("SWIGFunction", class('dsp_data_mask_iWord1_set'))

# Start of dsp_data_mask_iWord1_get

`dsp_data_mask_iWord1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  .Call('R_swig_dsp_data_mask_iWord1_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord1_get`, 'returnType') = 'numeric'
attr(`dsp_data_mask_iWord1_get`, "inputTypes") = c('_p_dsp_data_mask')
class(`dsp_data_mask_iWord1_get`) = c("SWIGFunction", class('dsp_data_mask_iWord1_get'))

# Start of dsp_data_mask_iWord2_set

`dsp_data_mask_iWord2_set` = function(self, s_iWord2)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  s_iWord2 = as.numeric(s_iWord2) 
  
  assert(length(s_iWord2) == 1 && s_iWord2 >= 0, "All values must be non-negative")
  
  .Call('R_swig_dsp_data_mask_iWord2_set', self, s_iWord2, PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord2_set`, 'returnType') = 'void'
attr(`dsp_data_mask_iWord2_set`, "inputTypes") = c('_p_dsp_data_mask', 'numeric')
class(`dsp_data_mask_iWord2_set`) = c("SWIGFunction", class('dsp_data_mask_iWord2_set'))

# Start of dsp_data_mask_iWord2_get

`dsp_data_mask_iWord2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  .Call('R_swig_dsp_data_mask_iWord2_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord2_get`, 'returnType') = 'numeric'
attr(`dsp_data_mask_iWord2_get`, "inputTypes") = c('_p_dsp_data_mask')
class(`dsp_data_mask_iWord2_get`) = c("SWIGFunction", class('dsp_data_mask_iWord2_get'))

# Start of dsp_data_mask_iWord3_set

`dsp_data_mask_iWord3_set` = function(self, s_iWord3)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  s_iWord3 = as.numeric(s_iWord3) 
  
  assert(length(s_iWord3) == 1 && s_iWord3 >= 0, "All values must be non-negative")
  
  .Call('R_swig_dsp_data_mask_iWord3_set', self, s_iWord3, PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord3_set`, 'returnType') = 'void'
attr(`dsp_data_mask_iWord3_set`, "inputTypes") = c('_p_dsp_data_mask', 'numeric')
class(`dsp_data_mask_iWord3_set`) = c("SWIGFunction", class('dsp_data_mask_iWord3_set'))

# Start of dsp_data_mask_iWord3_get

`dsp_data_mask_iWord3_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  .Call('R_swig_dsp_data_mask_iWord3_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord3_get`, 'returnType') = 'numeric'
attr(`dsp_data_mask_iWord3_get`, "inputTypes") = c('_p_dsp_data_mask')
class(`dsp_data_mask_iWord3_get`) = c("SWIGFunction", class('dsp_data_mask_iWord3_get'))

# Start of dsp_data_mask_iWord4_set

`dsp_data_mask_iWord4_set` = function(self, s_iWord4)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  s_iWord4 = as.numeric(s_iWord4) 
  
  assert(length(s_iWord4) == 1 && s_iWord4 >= 0, "All values must be non-negative")
  
  .Call('R_swig_dsp_data_mask_iWord4_set', self, s_iWord4, PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord4_set`, 'returnType') = 'void'
attr(`dsp_data_mask_iWord4_set`, "inputTypes") = c('_p_dsp_data_mask', 'numeric')
class(`dsp_data_mask_iWord4_set`) = c("SWIGFunction", class('dsp_data_mask_iWord4_set'))

# Start of dsp_data_mask_iWord4_get

`dsp_data_mask_iWord4_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  .Call('R_swig_dsp_data_mask_iWord4_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`dsp_data_mask_iWord4_get`, 'returnType') = 'numeric'
attr(`dsp_data_mask_iWord4_get`, "inputTypes") = c('_p_dsp_data_mask')
class(`dsp_data_mask_iWord4_get`) = c("SWIGFunction", class('dsp_data_mask_iWord4_get'))

# Start of new_dsp_data_mask

`dsp_data_mask` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_dsp_data_mask', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dsp_data_mask"
  
  ans
  
}

attr(`dsp_data_mask`, 'returnType') = '_p_dsp_data_mask'
class(`dsp_data_mask`) = c("SWIGFunction", class('dsp_data_mask'))

# Start of delete_dsp_data_mask

`delete_dsp_data_mask` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_dsp_data_mask") 
  .Call('R_swig_delete_dsp_data_mask', self, PACKAGE='iris')
  
}

attr(`delete_dsp_data_mask`, 'returnType') = 'void'
attr(`delete_dsp_data_mask`, "inputTypes") = c('_p_dsp_data_mask')
class(`delete_dsp_data_mask`) = c("SWIGFunction", class('delete_dsp_data_mask'))

# Start of accessor method for dsp_data_mask
setMethod('$', '_p_dsp_data_mask', function(x, name)

{
  accessorFuns = list('iWord0' = dsp_data_mask_iWord0_get, 'iXhdrType' = dsp_data_mask_iXhdrType_get, 'iWord1' = dsp_data_mask_iWord1_get, 'iWord2' = dsp_data_mask_iWord2_get, 'iWord3' = dsp_data_mask_iWord3_get, 'iWord4' = dsp_data_mask_iWord4_get)
  vaccessors = c('iWord0', 'iXhdrType', 'iWord1', 'iWord2', 'iWord3', 'iWord4')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for dsp_data_mask
# Start of accessor method for dsp_data_mask
setMethod('$<-', '_p_dsp_data_mask', function(x, name, value)

{
  accessorFuns = list('iWord0' = dsp_data_mask_iWord0_set, 'iXhdrType' = dsp_data_mask_iXhdrType_set, 'iWord1' = dsp_data_mask_iWord1_set, 'iWord2' = dsp_data_mask_iWord2_set, 'iWord3' = dsp_data_mask_iWord3_set, 'iWord4' = dsp_data_mask_iWord4_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_dsp_data_mask', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iWord0' = dsp_data_mask_iWord0_set, 'iXhdrType' = dsp_data_mask_iXhdrType_set, 'iWord1' = dsp_data_mask_iWord1_set, 'iWord2' = dsp_data_mask_iWord2_set, 'iWord3' = dsp_data_mask_iWord3_set, 'iWord4' = dsp_data_mask_iWord4_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for dsp_data_mask
setMethod('delete', '_p_dsp_data_mask', function(obj) {delete_dsp_data_mask(obj)})
# Start definition of copy functions & methods for dsp_data_mask
CopyToR_dsp_data_mask = function(value, obj = new("dsp_data_mask"))
{
  obj@iWord0 = value$iWord0
  obj@iXhdrType = value$iXhdrType
  obj@iWord1 = value$iWord1
  obj@iWord2 = value$iWord2
  obj@iWord3 = value$iWord3
  obj@iWord4 = value$iWord4
  obj
}



CopyToC_dsp_data_mask = function(value, obj)
{
  obj$iWord0 = value@iWord0
  obj$iXhdrType = value@iXhdrType
  obj$iWord1 = value@iWord1
  obj$iWord2 = value@iWord2
  obj$iWord3 = value@iWord3
  obj$iWord4 = value@iWord4
  obj
}



# Start definition of copy methods for dsp_data_mask
setMethod('copyToR', '_p_dsp_data_mask', CopyToR_dsp_data_mask)
setMethod('copyToC', 'dsp_data_mask', CopyToC_dsp_data_mask)

# End definition of copy methods for dsp_data_mask
# End definition of copy functions & methods for dsp_data_mask
# Start of task_dsp_info_imajor_mode_set

`task_dsp_info_imajor_mode_set` = function(self, s_imajor_mode)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_imajor_mode = coerceIfNotSubclass(s_imajor_mode, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_imajor_mode_set', self, s_imajor_mode, PACKAGE='iris')
  
}

attr(`task_dsp_info_imajor_mode_set`, 'returnType') = 'void'
attr(`task_dsp_info_imajor_mode_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_imajor_mode_set`) = c("SWIGFunction", class('task_dsp_info_imajor_mode_set'))

# Start of task_dsp_info_imajor_mode_get

`task_dsp_info_imajor_mode_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_imajor_mode_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_imajor_mode_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_imajor_mode_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_imajor_mode_get`) = c("SWIGFunction", class('task_dsp_info_imajor_mode_get'))

# Start of task_dsp_info_idsptype_set

`task_dsp_info_idsptype_set` = function(self, s_idsptype)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_idsptype = coerceIfNotSubclass(s_idsptype, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_idsptype_set', self, s_idsptype, PACKAGE='iris')
  
}

attr(`task_dsp_info_idsptype_set`, 'returnType') = 'void'
attr(`task_dsp_info_idsptype_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_idsptype_set`) = c("SWIGFunction", class('task_dsp_info_idsptype_set'))

# Start of task_dsp_info_idsptype_get

`task_dsp_info_idsptype_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_idsptype_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_idsptype_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_idsptype_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_idsptype_get`) = c("SWIGFunction", class('task_dsp_info_idsptype_get'))

# Start of task_dsp_info_DataMask_set

`task_dsp_info_DataMask_set` = function(self, s_DataMask)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_DataMask = coerceIfNotSubclass(s_DataMask, "_p_dsp_data_mask") 
  .Call('R_swig_task_dsp_info_DataMask_set', self, s_DataMask, PACKAGE='iris')
  
}

attr(`task_dsp_info_DataMask_set`, 'returnType') = 'void'
attr(`task_dsp_info_DataMask_set`, "inputTypes") = c('_p_task_dsp_info', '_p_dsp_data_mask')
class(`task_dsp_info_DataMask_set`) = c("SWIGFunction", class('task_dsp_info_DataMask_set'))

# Start of task_dsp_info_DataMask_get

`task_dsp_info_DataMask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_DataMask_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dsp_data_mask"
  
  ans
  
}

attr(`task_dsp_info_DataMask_get`, 'returnType') = '_p_dsp_data_mask'
attr(`task_dsp_info_DataMask_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_DataMask_get`) = c("SWIGFunction", class('task_dsp_info_DataMask_get'))

# Start of task_dsp_info_OriginalDataMask_set

`task_dsp_info_OriginalDataMask_set` = function(self, s_OriginalDataMask)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_OriginalDataMask = coerceIfNotSubclass(s_OriginalDataMask, "_p_dsp_data_mask") 
  .Call('R_swig_task_dsp_info_OriginalDataMask_set', self, s_OriginalDataMask, PACKAGE='iris')
  
}

attr(`task_dsp_info_OriginalDataMask_set`, 'returnType') = 'void'
attr(`task_dsp_info_OriginalDataMask_set`, "inputTypes") = c('_p_task_dsp_info', '_p_dsp_data_mask')
class(`task_dsp_info_OriginalDataMask_set`) = c("SWIGFunction", class('task_dsp_info_OriginalDataMask_set'))

# Start of task_dsp_info_OriginalDataMask_get

`task_dsp_info_OriginalDataMask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_OriginalDataMask_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_dsp_data_mask"
  
  ans
  
}

attr(`task_dsp_info_OriginalDataMask_get`, 'returnType') = '_p_dsp_data_mask'
attr(`task_dsp_info_OriginalDataMask_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_OriginalDataMask_get`) = c("SWIGFunction", class('task_dsp_info_OriginalDataMask_get'))

# Start of task_dsp_info_u_set

`task_dsp_info_u_set` = function(self, s_u)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_u = coerceIfNotSubclass(s_u, "_p_task_dsp_mode_u") 
  .Call('R_swig_task_dsp_info_u_set', self, s_u, PACKAGE='iris')
  
}

attr(`task_dsp_info_u_set`, 'returnType') = 'void'
attr(`task_dsp_info_u_set`, "inputTypes") = c('_p_task_dsp_info', '_p_task_dsp_mode_u')
class(`task_dsp_info_u_set`) = c("SWIGFunction", class('task_dsp_info_u_set'))

# Start of task_dsp_info_u_get

`task_dsp_info_u_get` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_u_get', self, PACKAGE='iris')
  class(ans) <- "_p_task_dsp_mode_u"
  
  ans
  
}

attr(`task_dsp_info_u_get`, 'returnType') = '_p_task_dsp_mode_u'
attr(`task_dsp_info_u_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_u_get`) = c("SWIGFunction", class('task_dsp_info_u_get'))

# Start of task_dsp_info_ipad_84x52_set

`task_dsp_info_ipad_84x52_set` = function(self, s_ipad_84x52)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  
  if(is.list(s_ipad_84x52))
  assert(all(sapply(s_ipad_84x52, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_84x52) >= 52)
  
  .Call('R_swig_task_dsp_info_ipad_84x52_set', self, s_ipad_84x52, PACKAGE='iris')
  
}

attr(`task_dsp_info_ipad_84x52_set`, 'returnType') = 'void'
attr(`task_dsp_info_ipad_84x52_set`, "inputTypes") = c('_p_task_dsp_info', '_p_char')
class(`task_dsp_info_ipad_84x52_set`) = c("SWIGFunction", class('task_dsp_info_ipad_84x52_set'))

# Start of task_dsp_info_ipad_84x52_get

`task_dsp_info_ipad_84x52_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_ipad_84x52_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_dsp_info_ipad_84x52_get`, 'returnType') = '_p_char'
attr(`task_dsp_info_ipad_84x52_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_ipad_84x52_get`) = c("SWIGFunction", class('task_dsp_info_ipad_84x52_get'))

# Start of task_dsp_info_iprf_set

`task_dsp_info_iprf_set` = function(self, s_iprf)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_iprf = as.integer(s_iprf) 
  
  if(length(s_iprf) > 1) {
    Rf_warning("using only the first element of s_iprf")
  }
  
  .Call('R_swig_task_dsp_info_iprf_set', self, s_iprf, PACKAGE='iris')
  
}

attr(`task_dsp_info_iprf_set`, 'returnType') = 'void'
attr(`task_dsp_info_iprf_set`, "inputTypes") = c('_p_task_dsp_info', 'numeric')
class(`task_dsp_info_iprf_set`) = c("SWIGFunction", class('task_dsp_info_iprf_set'))

# Start of task_dsp_info_iprf_get

`task_dsp_info_iprf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  .Call('R_swig_task_dsp_info_iprf_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_dsp_info_iprf_get`, 'returnType') = 'numeric'
attr(`task_dsp_info_iprf_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_iprf_get`) = c("SWIGFunction", class('task_dsp_info_iprf_get'))

# Start of task_dsp_info_ipw_set

`task_dsp_info_ipw_set` = function(self, s_ipw)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_ipw = as.integer(s_ipw) 
  
  if(length(s_ipw) > 1) {
    Rf_warning("using only the first element of s_ipw")
  }
  
  .Call('R_swig_task_dsp_info_ipw_set', self, s_ipw, PACKAGE='iris')
  
}

attr(`task_dsp_info_ipw_set`, 'returnType') = 'void'
attr(`task_dsp_info_ipw_set`, "inputTypes") = c('_p_task_dsp_info', 'numeric')
class(`task_dsp_info_ipw_set`) = c("SWIGFunction", class('task_dsp_info_ipw_set'))

# Start of task_dsp_info_ipw_get

`task_dsp_info_ipw_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  .Call('R_swig_task_dsp_info_ipw_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_dsp_info_ipw_get`, 'returnType') = 'numeric'
attr(`task_dsp_info_ipw_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_ipw_get`) = c("SWIGFunction", class('task_dsp_info_ipw_get'))

# Start of task_dsp_info_itrig_set

`task_dsp_info_itrig_set` = function(self, s_itrig)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_itrig = coerceIfNotSubclass(s_itrig, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_itrig_set', self, s_itrig, PACKAGE='iris')
  
}

attr(`task_dsp_info_itrig_set`, 'returnType') = 'void'
attr(`task_dsp_info_itrig_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_itrig_set`) = c("SWIGFunction", class('task_dsp_info_itrig_set'))

# Start of task_dsp_info_itrig_get

`task_dsp_info_itrig_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_itrig_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_itrig_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_itrig_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_itrig_get`) = c("SWIGFunction", class('task_dsp_info_itrig_get'))

# Start of task_dsp_info_idual_delay_set

`task_dsp_info_idual_delay_set` = function(self, s_idual_delay)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_idual_delay = coerceIfNotSubclass(s_idual_delay, "_p_short") 
  .Call('R_swig_task_dsp_info_idual_delay_set', self, s_idual_delay, PACKAGE='iris')
  
}

attr(`task_dsp_info_idual_delay_set`, 'returnType') = 'void'
attr(`task_dsp_info_idual_delay_set`, "inputTypes") = c('_p_task_dsp_info', '_p_short')
class(`task_dsp_info_idual_delay_set`) = c("SWIGFunction", class('task_dsp_info_idual_delay_set'))

# Start of task_dsp_info_idual_delay_get

`task_dsp_info_idual_delay_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_idual_delay_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_info_idual_delay_get`, 'returnType') = '_p_short'
attr(`task_dsp_info_idual_delay_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_idual_delay_get`) = c("SWIGFunction", class('task_dsp_info_idual_delay_get'))

# Start of task_dsp_info_iagc_code_set

`task_dsp_info_iagc_code_set` = function(self, s_iagc_code)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_iagc_code = coerceIfNotSubclass(s_iagc_code, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_iagc_code_set', self, s_iagc_code, PACKAGE='iris')
  
}

attr(`task_dsp_info_iagc_code_set`, 'returnType') = 'void'
attr(`task_dsp_info_iagc_code_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_iagc_code_set`) = c("SWIGFunction", class('task_dsp_info_iagc_code_set'))

# Start of task_dsp_info_iagc_code_get

`task_dsp_info_iagc_code_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_iagc_code_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_iagc_code_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_iagc_code_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_iagc_code_get`) = c("SWIGFunction", class('task_dsp_info_iagc_code_get'))

# Start of task_dsp_info_isamp_set

`task_dsp_info_isamp_set` = function(self, s_isamp)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_isamp = coerceIfNotSubclass(s_isamp, "_p_short") 
  .Call('R_swig_task_dsp_info_isamp_set', self, s_isamp, PACKAGE='iris')
  
}

attr(`task_dsp_info_isamp_set`, 'returnType') = 'void'
attr(`task_dsp_info_isamp_set`, "inputTypes") = c('_p_task_dsp_info', '_p_short')
class(`task_dsp_info_isamp_set`) = c("SWIGFunction", class('task_dsp_info_isamp_set'))

# Start of task_dsp_info_isamp_get

`task_dsp_info_isamp_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_isamp_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_info_isamp_get`, 'returnType') = '_p_short'
attr(`task_dsp_info_isamp_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_isamp_get`) = c("SWIGFunction", class('task_dsp_info_isamp_get'))

# Start of task_dsp_info_igain_set

`task_dsp_info_igain_set` = function(self, s_igain)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_igain = coerceIfNotSubclass(s_igain, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_igain_set', self, s_igain, PACKAGE='iris')
  
}

attr(`task_dsp_info_igain_set`, 'returnType') = 'void'
attr(`task_dsp_info_igain_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_igain_set`) = c("SWIGFunction", class('task_dsp_info_igain_set'))

# Start of task_dsp_info_igain_get

`task_dsp_info_igain_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_igain_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_igain_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_igain_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_igain_get`) = c("SWIGFunction", class('task_dsp_info_igain_get'))

# Start of task_dsp_info_sfilter_set

`task_dsp_info_sfilter_set` = function(self, s_sfilter)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  
  if(is.list(s_sfilter))
  assert(all(sapply(s_sfilter, class) == "_p_char"))     
  
  
#  assert(length(s_sfilter) >= 12)
  
  .Call('R_swig_task_dsp_info_sfilter_set', self, s_sfilter, PACKAGE='iris')
  
}

attr(`task_dsp_info_sfilter_set`, 'returnType') = 'void'
attr(`task_dsp_info_sfilter_set`, "inputTypes") = c('_p_task_dsp_info', '_p_char')
class(`task_dsp_info_sfilter_set`) = c("SWIGFunction", class('task_dsp_info_sfilter_set'))

# Start of task_dsp_info_sfilter_get

`task_dsp_info_sfilter_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_sfilter_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_dsp_info_sfilter_get`, 'returnType') = '_p_char'
attr(`task_dsp_info_sfilter_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_sfilter_get`) = c("SWIGFunction", class('task_dsp_info_sfilter_get'))

# Start of task_dsp_info_idop_filter_first_set

`task_dsp_info_idop_filter_first_set` = function(self, s_idop_filter_first)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_idop_filter_first = coerceIfNotSubclass(s_idop_filter_first, "_p_unsigned_char") 
  .Call('R_swig_task_dsp_info_idop_filter_first_set', self, s_idop_filter_first, PACKAGE='iris')
  
}

attr(`task_dsp_info_idop_filter_first_set`, 'returnType') = 'void'
attr(`task_dsp_info_idop_filter_first_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_char')
class(`task_dsp_info_idop_filter_first_set`) = c("SWIGFunction", class('task_dsp_info_idop_filter_first_set'))

# Start of task_dsp_info_idop_filter_first_get

`task_dsp_info_idop_filter_first_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_idop_filter_first_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`task_dsp_info_idop_filter_first_get`, 'returnType') = '_p_unsigned_char'
attr(`task_dsp_info_idop_filter_first_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_idop_filter_first_get`) = c("SWIGFunction", class('task_dsp_info_idop_filter_first_get'))

# Start of task_dsp_info_ilog_filter_first_set

`task_dsp_info_ilog_filter_first_set` = function(self, s_ilog_filter_first)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_ilog_filter_first = coerceIfNotSubclass(s_ilog_filter_first, "_p_unsigned_char") 
  .Call('R_swig_task_dsp_info_ilog_filter_first_set', self, s_ilog_filter_first, PACKAGE='iris')
  
}

attr(`task_dsp_info_ilog_filter_first_set`, 'returnType') = 'void'
attr(`task_dsp_info_ilog_filter_first_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_char')
class(`task_dsp_info_ilog_filter_first_set`) = c("SWIGFunction", class('task_dsp_info_ilog_filter_first_set'))

# Start of task_dsp_info_ilog_filter_first_get

`task_dsp_info_ilog_filter_first_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_ilog_filter_first_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`task_dsp_info_ilog_filter_first_get`, 'returnType') = '_p_unsigned_char'
attr(`task_dsp_info_ilog_filter_first_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_ilog_filter_first_get`) = c("SWIGFunction", class('task_dsp_info_ilog_filter_first_get'))

# Start of task_dsp_info_ifixed_gain_set

`task_dsp_info_ifixed_gain_set` = function(self, s_ifixed_gain)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_ifixed_gain = coerceIfNotSubclass(s_ifixed_gain, "_p_short") 
  .Call('R_swig_task_dsp_info_ifixed_gain_set', self, s_ifixed_gain, PACKAGE='iris')
  
}

attr(`task_dsp_info_ifixed_gain_set`, 'returnType') = 'void'
attr(`task_dsp_info_ifixed_gain_set`, "inputTypes") = c('_p_task_dsp_info', '_p_short')
class(`task_dsp_info_ifixed_gain_set`) = c("SWIGFunction", class('task_dsp_info_ifixed_gain_set'))

# Start of task_dsp_info_ifixed_gain_get

`task_dsp_info_ifixed_gain_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_ifixed_gain_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_dsp_info_ifixed_gain_get`, 'returnType') = '_p_short'
attr(`task_dsp_info_ifixed_gain_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_ifixed_gain_get`) = c("SWIGFunction", class('task_dsp_info_ifixed_gain_get'))

# Start of task_dsp_info_igas_atten_set

`task_dsp_info_igas_atten_set` = function(self, s_igas_atten)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_igas_atten = coerceIfNotSubclass(s_igas_atten, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_igas_atten_set', self, s_igas_atten, PACKAGE='iris')
  
}

attr(`task_dsp_info_igas_atten_set`, 'returnType') = 'void'
attr(`task_dsp_info_igas_atten_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_igas_atten_set`) = c("SWIGFunction", class('task_dsp_info_igas_atten_set'))

# Start of task_dsp_info_igas_atten_get

`task_dsp_info_igas_atten_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_igas_atten_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_igas_atten_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_igas_atten_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_igas_atten_get`) = c("SWIGFunction", class('task_dsp_info_igas_atten_get'))

# Start of task_dsp_info_lclutmap_used_set

`task_dsp_info_lclutmap_used_set` = function(self, s_lclutmap_used)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_lclutmap_used = coerceIfNotSubclass(s_lclutmap_used, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_lclutmap_used_set', self, s_lclutmap_used, PACKAGE='iris')
  
}

attr(`task_dsp_info_lclutmap_used_set`, 'returnType') = 'void'
attr(`task_dsp_info_lclutmap_used_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_lclutmap_used_set`) = c("SWIGFunction", class('task_dsp_info_lclutmap_used_set'))

# Start of task_dsp_info_lclutmap_used_get

`task_dsp_info_lclutmap_used_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_lclutmap_used_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_lclutmap_used_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_lclutmap_used_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_lclutmap_used_get`) = c("SWIGFunction", class('task_dsp_info_lclutmap_used_get'))

# Start of task_dsp_info_iXmtPhaseSequence_set

`task_dsp_info_iXmtPhaseSequence_set` = function(self, s_iXmtPhaseSequence)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_iXmtPhaseSequence = coerceIfNotSubclass(s_iXmtPhaseSequence, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_iXmtPhaseSequence_set', self, s_iXmtPhaseSequence, PACKAGE='iris')
  
}

attr(`task_dsp_info_iXmtPhaseSequence_set`, 'returnType') = 'void'
attr(`task_dsp_info_iXmtPhaseSequence_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_iXmtPhaseSequence_set`) = c("SWIGFunction", class('task_dsp_info_iXmtPhaseSequence_set'))

# Start of task_dsp_info_iXmtPhaseSequence_get

`task_dsp_info_iXmtPhaseSequence_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_iXmtPhaseSequence_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_iXmtPhaseSequence_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_iXmtPhaseSequence_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_iXmtPhaseSequence_get`) = c("SWIGFunction", class('task_dsp_info_iXmtPhaseSequence_get'))

# Start of task_dsp_info_iCfgHdrMask_set

`task_dsp_info_iCfgHdrMask_set` = function(self, s_iCfgHdrMask)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_iCfgHdrMask = as.numeric(s_iCfgHdrMask) 
  
  assert(length(s_iCfgHdrMask) == 1 && s_iCfgHdrMask >= 0, "All values must be non-negative")
  
  .Call('R_swig_task_dsp_info_iCfgHdrMask_set', self, s_iCfgHdrMask, PACKAGE='iris')
  
}

attr(`task_dsp_info_iCfgHdrMask_set`, 'returnType') = 'void'
attr(`task_dsp_info_iCfgHdrMask_set`, "inputTypes") = c('_p_task_dsp_info', 'numeric')
class(`task_dsp_info_iCfgHdrMask_set`) = c("SWIGFunction", class('task_dsp_info_iCfgHdrMask_set'))

# Start of task_dsp_info_iCfgHdrMask_get

`task_dsp_info_iCfgHdrMask_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  .Call('R_swig_task_dsp_info_iCfgHdrMask_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`task_dsp_info_iCfgHdrMask_get`, 'returnType') = 'numeric'
attr(`task_dsp_info_iCfgHdrMask_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_iCfgHdrMask_get`) = c("SWIGFunction", class('task_dsp_info_iCfgHdrMask_get'))

# Start of task_dsp_info_iFlagsTS_set

`task_dsp_info_iFlagsTS_set` = function(self, s_iFlagsTS)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  s_iFlagsTS = coerceIfNotSubclass(s_iFlagsTS, "_p_unsigned_short") 
  .Call('R_swig_task_dsp_info_iFlagsTS_set', self, s_iFlagsTS, PACKAGE='iris')
  
}

attr(`task_dsp_info_iFlagsTS_set`, 'returnType') = 'void'
attr(`task_dsp_info_iFlagsTS_set`, "inputTypes") = c('_p_task_dsp_info', '_p_unsigned_short')
class(`task_dsp_info_iFlagsTS_set`) = c("SWIGFunction", class('task_dsp_info_iFlagsTS_set'))

# Start of task_dsp_info_iFlagsTS_get

`task_dsp_info_iFlagsTS_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_iFlagsTS_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_dsp_info_iFlagsTS_get`, 'returnType') = '_p_unsigned_short'
attr(`task_dsp_info_iFlagsTS_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_iFlagsTS_get`) = c("SWIGFunction", class('task_dsp_info_iFlagsTS_get'))

# Start of task_dsp_info_ipad_182x2_set

`task_dsp_info_ipad_182x2_set` = function(self, s_ipad_182x2)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  
  if(is.list(s_ipad_182x2))
  assert(all(sapply(s_ipad_182x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_182x2) >= 2)
  
  .Call('R_swig_task_dsp_info_ipad_182x2_set', self, s_ipad_182x2, PACKAGE='iris')
  
}

attr(`task_dsp_info_ipad_182x2_set`, 'returnType') = 'void'
attr(`task_dsp_info_ipad_182x2_set`, "inputTypes") = c('_p_task_dsp_info', '_p_char')
class(`task_dsp_info_ipad_182x2_set`) = c("SWIGFunction", class('task_dsp_info_ipad_182x2_set'))

# Start of task_dsp_info_ipad_182x2_get

`task_dsp_info_ipad_182x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_ipad_182x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_dsp_info_ipad_182x2_get`, 'returnType') = '_p_char'
attr(`task_dsp_info_ipad_182x2_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_ipad_182x2_get`) = c("SWIGFunction", class('task_dsp_info_ipad_182x2_get'))

# Start of task_dsp_info_sCustomRayHeader_set

`task_dsp_info_sCustomRayHeader_set` = function(self, s_sCustomRayHeader)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  
  if(is.list(s_sCustomRayHeader))
  assert(all(sapply(s_sCustomRayHeader, class) == "_p_char"))     
  
  
#  assert(length(s_sCustomRayHeader) >= 16)
  
  .Call('R_swig_task_dsp_info_sCustomRayHeader_set', self, s_sCustomRayHeader, PACKAGE='iris')
  
}

attr(`task_dsp_info_sCustomRayHeader_set`, 'returnType') = 'void'
attr(`task_dsp_info_sCustomRayHeader_set`, "inputTypes") = c('_p_task_dsp_info', '_p_char')
class(`task_dsp_info_sCustomRayHeader_set`) = c("SWIGFunction", class('task_dsp_info_sCustomRayHeader_set'))

# Start of task_dsp_info_sCustomRayHeader_get

`task_dsp_info_sCustomRayHeader_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_sCustomRayHeader_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_dsp_info_sCustomRayHeader_get`, 'returnType') = '_p_char'
attr(`task_dsp_info_sCustomRayHeader_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_sCustomRayHeader_get`) = c("SWIGFunction", class('task_dsp_info_sCustomRayHeader_get'))

# Start of task_dsp_info_ipad_end_set

`task_dsp_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (120))
  
  .Call('R_swig_task_dsp_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_dsp_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_dsp_info_ipad_end_set`, "inputTypes") = c('_p_task_dsp_info', '_p_char')
class(`task_dsp_info_ipad_end_set`) = c("SWIGFunction", class('task_dsp_info_ipad_end_set'))

# Start of task_dsp_info_ipad_end_get

`task_dsp_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  ans = .Call('R_swig_task_dsp_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_dsp_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_dsp_info_ipad_end_get`, "inputTypes") = c('_p_task_dsp_info')
class(`task_dsp_info_ipad_end_get`) = c("SWIGFunction", class('task_dsp_info_ipad_end_get'))

# Start of new_task_dsp_info

`task_dsp_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_dsp_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_dsp_info"
  
  ans
  
}

attr(`task_dsp_info`, 'returnType') = '_p_task_dsp_info'
class(`task_dsp_info`) = c("SWIGFunction", class('task_dsp_info'))

# Start of delete_task_dsp_info

`delete_task_dsp_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_dsp_info") 
  .Call('R_swig_delete_task_dsp_info', self, PACKAGE='iris')
  
}

attr(`delete_task_dsp_info`, 'returnType') = 'void'
attr(`delete_task_dsp_info`, "inputTypes") = c('_p_task_dsp_info')
class(`delete_task_dsp_info`) = c("SWIGFunction", class('delete_task_dsp_info'))

# Start of accessor method for task_dsp_info
setMethod('$', '_p_task_dsp_info', function(x, name)

{
  accessorFuns = list('imajor_mode' = task_dsp_info_imajor_mode_get, 'idsptype' = task_dsp_info_idsptype_get, 'DataMask' = task_dsp_info_DataMask_get, 'OriginalDataMask' = task_dsp_info_OriginalDataMask_get, 'u' = task_dsp_info_u_get, 'ipad_84x52' = task_dsp_info_ipad_84x52_get, 'iprf' = task_dsp_info_iprf_get, 'ipw' = task_dsp_info_ipw_get, 'itrig' = task_dsp_info_itrig_get, 'idual_delay' = task_dsp_info_idual_delay_get, 'iagc_code' = task_dsp_info_iagc_code_get, 'isamp' = task_dsp_info_isamp_get, 'igain' = task_dsp_info_igain_get, 'sfilter' = task_dsp_info_sfilter_get, 'idop_filter_first' = task_dsp_info_idop_filter_first_get, 'ilog_filter_first' = task_dsp_info_ilog_filter_first_get, 'ifixed_gain' = task_dsp_info_ifixed_gain_get, 'igas_atten' = task_dsp_info_igas_atten_get, 'lclutmap_used' = task_dsp_info_lclutmap_used_get, 'iXmtPhaseSequence' = task_dsp_info_iXmtPhaseSequence_get, 'iCfgHdrMask' = task_dsp_info_iCfgHdrMask_get, 'iFlagsTS' = task_dsp_info_iFlagsTS_get, 'ipad_182x2' = task_dsp_info_ipad_182x2_get, 'sCustomRayHeader' = task_dsp_info_sCustomRayHeader_get, 'ipad_end' = task_dsp_info_ipad_end_get)
  vaccessors = c('imajor_mode', 'idsptype', 'DataMask', 'OriginalDataMask', 'u', 'ipad_84x52', 'iprf', 'ipw', 'itrig', 'idual_delay', 'iagc_code', 'isamp', 'igain', 'sfilter', 'idop_filter_first', 'ilog_filter_first', 'ifixed_gain', 'igas_atten', 'lclutmap_used', 'iXmtPhaseSequence', 'iCfgHdrMask', 'iFlagsTS', 'ipad_182x2', 'sCustomRayHeader', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_dsp_info
# Start of accessor method for task_dsp_info
setMethod('$<-', '_p_task_dsp_info', function(x, name, value)

{
  accessorFuns = list('imajor_mode' = task_dsp_info_imajor_mode_set, 'idsptype' = task_dsp_info_idsptype_set, 'DataMask' = task_dsp_info_DataMask_set, 'OriginalDataMask' = task_dsp_info_OriginalDataMask_set, 'u' = task_dsp_info_u_set, 'ipad_84x52' = task_dsp_info_ipad_84x52_set, 'iprf' = task_dsp_info_iprf_set, 'ipw' = task_dsp_info_ipw_set, 'itrig' = task_dsp_info_itrig_set, 'idual_delay' = task_dsp_info_idual_delay_set, 'iagc_code' = task_dsp_info_iagc_code_set, 'isamp' = task_dsp_info_isamp_set, 'igain' = task_dsp_info_igain_set, 'sfilter' = task_dsp_info_sfilter_set, 'idop_filter_first' = task_dsp_info_idop_filter_first_set, 'ilog_filter_first' = task_dsp_info_ilog_filter_first_set, 'ifixed_gain' = task_dsp_info_ifixed_gain_set, 'igas_atten' = task_dsp_info_igas_atten_set, 'lclutmap_used' = task_dsp_info_lclutmap_used_set, 'iXmtPhaseSequence' = task_dsp_info_iXmtPhaseSequence_set, 'iCfgHdrMask' = task_dsp_info_iCfgHdrMask_set, 'iFlagsTS' = task_dsp_info_iFlagsTS_set, 'ipad_182x2' = task_dsp_info_ipad_182x2_set, 'sCustomRayHeader' = task_dsp_info_sCustomRayHeader_set, 'ipad_end' = task_dsp_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_dsp_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('imajor_mode' = task_dsp_info_imajor_mode_set, 'idsptype' = task_dsp_info_idsptype_set, 'DataMask' = task_dsp_info_DataMask_set, 'OriginalDataMask' = task_dsp_info_OriginalDataMask_set, 'u' = task_dsp_info_u_set, 'ipad_84x52' = task_dsp_info_ipad_84x52_set, 'iprf' = task_dsp_info_iprf_set, 'ipw' = task_dsp_info_ipw_set, 'itrig' = task_dsp_info_itrig_set, 'idual_delay' = task_dsp_info_idual_delay_set, 'iagc_code' = task_dsp_info_iagc_code_set, 'isamp' = task_dsp_info_isamp_set, 'igain' = task_dsp_info_igain_set, 'sfilter' = task_dsp_info_sfilter_set, 'idop_filter_first' = task_dsp_info_idop_filter_first_set, 'ilog_filter_first' = task_dsp_info_ilog_filter_first_set, 'ifixed_gain' = task_dsp_info_ifixed_gain_set, 'igas_atten' = task_dsp_info_igas_atten_set, 'lclutmap_used' = task_dsp_info_lclutmap_used_set, 'iXmtPhaseSequence' = task_dsp_info_iXmtPhaseSequence_set, 'iCfgHdrMask' = task_dsp_info_iCfgHdrMask_set, 'iFlagsTS' = task_dsp_info_iFlagsTS_set, 'ipad_182x2' = task_dsp_info_ipad_182x2_set, 'sCustomRayHeader' = task_dsp_info_sCustomRayHeader_set, 'ipad_end' = task_dsp_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_dsp_info
setMethod('delete', '_p_task_dsp_info', function(obj) {delete_task_dsp_info(obj)})
# Start definition of copy functions & methods for task_dsp_info
CopyToR_task_dsp_info = function(value, obj = new("task_dsp_info"))
{
  obj@ipad_84x52 = value$ipad_84x52
  obj@iprf = value$iprf
  obj@ipw = value$ipw
  obj@sfilter = value$sfilter
  obj@iCfgHdrMask = value$iCfgHdrMask
  obj@ipad_182x2 = value$ipad_182x2
  obj@sCustomRayHeader = value$sCustomRayHeader
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_dsp_info = function(value, obj)
{
  obj$ipad_84x52 = value@ipad_84x52
  obj$iprf = value@iprf
  obj$ipw = value@ipw
  obj$sfilter = value@sfilter
  obj$iCfgHdrMask = value@iCfgHdrMask
  obj$ipad_182x2 = value@ipad_182x2
  obj$sCustomRayHeader = value@sCustomRayHeader
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_dsp_info
setMethod('copyToR', '_p_task_dsp_info', CopyToR_task_dsp_info)
setMethod('copyToC', 'task_dsp_info', CopyToC_task_dsp_info)

# End definition of copy methods for task_dsp_info
# End definition of copy functions & methods for task_dsp_info
# Start of task_calib_info_iz_slope_set

`task_calib_info_iz_slope_set` = function(self, s_iz_slope)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iz_slope = coerceIfNotSubclass(s_iz_slope, "_p_short") 
  .Call('R_swig_task_calib_info_iz_slope_set', self, s_iz_slope, PACKAGE='iris')
  
}

attr(`task_calib_info_iz_slope_set`, 'returnType') = 'void'
attr(`task_calib_info_iz_slope_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iz_slope_set`) = c("SWIGFunction", class('task_calib_info_iz_slope_set'))

# Start of task_calib_info_iz_slope_get

`task_calib_info_iz_slope_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iz_slope_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iz_slope_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iz_slope_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iz_slope_get`) = c("SWIGFunction", class('task_calib_info_iz_slope_get'))

# Start of task_calib_info_izns_thr_set

`task_calib_info_izns_thr_set` = function(self, s_izns_thr)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_izns_thr = coerceIfNotSubclass(s_izns_thr, "_p_short") 
  .Call('R_swig_task_calib_info_izns_thr_set', self, s_izns_thr, PACKAGE='iris')
  
}

attr(`task_calib_info_izns_thr_set`, 'returnType') = 'void'
attr(`task_calib_info_izns_thr_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_izns_thr_set`) = c("SWIGFunction", class('task_calib_info_izns_thr_set'))

# Start of task_calib_info_izns_thr_get

`task_calib_info_izns_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_izns_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_izns_thr_get`, 'returnType') = '_p_short'
attr(`task_calib_info_izns_thr_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_izns_thr_get`) = c("SWIGFunction", class('task_calib_info_izns_thr_get'))

# Start of task_calib_info_iccr_thr_set

`task_calib_info_iccr_thr_set` = function(self, s_iccr_thr)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iccr_thr = coerceIfNotSubclass(s_iccr_thr, "_p_short") 
  .Call('R_swig_task_calib_info_iccr_thr_set', self, s_iccr_thr, PACKAGE='iris')
  
}

attr(`task_calib_info_iccr_thr_set`, 'returnType') = 'void'
attr(`task_calib_info_iccr_thr_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iccr_thr_set`) = c("SWIGFunction", class('task_calib_info_iccr_thr_set'))

# Start of task_calib_info_iccr_thr_get

`task_calib_info_iccr_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iccr_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iccr_thr_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iccr_thr_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iccr_thr_get`) = c("SWIGFunction", class('task_calib_info_iccr_thr_get'))

# Start of task_calib_info_isqi_thr_set

`task_calib_info_isqi_thr_set` = function(self, s_isqi_thr)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_isqi_thr = coerceIfNotSubclass(s_isqi_thr, "_p_short") 
  .Call('R_swig_task_calib_info_isqi_thr_set', self, s_isqi_thr, PACKAGE='iris')
  
}

attr(`task_calib_info_isqi_thr_set`, 'returnType') = 'void'
attr(`task_calib_info_isqi_thr_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_isqi_thr_set`) = c("SWIGFunction", class('task_calib_info_isqi_thr_set'))

# Start of task_calib_info_isqi_thr_get

`task_calib_info_isqi_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_isqi_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_isqi_thr_get`, 'returnType') = '_p_short'
attr(`task_calib_info_isqi_thr_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_isqi_thr_get`) = c("SWIGFunction", class('task_calib_info_isqi_thr_get'))

# Start of task_calib_info_isig_thr_set

`task_calib_info_isig_thr_set` = function(self, s_isig_thr)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_isig_thr = coerceIfNotSubclass(s_isig_thr, "_p_short") 
  .Call('R_swig_task_calib_info_isig_thr_set', self, s_isig_thr, PACKAGE='iris')
  
}

attr(`task_calib_info_isig_thr_set`, 'returnType') = 'void'
attr(`task_calib_info_isig_thr_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_isig_thr_set`) = c("SWIGFunction", class('task_calib_info_isig_thr_set'))

# Start of task_calib_info_isig_thr_get

`task_calib_info_isig_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_isig_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_isig_thr_get`, 'returnType') = '_p_short'
attr(`task_calib_info_isig_thr_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_isig_thr_get`) = c("SWIGFunction", class('task_calib_info_isig_thr_get'))

# Start of task_calib_info_ipad10x8_set

`task_calib_info_ipad10x8_set` = function(self, s_ipad10x8)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  
  if(is.list(s_ipad10x8))
  assert(all(sapply(s_ipad10x8, class) == "_p_char"))     
  
  
#  assert(length(s_ipad10x8) >= 8)
  
  .Call('R_swig_task_calib_info_ipad10x8_set', self, s_ipad10x8, PACKAGE='iris')
  
}

attr(`task_calib_info_ipad10x8_set`, 'returnType') = 'void'
attr(`task_calib_info_ipad10x8_set`, "inputTypes") = c('_p_task_calib_info', '_p_char')
class(`task_calib_info_ipad10x8_set`) = c("SWIGFunction", class('task_calib_info_ipad10x8_set'))

# Start of task_calib_info_ipad10x8_get

`task_calib_info_ipad10x8_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_ipad10x8_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_calib_info_ipad10x8_get`, 'returnType') = '_p_char'
attr(`task_calib_info_ipad10x8_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_ipad10x8_get`) = c("SWIGFunction", class('task_calib_info_ipad10x8_get'))

# Start of task_calib_info_iz_calib_set

`task_calib_info_iz_calib_set` = function(self, s_iz_calib)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iz_calib = coerceIfNotSubclass(s_iz_calib, "_p_short") 
  .Call('R_swig_task_calib_info_iz_calib_set', self, s_iz_calib, PACKAGE='iris')
  
}

attr(`task_calib_info_iz_calib_set`, 'returnType') = 'void'
attr(`task_calib_info_iz_calib_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iz_calib_set`) = c("SWIGFunction", class('task_calib_info_iz_calib_set'))

# Start of task_calib_info_iz_calib_get

`task_calib_info_iz_calib_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iz_calib_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iz_calib_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iz_calib_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iz_calib_get`) = c("SWIGFunction", class('task_calib_info_iz_calib_get'))

# Start of task_calib_info_iuz_tcf_set

`task_calib_info_iuz_tcf_set` = function(self, s_iuz_tcf)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iuz_tcf = coerceIfNotSubclass(s_iuz_tcf, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_iuz_tcf_set', self, s_iuz_tcf, PACKAGE='iris')
  
}

attr(`task_calib_info_iuz_tcf_set`, 'returnType') = 'void'
attr(`task_calib_info_iuz_tcf_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_iuz_tcf_set`) = c("SWIGFunction", class('task_calib_info_iuz_tcf_set'))

# Start of task_calib_info_iuz_tcf_get

`task_calib_info_iuz_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iuz_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_iuz_tcf_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_iuz_tcf_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iuz_tcf_get`) = c("SWIGFunction", class('task_calib_info_iuz_tcf_get'))

# Start of task_calib_info_icz_tcf_set

`task_calib_info_icz_tcf_set` = function(self, s_icz_tcf)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_icz_tcf = coerceIfNotSubclass(s_icz_tcf, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_icz_tcf_set', self, s_icz_tcf, PACKAGE='iris')
  
}

attr(`task_calib_info_icz_tcf_set`, 'returnType') = 'void'
attr(`task_calib_info_icz_tcf_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_icz_tcf_set`) = c("SWIGFunction", class('task_calib_info_icz_tcf_set'))

# Start of task_calib_info_icz_tcf_get

`task_calib_info_icz_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_icz_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_icz_tcf_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_icz_tcf_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_icz_tcf_get`) = c("SWIGFunction", class('task_calib_info_icz_tcf_get'))

# Start of task_calib_info_ivl_tcf_set

`task_calib_info_ivl_tcf_set` = function(self, s_ivl_tcf)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_ivl_tcf = coerceIfNotSubclass(s_ivl_tcf, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_ivl_tcf_set', self, s_ivl_tcf, PACKAGE='iris')
  
}

attr(`task_calib_info_ivl_tcf_set`, 'returnType') = 'void'
attr(`task_calib_info_ivl_tcf_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_ivl_tcf_set`) = c("SWIGFunction", class('task_calib_info_ivl_tcf_set'))

# Start of task_calib_info_ivl_tcf_get

`task_calib_info_ivl_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_ivl_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_ivl_tcf_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_ivl_tcf_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_ivl_tcf_get`) = c("SWIGFunction", class('task_calib_info_ivl_tcf_get'))

# Start of task_calib_info_iwd_tcf_set

`task_calib_info_iwd_tcf_set` = function(self, s_iwd_tcf)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iwd_tcf = coerceIfNotSubclass(s_iwd_tcf, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_iwd_tcf_set', self, s_iwd_tcf, PACKAGE='iris')
  
}

attr(`task_calib_info_iwd_tcf_set`, 'returnType') = 'void'
attr(`task_calib_info_iwd_tcf_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_iwd_tcf_set`) = c("SWIGFunction", class('task_calib_info_iwd_tcf_set'))

# Start of task_calib_info_iwd_tcf_get

`task_calib_info_iwd_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iwd_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_iwd_tcf_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_iwd_tcf_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iwd_tcf_get`) = c("SWIGFunction", class('task_calib_info_iwd_tcf_get'))

# Start of task_calib_info_izdr_tcf_set

`task_calib_info_izdr_tcf_set` = function(self, s_izdr_tcf)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_izdr_tcf = coerceIfNotSubclass(s_izdr_tcf, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_izdr_tcf_set', self, s_izdr_tcf, PACKAGE='iris')
  
}

attr(`task_calib_info_izdr_tcf_set`, 'returnType') = 'void'
attr(`task_calib_info_izdr_tcf_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_izdr_tcf_set`) = c("SWIGFunction", class('task_calib_info_izdr_tcf_set'))

# Start of task_calib_info_izdr_tcf_get

`task_calib_info_izdr_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_izdr_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_izdr_tcf_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_izdr_tcf_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_izdr_tcf_get`) = c("SWIGFunction", class('task_calib_info_izdr_tcf_get'))

# Start of task_calib_info_ipad30x6_set

`task_calib_info_ipad30x6_set` = function(self, s_ipad30x6)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  
  if(is.list(s_ipad30x6))
  assert(all(sapply(s_ipad30x6, class) == "_p_char"))     
  
  
#  assert(length(s_ipad30x6) >= 6)
  
  .Call('R_swig_task_calib_info_ipad30x6_set', self, s_ipad30x6, PACKAGE='iris')
  
}

attr(`task_calib_info_ipad30x6_set`, 'returnType') = 'void'
attr(`task_calib_info_ipad30x6_set`, "inputTypes") = c('_p_task_calib_info', '_p_char')
class(`task_calib_info_ipad30x6_set`) = c("SWIGFunction", class('task_calib_info_ipad30x6_set'))

# Start of task_calib_info_ipad30x6_get

`task_calib_info_ipad30x6_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_ipad30x6_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_calib_info_ipad30x6_get`, 'returnType') = '_p_char'
attr(`task_calib_info_ipad30x6_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_ipad30x6_get`) = c("SWIGFunction", class('task_calib_info_ipad30x6_get'))

# Start of task_calib_info_iflags_set

`task_calib_info_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`task_calib_info_iflags_set`, 'returnType') = 'void'
attr(`task_calib_info_iflags_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_iflags_set`) = c("SWIGFunction", class('task_calib_info_iflags_set'))

# Start of task_calib_info_iflags_get

`task_calib_info_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_iflags_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_iflags_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iflags_get`) = c("SWIGFunction", class('task_calib_info_iflags_get'))

# Start of task_calib_info_ipad38x2_set

`task_calib_info_ipad38x2_set` = function(self, s_ipad38x2)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  
  if(is.list(s_ipad38x2))
  assert(all(sapply(s_ipad38x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad38x2) >= 2)
  
  .Call('R_swig_task_calib_info_ipad38x2_set', self, s_ipad38x2, PACKAGE='iris')
  
}

attr(`task_calib_info_ipad38x2_set`, 'returnType') = 'void'
attr(`task_calib_info_ipad38x2_set`, "inputTypes") = c('_p_task_calib_info', '_p_char')
class(`task_calib_info_ipad38x2_set`) = c("SWIGFunction", class('task_calib_info_ipad38x2_set'))

# Start of task_calib_info_ipad38x2_get

`task_calib_info_ipad38x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_ipad38x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_calib_info_ipad38x2_get`, 'returnType') = '_p_char'
attr(`task_calib_info_ipad38x2_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_ipad38x2_get`) = c("SWIGFunction", class('task_calib_info_ipad38x2_get'))

# Start of task_calib_info_ildr_bias_set

`task_calib_info_ildr_bias_set` = function(self, s_ildr_bias)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_ildr_bias = coerceIfNotSubclass(s_ildr_bias, "_p_short") 
  .Call('R_swig_task_calib_info_ildr_bias_set', self, s_ildr_bias, PACKAGE='iris')
  
}

attr(`task_calib_info_ildr_bias_set`, 'returnType') = 'void'
attr(`task_calib_info_ildr_bias_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_ildr_bias_set`) = c("SWIGFunction", class('task_calib_info_ildr_bias_set'))

# Start of task_calib_info_ildr_bias_get

`task_calib_info_ildr_bias_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_ildr_bias_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_ildr_bias_get`, 'returnType') = '_p_short'
attr(`task_calib_info_ildr_bias_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_ildr_bias_get`) = c("SWIGFunction", class('task_calib_info_ildr_bias_get'))

# Start of task_calib_info_izdr_bias_set

`task_calib_info_izdr_bias_set` = function(self, s_izdr_bias)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_izdr_bias = coerceIfNotSubclass(s_izdr_bias, "_p_short") 
  .Call('R_swig_task_calib_info_izdr_bias_set', self, s_izdr_bias, PACKAGE='iris')
  
}

attr(`task_calib_info_izdr_bias_set`, 'returnType') = 'void'
attr(`task_calib_info_izdr_bias_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_izdr_bias_set`) = c("SWIGFunction", class('task_calib_info_izdr_bias_set'))

# Start of task_calib_info_izdr_bias_get

`task_calib_info_izdr_bias_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_izdr_bias_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_izdr_bias_get`, 'returnType') = '_p_short'
attr(`task_calib_info_izdr_bias_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_izdr_bias_get`) = c("SWIGFunction", class('task_calib_info_izdr_bias_get'))

# Start of task_calib_info_iPointClutterThreshold_set

`task_calib_info_iPointClutterThreshold_set` = function(self, s_iPointClutterThreshold)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iPointClutterThreshold = coerceIfNotSubclass(s_iPointClutterThreshold, "_p_short") 
  .Call('R_swig_task_calib_info_iPointClutterThreshold_set', self, s_iPointClutterThreshold, PACKAGE='iris')
  
}

attr(`task_calib_info_iPointClutterThreshold_set`, 'returnType') = 'void'
attr(`task_calib_info_iPointClutterThreshold_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iPointClutterThreshold_set`) = c("SWIGFunction", class('task_calib_info_iPointClutterThreshold_set'))

# Start of task_calib_info_iPointClutterThreshold_get

`task_calib_info_iPointClutterThreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iPointClutterThreshold_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iPointClutterThreshold_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iPointClutterThreshold_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iPointClutterThreshold_get`) = c("SWIGFunction", class('task_calib_info_iPointClutterThreshold_get'))

# Start of task_calib_info_iPointClutterSkip_set

`task_calib_info_iPointClutterSkip_set` = function(self, s_iPointClutterSkip)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iPointClutterSkip = coerceIfNotSubclass(s_iPointClutterSkip, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_iPointClutterSkip_set', self, s_iPointClutterSkip, PACKAGE='iris')
  
}

attr(`task_calib_info_iPointClutterSkip_set`, 'returnType') = 'void'
attr(`task_calib_info_iPointClutterSkip_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_iPointClutterSkip_set`) = c("SWIGFunction", class('task_calib_info_iPointClutterSkip_set'))

# Start of task_calib_info_iPointClutterSkip_get

`task_calib_info_iPointClutterSkip_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iPointClutterSkip_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_iPointClutterSkip_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_iPointClutterSkip_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iPointClutterSkip_get`) = c("SWIGFunction", class('task_calib_info_iPointClutterSkip_get'))

# Start of task_calib_info_iI0Horiz_set

`task_calib_info_iI0Horiz_set` = function(self, s_iI0Horiz)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iI0Horiz = coerceIfNotSubclass(s_iI0Horiz, "_p_short") 
  .Call('R_swig_task_calib_info_iI0Horiz_set', self, s_iI0Horiz, PACKAGE='iris')
  
}

attr(`task_calib_info_iI0Horiz_set`, 'returnType') = 'void'
attr(`task_calib_info_iI0Horiz_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iI0Horiz_set`) = c("SWIGFunction", class('task_calib_info_iI0Horiz_set'))

# Start of task_calib_info_iI0Horiz_get

`task_calib_info_iI0Horiz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iI0Horiz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iI0Horiz_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iI0Horiz_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iI0Horiz_get`) = c("SWIGFunction", class('task_calib_info_iI0Horiz_get'))

# Start of task_calib_info_iI0Vert_set

`task_calib_info_iI0Vert_set` = function(self, s_iI0Vert)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iI0Vert = coerceIfNotSubclass(s_iI0Vert, "_p_short") 
  .Call('R_swig_task_calib_info_iI0Vert_set', self, s_iI0Vert, PACKAGE='iris')
  
}

attr(`task_calib_info_iI0Vert_set`, 'returnType') = 'void'
attr(`task_calib_info_iI0Vert_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iI0Vert_set`) = c("SWIGFunction", class('task_calib_info_iI0Vert_set'))

# Start of task_calib_info_iI0Vert_get

`task_calib_info_iI0Vert_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iI0Vert_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iI0Vert_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iI0Vert_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iI0Vert_get`) = c("SWIGFunction", class('task_calib_info_iI0Vert_get'))

# Start of task_calib_info_iCalNoiseHoriz_set

`task_calib_info_iCalNoiseHoriz_set` = function(self, s_iCalNoiseHoriz)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iCalNoiseHoriz = coerceIfNotSubclass(s_iCalNoiseHoriz, "_p_short") 
  .Call('R_swig_task_calib_info_iCalNoiseHoriz_set', self, s_iCalNoiseHoriz, PACKAGE='iris')
  
}

attr(`task_calib_info_iCalNoiseHoriz_set`, 'returnType') = 'void'
attr(`task_calib_info_iCalNoiseHoriz_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iCalNoiseHoriz_set`) = c("SWIGFunction", class('task_calib_info_iCalNoiseHoriz_set'))

# Start of task_calib_info_iCalNoiseHoriz_get

`task_calib_info_iCalNoiseHoriz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iCalNoiseHoriz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iCalNoiseHoriz_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iCalNoiseHoriz_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iCalNoiseHoriz_get`) = c("SWIGFunction", class('task_calib_info_iCalNoiseHoriz_get'))

# Start of task_calib_info_iCalNoiseVert_set

`task_calib_info_iCalNoiseVert_set` = function(self, s_iCalNoiseVert)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iCalNoiseVert = coerceIfNotSubclass(s_iCalNoiseVert, "_p_short") 
  .Call('R_swig_task_calib_info_iCalNoiseVert_set', self, s_iCalNoiseVert, PACKAGE='iris')
  
}

attr(`task_calib_info_iCalNoiseVert_set`, 'returnType') = 'void'
attr(`task_calib_info_iCalNoiseVert_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iCalNoiseVert_set`) = c("SWIGFunction", class('task_calib_info_iCalNoiseVert_set'))

# Start of task_calib_info_iCalNoiseVert_get

`task_calib_info_iCalNoiseVert_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iCalNoiseVert_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iCalNoiseVert_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iCalNoiseVert_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iCalNoiseVert_get`) = c("SWIGFunction", class('task_calib_info_iCalNoiseVert_get'))

# Start of task_calib_info_iRadarConstantHoriz_set

`task_calib_info_iRadarConstantHoriz_set` = function(self, s_iRadarConstantHoriz)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iRadarConstantHoriz = coerceIfNotSubclass(s_iRadarConstantHoriz, "_p_short") 
  .Call('R_swig_task_calib_info_iRadarConstantHoriz_set', self, s_iRadarConstantHoriz, PACKAGE='iris')
  
}

attr(`task_calib_info_iRadarConstantHoriz_set`, 'returnType') = 'void'
attr(`task_calib_info_iRadarConstantHoriz_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iRadarConstantHoriz_set`) = c("SWIGFunction", class('task_calib_info_iRadarConstantHoriz_set'))

# Start of task_calib_info_iRadarConstantHoriz_get

`task_calib_info_iRadarConstantHoriz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iRadarConstantHoriz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iRadarConstantHoriz_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iRadarConstantHoriz_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iRadarConstantHoriz_get`) = c("SWIGFunction", class('task_calib_info_iRadarConstantHoriz_get'))

# Start of task_calib_info_iRadarConstantVert_set

`task_calib_info_iRadarConstantVert_set` = function(self, s_iRadarConstantVert)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iRadarConstantVert = coerceIfNotSubclass(s_iRadarConstantVert, "_p_short") 
  .Call('R_swig_task_calib_info_iRadarConstantVert_set', self, s_iRadarConstantVert, PACKAGE='iris')
  
}

attr(`task_calib_info_iRadarConstantVert_set`, 'returnType') = 'void'
attr(`task_calib_info_iRadarConstantVert_set`, "inputTypes") = c('_p_task_calib_info', '_p_short')
class(`task_calib_info_iRadarConstantVert_set`) = c("SWIGFunction", class('task_calib_info_iRadarConstantVert_set'))

# Start of task_calib_info_iRadarConstantVert_get

`task_calib_info_iRadarConstantVert_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iRadarConstantVert_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`task_calib_info_iRadarConstantVert_get`, 'returnType') = '_p_short'
attr(`task_calib_info_iRadarConstantVert_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iRadarConstantVert_get`) = c("SWIGFunction", class('task_calib_info_iRadarConstantVert_get'))

# Start of task_calib_info_iReceiverBandwidth_set

`task_calib_info_iReceiverBandwidth_set` = function(self, s_iReceiverBandwidth)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  s_iReceiverBandwidth = coerceIfNotSubclass(s_iReceiverBandwidth, "_p_unsigned_short") 
  .Call('R_swig_task_calib_info_iReceiverBandwidth_set', self, s_iReceiverBandwidth, PACKAGE='iris')
  
}

attr(`task_calib_info_iReceiverBandwidth_set`, 'returnType') = 'void'
attr(`task_calib_info_iReceiverBandwidth_set`, "inputTypes") = c('_p_task_calib_info', '_p_unsigned_short')
class(`task_calib_info_iReceiverBandwidth_set`) = c("SWIGFunction", class('task_calib_info_iReceiverBandwidth_set'))

# Start of task_calib_info_iReceiverBandwidth_get

`task_calib_info_iReceiverBandwidth_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_iReceiverBandwidth_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`task_calib_info_iReceiverBandwidth_get`, 'returnType') = '_p_unsigned_short'
attr(`task_calib_info_iReceiverBandwidth_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_iReceiverBandwidth_get`) = c("SWIGFunction", class('task_calib_info_iReceiverBandwidth_get'))

# Start of task_calib_info_ipad_end_set

`task_calib_info_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= (258))
  
  .Call('R_swig_task_calib_info_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`task_calib_info_ipad_end_set`, 'returnType') = 'void'
attr(`task_calib_info_ipad_end_set`, "inputTypes") = c('_p_task_calib_info', '_p_char')
class(`task_calib_info_ipad_end_set`) = c("SWIGFunction", class('task_calib_info_ipad_end_set'))

# Start of task_calib_info_ipad_end_get

`task_calib_info_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  ans = .Call('R_swig_task_calib_info_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`task_calib_info_ipad_end_get`, 'returnType') = '_p_char'
attr(`task_calib_info_ipad_end_get`, "inputTypes") = c('_p_task_calib_info')
class(`task_calib_info_ipad_end_get`) = c("SWIGFunction", class('task_calib_info_ipad_end_get'))

# Start of new_task_calib_info

`task_calib_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_calib_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_calib_info"
  
  ans
  
}

attr(`task_calib_info`, 'returnType') = '_p_task_calib_info'
class(`task_calib_info`) = c("SWIGFunction", class('task_calib_info'))

# Start of delete_task_calib_info

`delete_task_calib_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_calib_info") 
  .Call('R_swig_delete_task_calib_info', self, PACKAGE='iris')
  
}

attr(`delete_task_calib_info`, 'returnType') = 'void'
attr(`delete_task_calib_info`, "inputTypes") = c('_p_task_calib_info')
class(`delete_task_calib_info`) = c("SWIGFunction", class('delete_task_calib_info'))

# Start of accessor method for task_calib_info
setMethod('$', '_p_task_calib_info', function(x, name)

{
  accessorFuns = list('iz_slope' = task_calib_info_iz_slope_get, 'izns_thr' = task_calib_info_izns_thr_get, 'iccr_thr' = task_calib_info_iccr_thr_get, 'isqi_thr' = task_calib_info_isqi_thr_get, 'isig_thr' = task_calib_info_isig_thr_get, 'ipad10x8' = task_calib_info_ipad10x8_get, 'iz_calib' = task_calib_info_iz_calib_get, 'iuz_tcf' = task_calib_info_iuz_tcf_get, 'icz_tcf' = task_calib_info_icz_tcf_get, 'ivl_tcf' = task_calib_info_ivl_tcf_get, 'iwd_tcf' = task_calib_info_iwd_tcf_get, 'izdr_tcf' = task_calib_info_izdr_tcf_get, 'ipad30x6' = task_calib_info_ipad30x6_get, 'iflags' = task_calib_info_iflags_get, 'ipad38x2' = task_calib_info_ipad38x2_get, 'ildr_bias' = task_calib_info_ildr_bias_get, 'izdr_bias' = task_calib_info_izdr_bias_get, 'iPointClutterThreshold' = task_calib_info_iPointClutterThreshold_get, 'iPointClutterSkip' = task_calib_info_iPointClutterSkip_get, 'iI0Horiz' = task_calib_info_iI0Horiz_get, 'iI0Vert' = task_calib_info_iI0Vert_get, 'iCalNoiseHoriz' = task_calib_info_iCalNoiseHoriz_get, 'iCalNoiseVert' = task_calib_info_iCalNoiseVert_get, 'iRadarConstantHoriz' = task_calib_info_iRadarConstantHoriz_get, 'iRadarConstantVert' = task_calib_info_iRadarConstantVert_get, 'iReceiverBandwidth' = task_calib_info_iReceiverBandwidth_get, 'ipad_end' = task_calib_info_ipad_end_get)
  vaccessors = c('iz_slope', 'izns_thr', 'iccr_thr', 'isqi_thr', 'isig_thr', 'ipad10x8', 'iz_calib', 'iuz_tcf', 'icz_tcf', 'ivl_tcf', 'iwd_tcf', 'izdr_tcf', 'ipad30x6', 'iflags', 'ipad38x2', 'ildr_bias', 'izdr_bias', 'iPointClutterThreshold', 'iPointClutterSkip', 'iI0Horiz', 'iI0Vert', 'iCalNoiseHoriz', 'iCalNoiseVert', 'iRadarConstantHoriz', 'iRadarConstantVert', 'iReceiverBandwidth', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_calib_info
# Start of accessor method for task_calib_info
setMethod('$<-', '_p_task_calib_info', function(x, name, value)

{
  accessorFuns = list('iz_slope' = task_calib_info_iz_slope_set, 'izns_thr' = task_calib_info_izns_thr_set, 'iccr_thr' = task_calib_info_iccr_thr_set, 'isqi_thr' = task_calib_info_isqi_thr_set, 'isig_thr' = task_calib_info_isig_thr_set, 'ipad10x8' = task_calib_info_ipad10x8_set, 'iz_calib' = task_calib_info_iz_calib_set, 'iuz_tcf' = task_calib_info_iuz_tcf_set, 'icz_tcf' = task_calib_info_icz_tcf_set, 'ivl_tcf' = task_calib_info_ivl_tcf_set, 'iwd_tcf' = task_calib_info_iwd_tcf_set, 'izdr_tcf' = task_calib_info_izdr_tcf_set, 'ipad30x6' = task_calib_info_ipad30x6_set, 'iflags' = task_calib_info_iflags_set, 'ipad38x2' = task_calib_info_ipad38x2_set, 'ildr_bias' = task_calib_info_ildr_bias_set, 'izdr_bias' = task_calib_info_izdr_bias_set, 'iPointClutterThreshold' = task_calib_info_iPointClutterThreshold_set, 'iPointClutterSkip' = task_calib_info_iPointClutterSkip_set, 'iI0Horiz' = task_calib_info_iI0Horiz_set, 'iI0Vert' = task_calib_info_iI0Vert_set, 'iCalNoiseHoriz' = task_calib_info_iCalNoiseHoriz_set, 'iCalNoiseVert' = task_calib_info_iCalNoiseVert_set, 'iRadarConstantHoriz' = task_calib_info_iRadarConstantHoriz_set, 'iRadarConstantVert' = task_calib_info_iRadarConstantVert_set, 'iReceiverBandwidth' = task_calib_info_iReceiverBandwidth_set, 'ipad_end' = task_calib_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_calib_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iz_slope' = task_calib_info_iz_slope_set, 'izns_thr' = task_calib_info_izns_thr_set, 'iccr_thr' = task_calib_info_iccr_thr_set, 'isqi_thr' = task_calib_info_isqi_thr_set, 'isig_thr' = task_calib_info_isig_thr_set, 'ipad10x8' = task_calib_info_ipad10x8_set, 'iz_calib' = task_calib_info_iz_calib_set, 'iuz_tcf' = task_calib_info_iuz_tcf_set, 'icz_tcf' = task_calib_info_icz_tcf_set, 'ivl_tcf' = task_calib_info_ivl_tcf_set, 'iwd_tcf' = task_calib_info_iwd_tcf_set, 'izdr_tcf' = task_calib_info_izdr_tcf_set, 'ipad30x6' = task_calib_info_ipad30x6_set, 'iflags' = task_calib_info_iflags_set, 'ipad38x2' = task_calib_info_ipad38x2_set, 'ildr_bias' = task_calib_info_ildr_bias_set, 'izdr_bias' = task_calib_info_izdr_bias_set, 'iPointClutterThreshold' = task_calib_info_iPointClutterThreshold_set, 'iPointClutterSkip' = task_calib_info_iPointClutterSkip_set, 'iI0Horiz' = task_calib_info_iI0Horiz_set, 'iI0Vert' = task_calib_info_iI0Vert_set, 'iCalNoiseHoriz' = task_calib_info_iCalNoiseHoriz_set, 'iCalNoiseVert' = task_calib_info_iCalNoiseVert_set, 'iRadarConstantHoriz' = task_calib_info_iRadarConstantHoriz_set, 'iRadarConstantVert' = task_calib_info_iRadarConstantVert_set, 'iReceiverBandwidth' = task_calib_info_iReceiverBandwidth_set, 'ipad_end' = task_calib_info_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_calib_info
setMethod('delete', '_p_task_calib_info', function(obj) {delete_task_calib_info(obj)})
# Start definition of copy functions & methods for task_calib_info
CopyToR_task_calib_info = function(value, obj = new("task_calib_info"))
{
  obj@ipad10x8 = value$ipad10x8
  obj@ipad30x6 = value$ipad30x6
  obj@ipad38x2 = value$ipad38x2
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_task_calib_info = function(value, obj)
{
  obj$ipad10x8 = value@ipad10x8
  obj$ipad30x6 = value@ipad30x6
  obj$ipad38x2 = value@ipad38x2
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for task_calib_info
setMethod('copyToR', '_p_task_calib_info', CopyToR_task_calib_info)
setMethod('copyToC', 'task_calib_info', CopyToC_task_calib_info)

# End definition of copy methods for task_calib_info
# End definition of copy functions & methods for task_calib_info
# Start of serv_task_calib_info_iz_slope_set

`serv_task_calib_info_iz_slope_set` = function(self, s_iz_slope)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iz_slope = as.integer(s_iz_slope) 
  
  if(length(s_iz_slope) > 1) {
    Rf_warning("using only the first element of s_iz_slope")
  }
  
  .Call('R_swig_serv_task_calib_info_iz_slope_set', self, s_iz_slope, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iz_slope_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iz_slope_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iz_slope_set`) = c("SWIGFunction", class('serv_task_calib_info_iz_slope_set'))

# Start of serv_task_calib_info_iz_slope_get

`serv_task_calib_info_iz_slope_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iz_slope_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iz_slope_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iz_slope_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iz_slope_get`) = c("SWIGFunction", class('serv_task_calib_info_iz_slope_get'))

# Start of serv_task_calib_info_izns_thr_set

`serv_task_calib_info_izns_thr_set` = function(self, s_izns_thr)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_izns_thr = as.integer(s_izns_thr) 
  
  if(length(s_izns_thr) > 1) {
    Rf_warning("using only the first element of s_izns_thr")
  }
  
  .Call('R_swig_serv_task_calib_info_izns_thr_set', self, s_izns_thr, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_izns_thr_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_izns_thr_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_izns_thr_set`) = c("SWIGFunction", class('serv_task_calib_info_izns_thr_set'))

# Start of serv_task_calib_info_izns_thr_get

`serv_task_calib_info_izns_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_izns_thr_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_izns_thr_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_izns_thr_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_izns_thr_get`) = c("SWIGFunction", class('serv_task_calib_info_izns_thr_get'))

# Start of serv_task_calib_info_iccr_thr_set

`serv_task_calib_info_iccr_thr_set` = function(self, s_iccr_thr)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iccr_thr = as.integer(s_iccr_thr) 
  
  if(length(s_iccr_thr) > 1) {
    Rf_warning("using only the first element of s_iccr_thr")
  }
  
  .Call('R_swig_serv_task_calib_info_iccr_thr_set', self, s_iccr_thr, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iccr_thr_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iccr_thr_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iccr_thr_set`) = c("SWIGFunction", class('serv_task_calib_info_iccr_thr_set'))

# Start of serv_task_calib_info_iccr_thr_get

`serv_task_calib_info_iccr_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iccr_thr_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iccr_thr_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iccr_thr_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iccr_thr_get`) = c("SWIGFunction", class('serv_task_calib_info_iccr_thr_get'))

# Start of serv_task_calib_info_isqi_thr_set

`serv_task_calib_info_isqi_thr_set` = function(self, s_isqi_thr)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_isqi_thr = as.integer(s_isqi_thr) 
  
  if(length(s_isqi_thr) > 1) {
    Rf_warning("using only the first element of s_isqi_thr")
  }
  
  .Call('R_swig_serv_task_calib_info_isqi_thr_set', self, s_isqi_thr, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_isqi_thr_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_isqi_thr_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_isqi_thr_set`) = c("SWIGFunction", class('serv_task_calib_info_isqi_thr_set'))

# Start of serv_task_calib_info_isqi_thr_get

`serv_task_calib_info_isqi_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_isqi_thr_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_isqi_thr_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_isqi_thr_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_isqi_thr_get`) = c("SWIGFunction", class('serv_task_calib_info_isqi_thr_get'))

# Start of serv_task_calib_info_isig_thr_set

`serv_task_calib_info_isig_thr_set` = function(self, s_isig_thr)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_isig_thr = as.integer(s_isig_thr) 
  
  if(length(s_isig_thr) > 1) {
    Rf_warning("using only the first element of s_isig_thr")
  }
  
  .Call('R_swig_serv_task_calib_info_isig_thr_set', self, s_isig_thr, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_isig_thr_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_isig_thr_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_isig_thr_set`) = c("SWIGFunction", class('serv_task_calib_info_isig_thr_set'))

# Start of serv_task_calib_info_isig_thr_get

`serv_task_calib_info_isig_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_isig_thr_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_isig_thr_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_isig_thr_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_isig_thr_get`) = c("SWIGFunction", class('serv_task_calib_info_isig_thr_get'))

# Start of serv_task_calib_info_iz_calib_set

`serv_task_calib_info_iz_calib_set` = function(self, s_iz_calib)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iz_calib = as.integer(s_iz_calib) 
  
  if(length(s_iz_calib) > 1) {
    Rf_warning("using only the first element of s_iz_calib")
  }
  
  .Call('R_swig_serv_task_calib_info_iz_calib_set', self, s_iz_calib, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iz_calib_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iz_calib_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iz_calib_set`) = c("SWIGFunction", class('serv_task_calib_info_iz_calib_set'))

# Start of serv_task_calib_info_iz_calib_get

`serv_task_calib_info_iz_calib_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iz_calib_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iz_calib_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iz_calib_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iz_calib_get`) = c("SWIGFunction", class('serv_task_calib_info_iz_calib_get'))

# Start of serv_task_calib_info_iuz_tcf_set

`serv_task_calib_info_iuz_tcf_set` = function(self, s_iuz_tcf)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iuz_tcf = as.numeric(s_iuz_tcf) 
  
  assert(length(s_iuz_tcf) == 1 && s_iuz_tcf >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_calib_info_iuz_tcf_set', self, s_iuz_tcf, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iuz_tcf_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iuz_tcf_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iuz_tcf_set`) = c("SWIGFunction", class('serv_task_calib_info_iuz_tcf_set'))

# Start of serv_task_calib_info_iuz_tcf_get

`serv_task_calib_info_iuz_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iuz_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iuz_tcf_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iuz_tcf_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iuz_tcf_get`) = c("SWIGFunction", class('serv_task_calib_info_iuz_tcf_get'))

# Start of serv_task_calib_info_icz_tcf_set

`serv_task_calib_info_icz_tcf_set` = function(self, s_icz_tcf)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_icz_tcf = as.numeric(s_icz_tcf) 
  
  assert(length(s_icz_tcf) == 1 && s_icz_tcf >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_calib_info_icz_tcf_set', self, s_icz_tcf, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_icz_tcf_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_icz_tcf_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_icz_tcf_set`) = c("SWIGFunction", class('serv_task_calib_info_icz_tcf_set'))

# Start of serv_task_calib_info_icz_tcf_get

`serv_task_calib_info_icz_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_icz_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_icz_tcf_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_icz_tcf_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_icz_tcf_get`) = c("SWIGFunction", class('serv_task_calib_info_icz_tcf_get'))

# Start of serv_task_calib_info_ivl_tcf_set

`serv_task_calib_info_ivl_tcf_set` = function(self, s_ivl_tcf)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_ivl_tcf = as.numeric(s_ivl_tcf) 
  
  assert(length(s_ivl_tcf) == 1 && s_ivl_tcf >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_calib_info_ivl_tcf_set', self, s_ivl_tcf, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_ivl_tcf_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_ivl_tcf_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_ivl_tcf_set`) = c("SWIGFunction", class('serv_task_calib_info_ivl_tcf_set'))

# Start of serv_task_calib_info_ivl_tcf_get

`serv_task_calib_info_ivl_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_ivl_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_ivl_tcf_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_ivl_tcf_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_ivl_tcf_get`) = c("SWIGFunction", class('serv_task_calib_info_ivl_tcf_get'))

# Start of serv_task_calib_info_iwd_tcf_set

`serv_task_calib_info_iwd_tcf_set` = function(self, s_iwd_tcf)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iwd_tcf = as.numeric(s_iwd_tcf) 
  
  assert(length(s_iwd_tcf) == 1 && s_iwd_tcf >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_calib_info_iwd_tcf_set', self, s_iwd_tcf, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iwd_tcf_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iwd_tcf_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iwd_tcf_set`) = c("SWIGFunction", class('serv_task_calib_info_iwd_tcf_set'))

# Start of serv_task_calib_info_iwd_tcf_get

`serv_task_calib_info_iwd_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iwd_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iwd_tcf_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iwd_tcf_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iwd_tcf_get`) = c("SWIGFunction", class('serv_task_calib_info_iwd_tcf_get'))

# Start of serv_task_calib_info_izdr_tcf_set

`serv_task_calib_info_izdr_tcf_set` = function(self, s_izdr_tcf)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_izdr_tcf = as.numeric(s_izdr_tcf) 
  
  assert(length(s_izdr_tcf) == 1 && s_izdr_tcf >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_calib_info_izdr_tcf_set', self, s_izdr_tcf, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_izdr_tcf_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_izdr_tcf_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_izdr_tcf_set`) = c("SWIGFunction", class('serv_task_calib_info_izdr_tcf_set'))

# Start of serv_task_calib_info_izdr_tcf_get

`serv_task_calib_info_izdr_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_izdr_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_izdr_tcf_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_izdr_tcf_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_izdr_tcf_get`) = c("SWIGFunction", class('serv_task_calib_info_izdr_tcf_get'))

# Start of serv_task_calib_info_iflags_set

`serv_task_calib_info_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iflags = as.numeric(s_iflags) 
  
  assert(length(s_iflags) == 1 && s_iflags >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_calib_info_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iflags_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iflags_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iflags_set`) = c("SWIGFunction", class('serv_task_calib_info_iflags_set'))

# Start of serv_task_calib_info_iflags_get

`serv_task_calib_info_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iflags_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iflags_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iflags_get`) = c("SWIGFunction", class('serv_task_calib_info_iflags_get'))

# Start of serv_task_calib_info_iPointClutterThreshold_set

`serv_task_calib_info_iPointClutterThreshold_set` = function(self, s_iPointClutterThreshold)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iPointClutterThreshold = as.integer(s_iPointClutterThreshold) 
  
  if(length(s_iPointClutterThreshold) > 1) {
    Rf_warning("using only the first element of s_iPointClutterThreshold")
  }
  
  .Call('R_swig_serv_task_calib_info_iPointClutterThreshold_set', self, s_iPointClutterThreshold, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iPointClutterThreshold_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iPointClutterThreshold_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iPointClutterThreshold_set`) = c("SWIGFunction", class('serv_task_calib_info_iPointClutterThreshold_set'))

# Start of serv_task_calib_info_iPointClutterThreshold_get

`serv_task_calib_info_iPointClutterThreshold_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iPointClutterThreshold_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iPointClutterThreshold_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iPointClutterThreshold_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iPointClutterThreshold_get`) = c("SWIGFunction", class('serv_task_calib_info_iPointClutterThreshold_get'))

# Start of serv_task_calib_info_iPointClutterSkip_set

`serv_task_calib_info_iPointClutterSkip_set` = function(self, s_iPointClutterSkip)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  s_iPointClutterSkip = as.numeric(s_iPointClutterSkip) 
  
  assert(length(s_iPointClutterSkip) == 1 && s_iPointClutterSkip >= 0, "All values must be non-negative")
  
  .Call('R_swig_serv_task_calib_info_iPointClutterSkip_set', self, s_iPointClutterSkip, PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iPointClutterSkip_set`, 'returnType') = 'void'
attr(`serv_task_calib_info_iPointClutterSkip_set`, "inputTypes") = c('_p_serv_task_calib_info', 'numeric')
class(`serv_task_calib_info_iPointClutterSkip_set`) = c("SWIGFunction", class('serv_task_calib_info_iPointClutterSkip_set'))

# Start of serv_task_calib_info_iPointClutterSkip_get

`serv_task_calib_info_iPointClutterSkip_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_serv_task_calib_info_iPointClutterSkip_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`serv_task_calib_info_iPointClutterSkip_get`, 'returnType') = 'numeric'
attr(`serv_task_calib_info_iPointClutterSkip_get`, "inputTypes") = c('_p_serv_task_calib_info')
class(`serv_task_calib_info_iPointClutterSkip_get`) = c("SWIGFunction", class('serv_task_calib_info_iPointClutterSkip_get'))

# Start of new_serv_task_calib_info

`serv_task_calib_info` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_serv_task_calib_info', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_serv_task_calib_info"
  
  ans
  
}

attr(`serv_task_calib_info`, 'returnType') = '_p_serv_task_calib_info'
class(`serv_task_calib_info`) = c("SWIGFunction", class('serv_task_calib_info'))

# Start of delete_serv_task_calib_info

`delete_serv_task_calib_info` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_serv_task_calib_info") 
  .Call('R_swig_delete_serv_task_calib_info', self, PACKAGE='iris')
  
}

attr(`delete_serv_task_calib_info`, 'returnType') = 'void'
attr(`delete_serv_task_calib_info`, "inputTypes") = c('_p_serv_task_calib_info')
class(`delete_serv_task_calib_info`) = c("SWIGFunction", class('delete_serv_task_calib_info'))

# Start of accessor method for serv_task_calib_info
setMethod('$', '_p_serv_task_calib_info', function(x, name)

{
  accessorFuns = list('iz_slope' = serv_task_calib_info_iz_slope_get, 'izns_thr' = serv_task_calib_info_izns_thr_get, 'iccr_thr' = serv_task_calib_info_iccr_thr_get, 'isqi_thr' = serv_task_calib_info_isqi_thr_get, 'isig_thr' = serv_task_calib_info_isig_thr_get, 'iz_calib' = serv_task_calib_info_iz_calib_get, 'iuz_tcf' = serv_task_calib_info_iuz_tcf_get, 'icz_tcf' = serv_task_calib_info_icz_tcf_get, 'ivl_tcf' = serv_task_calib_info_ivl_tcf_get, 'iwd_tcf' = serv_task_calib_info_iwd_tcf_get, 'izdr_tcf' = serv_task_calib_info_izdr_tcf_get, 'iflags' = serv_task_calib_info_iflags_get, 'iPointClutterThreshold' = serv_task_calib_info_iPointClutterThreshold_get, 'iPointClutterSkip' = serv_task_calib_info_iPointClutterSkip_get)
  vaccessors = c('iz_slope', 'izns_thr', 'iccr_thr', 'isqi_thr', 'isig_thr', 'iz_calib', 'iuz_tcf', 'icz_tcf', 'ivl_tcf', 'iwd_tcf', 'izdr_tcf', 'iflags', 'iPointClutterThreshold', 'iPointClutterSkip')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for serv_task_calib_info
# Start of accessor method for serv_task_calib_info
setMethod('$<-', '_p_serv_task_calib_info', function(x, name, value)

{
  accessorFuns = list('iz_slope' = serv_task_calib_info_iz_slope_set, 'izns_thr' = serv_task_calib_info_izns_thr_set, 'iccr_thr' = serv_task_calib_info_iccr_thr_set, 'isqi_thr' = serv_task_calib_info_isqi_thr_set, 'isig_thr' = serv_task_calib_info_isig_thr_set, 'iz_calib' = serv_task_calib_info_iz_calib_set, 'iuz_tcf' = serv_task_calib_info_iuz_tcf_set, 'icz_tcf' = serv_task_calib_info_icz_tcf_set, 'ivl_tcf' = serv_task_calib_info_ivl_tcf_set, 'iwd_tcf' = serv_task_calib_info_iwd_tcf_set, 'izdr_tcf' = serv_task_calib_info_izdr_tcf_set, 'iflags' = serv_task_calib_info_iflags_set, 'iPointClutterThreshold' = serv_task_calib_info_iPointClutterThreshold_set, 'iPointClutterSkip' = serv_task_calib_info_iPointClutterSkip_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_serv_task_calib_info', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iz_slope' = serv_task_calib_info_iz_slope_set, 'izns_thr' = serv_task_calib_info_izns_thr_set, 'iccr_thr' = serv_task_calib_info_iccr_thr_set, 'isqi_thr' = serv_task_calib_info_isqi_thr_set, 'isig_thr' = serv_task_calib_info_isig_thr_set, 'iz_calib' = serv_task_calib_info_iz_calib_set, 'iuz_tcf' = serv_task_calib_info_iuz_tcf_set, 'icz_tcf' = serv_task_calib_info_icz_tcf_set, 'ivl_tcf' = serv_task_calib_info_ivl_tcf_set, 'iwd_tcf' = serv_task_calib_info_iwd_tcf_set, 'izdr_tcf' = serv_task_calib_info_izdr_tcf_set, 'iflags' = serv_task_calib_info_iflags_set, 'iPointClutterThreshold' = serv_task_calib_info_iPointClutterThreshold_set, 'iPointClutterSkip' = serv_task_calib_info_iPointClutterSkip_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for serv_task_calib_info
setMethod('delete', '_p_serv_task_calib_info', function(obj) {delete_serv_task_calib_info(obj)})
# Start definition of copy functions & methods for serv_task_calib_info
CopyToR_serv_task_calib_info = function(value, obj = new("serv_task_calib_info"))
{
  obj@iz_slope = value$iz_slope
  obj@izns_thr = value$izns_thr
  obj@iccr_thr = value$iccr_thr
  obj@isqi_thr = value$isqi_thr
  obj@isig_thr = value$isig_thr
  obj@iz_calib = value$iz_calib
  obj@iuz_tcf = value$iuz_tcf
  obj@icz_tcf = value$icz_tcf
  obj@ivl_tcf = value$ivl_tcf
  obj@iwd_tcf = value$iwd_tcf
  obj@izdr_tcf = value$izdr_tcf
  obj@iflags = value$iflags
  obj@iPointClutterThreshold = value$iPointClutterThreshold
  obj@iPointClutterSkip = value$iPointClutterSkip
  obj
}



CopyToC_serv_task_calib_info = function(value, obj)
{
  obj$iz_slope = value@iz_slope
  obj$izns_thr = value@izns_thr
  obj$iccr_thr = value@iccr_thr
  obj$isqi_thr = value@isqi_thr
  obj$isig_thr = value@isig_thr
  obj$iz_calib = value@iz_calib
  obj$iuz_tcf = value@iuz_tcf
  obj$icz_tcf = value@icz_tcf
  obj$ivl_tcf = value@ivl_tcf
  obj$iwd_tcf = value@iwd_tcf
  obj$izdr_tcf = value@izdr_tcf
  obj$iflags = value@iflags
  obj$iPointClutterThreshold = value@iPointClutterThreshold
  obj$iPointClutterSkip = value@iPointClutterSkip
  obj
}



# Start definition of copy methods for serv_task_calib_info
setMethod('copyToR', '_p_serv_task_calib_info', CopyToR_serv_task_calib_info)
setMethod('copyToC', 'serv_task_calib_info', CopyToC_serv_task_calib_info)

# End definition of copy methods for serv_task_calib_info
# End definition of copy functions & methods for serv_task_calib_info
# Start of task_configuration_hdr_set

`task_configuration_hdr_set` = function(self, s_hdr)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_hdr = coerceIfNotSubclass(s_hdr, "_p_structure_header") 
  .Call('R_swig_task_configuration_hdr_set', self, s_hdr, PACKAGE='iris')
  
}

attr(`task_configuration_hdr_set`, 'returnType') = 'void'
attr(`task_configuration_hdr_set`, "inputTypes") = c('_p_task_configuration', '_p_structure_header')
class(`task_configuration_hdr_set`) = c("SWIGFunction", class('task_configuration_hdr_set'))

# Start of task_configuration_hdr_get

`task_configuration_hdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_hdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_structure_header"
  
  ans
  
}

attr(`task_configuration_hdr_get`, 'returnType') = '_p_structure_header'
attr(`task_configuration_hdr_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_hdr_get`) = c("SWIGFunction", class('task_configuration_hdr_get'))

# Start of task_configuration_sch_set

`task_configuration_sch_set` = function(self, s_sch)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_sch = coerceIfNotSubclass(s_sch, "_p_task_sched_info") 
  .Call('R_swig_task_configuration_sch_set', self, s_sch, PACKAGE='iris')
  
}

attr(`task_configuration_sch_set`, 'returnType') = 'void'
attr(`task_configuration_sch_set`, "inputTypes") = c('_p_task_configuration', '_p_task_sched_info')
class(`task_configuration_sch_set`) = c("SWIGFunction", class('task_configuration_sch_set'))

# Start of task_configuration_sch_get

`task_configuration_sch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_sch_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_sched_info"
  
  ans
  
}

attr(`task_configuration_sch_get`, 'returnType') = '_p_task_sched_info'
attr(`task_configuration_sch_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_sch_get`) = c("SWIGFunction", class('task_configuration_sch_get'))

# Start of task_configuration_dsp_set

`task_configuration_dsp_set` = function(self, s_dsp)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_dsp = coerceIfNotSubclass(s_dsp, "_p_task_dsp_info") 
  .Call('R_swig_task_configuration_dsp_set', self, s_dsp, PACKAGE='iris')
  
}

attr(`task_configuration_dsp_set`, 'returnType') = 'void'
attr(`task_configuration_dsp_set`, "inputTypes") = c('_p_task_configuration', '_p_task_dsp_info')
class(`task_configuration_dsp_set`) = c("SWIGFunction", class('task_configuration_dsp_set'))

# Start of task_configuration_dsp_get

`task_configuration_dsp_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_dsp_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_dsp_info"
  
  ans
  
}

attr(`task_configuration_dsp_get`, 'returnType') = '_p_task_dsp_info'
attr(`task_configuration_dsp_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_dsp_get`) = c("SWIGFunction", class('task_configuration_dsp_get'))

# Start of task_configuration_cal_set

`task_configuration_cal_set` = function(self, s_cal)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_cal = coerceIfNotSubclass(s_cal, "_p_task_calib_info") 
  .Call('R_swig_task_configuration_cal_set', self, s_cal, PACKAGE='iris')
  
}

attr(`task_configuration_cal_set`, 'returnType') = 'void'
attr(`task_configuration_cal_set`, "inputTypes") = c('_p_task_configuration', '_p_task_calib_info')
class(`task_configuration_cal_set`) = c("SWIGFunction", class('task_configuration_cal_set'))

# Start of task_configuration_cal_get

`task_configuration_cal_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_cal_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_calib_info"
  
  ans
  
}

attr(`task_configuration_cal_get`, 'returnType') = '_p_task_calib_info'
attr(`task_configuration_cal_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_cal_get`) = c("SWIGFunction", class('task_configuration_cal_get'))

# Start of task_configuration_rng_set

`task_configuration_rng_set` = function(self, s_rng)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_rng = coerceIfNotSubclass(s_rng, "_p_task_range_info") 
  .Call('R_swig_task_configuration_rng_set', self, s_rng, PACKAGE='iris')
  
}

attr(`task_configuration_rng_set`, 'returnType') = 'void'
attr(`task_configuration_rng_set`, "inputTypes") = c('_p_task_configuration', '_p_task_range_info')
class(`task_configuration_rng_set`) = c("SWIGFunction", class('task_configuration_rng_set'))

# Start of task_configuration_rng_get

`task_configuration_rng_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_rng_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_range_info"
  
  ans
  
}

attr(`task_configuration_rng_get`, 'returnType') = '_p_task_range_info'
attr(`task_configuration_rng_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_rng_get`) = c("SWIGFunction", class('task_configuration_rng_get'))

# Start of task_configuration_scan_set

`task_configuration_scan_set` = function(self, s_scan)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_scan = coerceIfNotSubclass(s_scan, "_p_task_scan_info") 
  .Call('R_swig_task_configuration_scan_set', self, s_scan, PACKAGE='iris')
  
}

attr(`task_configuration_scan_set`, 'returnType') = 'void'
attr(`task_configuration_scan_set`, "inputTypes") = c('_p_task_configuration', '_p_task_scan_info')
class(`task_configuration_scan_set`) = c("SWIGFunction", class('task_configuration_scan_set'))

# Start of task_configuration_scan_get

`task_configuration_scan_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_scan_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_scan_info"
  
  ans
  
}

attr(`task_configuration_scan_get`, 'returnType') = '_p_task_scan_info'
attr(`task_configuration_scan_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_scan_get`) = c("SWIGFunction", class('task_configuration_scan_get'))

# Start of task_configuration_misc_set

`task_configuration_misc_set` = function(self, s_misc)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_misc = coerceIfNotSubclass(s_misc, "_p_task_misc_info") 
  .Call('R_swig_task_configuration_misc_set', self, s_misc, PACKAGE='iris')
  
}

attr(`task_configuration_misc_set`, 'returnType') = 'void'
attr(`task_configuration_misc_set`, "inputTypes") = c('_p_task_configuration', '_p_task_misc_info')
class(`task_configuration_misc_set`) = c("SWIGFunction", class('task_configuration_misc_set'))

# Start of task_configuration_misc_get

`task_configuration_misc_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_misc_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_misc_info"
  
  ans
  
}

attr(`task_configuration_misc_get`, 'returnType') = '_p_task_misc_info'
attr(`task_configuration_misc_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_misc_get`) = c("SWIGFunction", class('task_configuration_misc_get'))

# Start of task_configuration_end_set

`task_configuration_end_set` = function(self, s_end)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  s_end = coerceIfNotSubclass(s_end, "_p_task_end_info") 
  .Call('R_swig_task_configuration_end_set', self, s_end, PACKAGE='iris')
  
}

attr(`task_configuration_end_set`, 'returnType') = 'void'
attr(`task_configuration_end_set`, "inputTypes") = c('_p_task_configuration', '_p_task_end_info')
class(`task_configuration_end_set`) = c("SWIGFunction", class('task_configuration_end_set'))

# Start of task_configuration_end_get

`task_configuration_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_end_info"
  
  ans
  
}

attr(`task_configuration_end_get`, 'returnType') = '_p_task_end_info'
attr(`task_configuration_end_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_end_get`) = c("SWIGFunction", class('task_configuration_end_get'))

# Start of task_configuration_comnts_set

`task_configuration_comnts_set` = function(self, s_comnts)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  
  if(is.list(s_comnts))
  assert(all(sapply(s_comnts, class) == "_p_unsigned_char"))     
  
  
#  assert(length(s_comnts) >= 720)
  
  .Call('R_swig_task_configuration_comnts_set', self, s_comnts, PACKAGE='iris')
  
}

attr(`task_configuration_comnts_set`, 'returnType') = 'void'
attr(`task_configuration_comnts_set`, "inputTypes") = c('_p_task_configuration', '_p_unsigned_char')
class(`task_configuration_comnts_set`) = c("SWIGFunction", class('task_configuration_comnts_set'))

# Start of task_configuration_comnts_get

`task_configuration_comnts_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  ans = .Call('R_swig_task_configuration_comnts_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`task_configuration_comnts_get`, 'returnType') = '_p_unsigned_char'
attr(`task_configuration_comnts_get`, "inputTypes") = c('_p_task_configuration')
class(`task_configuration_comnts_get`) = c("SWIGFunction", class('task_configuration_comnts_get'))

# Start of new_task_configuration

`task_configuration` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_task_configuration', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_configuration"
  
  ans
  
}

attr(`task_configuration`, 'returnType') = '_p_task_configuration'
class(`task_configuration`) = c("SWIGFunction", class('task_configuration'))

# Start of delete_task_configuration

`delete_task_configuration` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_task_configuration") 
  .Call('R_swig_delete_task_configuration', self, PACKAGE='iris')
  
}

attr(`delete_task_configuration`, 'returnType') = 'void'
attr(`delete_task_configuration`, "inputTypes") = c('_p_task_configuration')
class(`delete_task_configuration`) = c("SWIGFunction", class('delete_task_configuration'))

# Start of accessor method for task_configuration
setMethod('$', '_p_task_configuration', function(x, name)

{
  accessorFuns = list('hdr' = task_configuration_hdr_get, 'sch' = task_configuration_sch_get, 'dsp' = task_configuration_dsp_get, 'cal' = task_configuration_cal_get, 'rng' = task_configuration_rng_get, 'scan' = task_configuration_scan_get, 'misc' = task_configuration_misc_get, 'end' = task_configuration_end_get, 'comnts' = task_configuration_comnts_get)
  vaccessors = c('hdr', 'sch', 'dsp', 'cal', 'rng', 'scan', 'misc', 'end', 'comnts')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for task_configuration
# Start of accessor method for task_configuration
setMethod('$<-', '_p_task_configuration', function(x, name, value)

{
  accessorFuns = list('hdr' = task_configuration_hdr_set, 'sch' = task_configuration_sch_set, 'dsp' = task_configuration_dsp_set, 'cal' = task_configuration_cal_set, 'rng' = task_configuration_rng_set, 'scan' = task_configuration_scan_set, 'misc' = task_configuration_misc_set, 'end' = task_configuration_end_set, 'comnts' = task_configuration_comnts_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_task_configuration', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('hdr' = task_configuration_hdr_set, 'sch' = task_configuration_sch_set, 'dsp' = task_configuration_dsp_set, 'cal' = task_configuration_cal_set, 'rng' = task_configuration_rng_set, 'scan' = task_configuration_scan_set, 'misc' = task_configuration_misc_set, 'end' = task_configuration_end_set, 'comnts' = task_configuration_comnts_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for task_configuration
setMethod('delete', '_p_task_configuration', function(obj) {delete_task_configuration(obj)})
# Start definition of copy functions & methods for task_configuration
CopyToR_task_configuration = function(value, obj = new("task_configuration"))
{
  obj
}



CopyToC_task_configuration = function(value, obj)
{
  obj
}



# Start definition of copy methods for task_configuration
setMethod('copyToR', '_p_task_configuration', CopyToR_task_configuration)
setMethod('copyToC', 'task_configuration', CopyToC_task_configuration)

# End definition of copy methods for task_configuration
# End definition of copy functions & methods for task_configuration
# Start of gparm_irev_ser_set

`gparm_irev_ser_set` = function(self, s_irev_ser)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_irev_ser = coerceIfNotSubclass(s_irev_ser, "_p_unsigned_short") 
  .Call('R_swig_gparm_irev_ser_set', self, s_irev_ser, PACKAGE='iris')
  
}

attr(`gparm_irev_ser_set`, 'returnType') = 'void'
attr(`gparm_irev_ser_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_irev_ser_set`) = c("SWIGFunction", class('gparm_irev_ser_set'))

# Start of gparm_irev_ser_get

`gparm_irev_ser_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_irev_ser_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_irev_ser_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_irev_ser_get`, "inputTypes") = c('_p_gparm')
class(`gparm_irev_ser_get`) = c("SWIGFunction", class('gparm_irev_ser_get'))

# Start of gparm_ibin_out_num_set

`gparm_ibin_out_num_set` = function(self, s_ibin_out_num)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ibin_out_num = coerceIfNotSubclass(s_ibin_out_num, "_p_unsigned_short") 
  .Call('R_swig_gparm_ibin_out_num_set', self, s_ibin_out_num, PACKAGE='iris')
  
}

attr(`gparm_ibin_out_num_set`, 'returnType') = 'void'
attr(`gparm_ibin_out_num_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ibin_out_num_set`) = c("SWIGFunction", class('gparm_ibin_out_num_set'))

# Start of gparm_ibin_out_num_get

`gparm_ibin_out_num_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ibin_out_num_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ibin_out_num_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ibin_out_num_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ibin_out_num_get`) = c("SWIGFunction", class('gparm_ibin_out_num_get'))

# Start of gparm_iprt_mes_set

`gparm_iprt_mes_set` = function(self, s_iprt_mes)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iprt_mes = coerceIfNotSubclass(s_iprt_mes, "_p_unsigned_short") 
  .Call('R_swig_gparm_iprt_mes_set', self, s_iprt_mes, PACKAGE='iris')
  
}

attr(`gparm_iprt_mes_set`, 'returnType') = 'void'
attr(`gparm_iprt_mes_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iprt_mes_set`) = c("SWIGFunction", class('gparm_iprt_mes_set'))

# Start of gparm_iprt_mes_get

`gparm_iprt_mes_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iprt_mes_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iprt_mes_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iprt_mes_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iprt_mes_get`) = c("SWIGFunction", class('gparm_iprt_mes_get'))

# Start of gparm_itaga_set

`gparm_itaga_set` = function(self, s_itaga)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_itaga = coerceIfNotSubclass(s_itaga, "_p_unsigned_short") 
  .Call('R_swig_gparm_itaga_set', self, s_itaga, PACKAGE='iris')
  
}

attr(`gparm_itaga_set`, 'returnType') = 'void'
attr(`gparm_itaga_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_itaga_set`) = c("SWIGFunction", class('gparm_itaga_set'))

# Start of gparm_itaga_get

`gparm_itaga_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_itaga_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_itaga_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_itaga_get`, "inputTypes") = c('_p_gparm')
class(`gparm_itaga_get`) = c("SWIGFunction", class('gparm_itaga_get'))

# Start of gparm_itagb_set

`gparm_itagb_set` = function(self, s_itagb)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_itagb = coerceIfNotSubclass(s_itagb, "_p_unsigned_short") 
  .Call('R_swig_gparm_itagb_set', self, s_itagb, PACKAGE='iris')
  
}

attr(`gparm_itagb_set`, 'returnType') = 'void'
attr(`gparm_itagb_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_itagb_set`) = c("SWIGFunction", class('gparm_itagb_set'))

# Start of gparm_itagb_get

`gparm_itagb_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_itagb_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_itagb_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_itagb_get`, "inputTypes") = c('_p_gparm')
class(`gparm_itagb_get`) = c("SWIGFunction", class('gparm_itagb_get'))

# Start of gparm_log_nse_set

`gparm_log_nse_set` = function(self, s_log_nse)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_log_nse = coerceIfNotSubclass(s_log_nse, "_p_unsigned_short") 
  .Call('R_swig_gparm_log_nse_set', self, s_log_nse, PACKAGE='iris')
  
}

attr(`gparm_log_nse_set`, 'returnType') = 'void'
attr(`gparm_log_nse_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_log_nse_set`) = c("SWIGFunction", class('gparm_log_nse_set'))

# Start of gparm_log_nse_get

`gparm_log_nse_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_log_nse_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_log_nse_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_log_nse_get`, "inputTypes") = c('_p_gparm')
class(`gparm_log_nse_get`) = c("SWIGFunction", class('gparm_log_nse_get'))

# Start of gparm_i_nse__set

`gparm_i_nse__set` = function(self, s_i_nse_)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_i_nse_ = coerceIfNotSubclass(s_i_nse_, "_p_short") 
  .Call('R_swig_gparm_i_nse__set', self, s_i_nse_, PACKAGE='iris')
  
}

attr(`gparm_i_nse__set`, 'returnType') = 'void'
attr(`gparm_i_nse__set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_i_nse__set`) = c("SWIGFunction", class('gparm_i_nse__set'))

# Start of gparm_i_nse__get

`gparm_i_nse__get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_i_nse__get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_i_nse__get`, 'returnType') = '_p_short'
attr(`gparm_i_nse__get`, "inputTypes") = c('_p_gparm')
class(`gparm_i_nse__get`) = c("SWIGFunction", class('gparm_i_nse__get'))

# Start of gparm_q_nse__set

`gparm_q_nse__set` = function(self, s_q_nse_)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_q_nse_ = coerceIfNotSubclass(s_q_nse_, "_p_short") 
  .Call('R_swig_gparm_q_nse__set', self, s_q_nse_, PACKAGE='iris')
  
}

attr(`gparm_q_nse__set`, 'returnType') = 'void'
attr(`gparm_q_nse__set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_q_nse__set`) = c("SWIGFunction", class('gparm_q_nse__set'))

# Start of gparm_q_nse__get

`gparm_q_nse__get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_q_nse__get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_q_nse__get`, 'returnType') = '_p_short'
attr(`gparm_q_nse__get`, "inputTypes") = c('_p_gparm')
class(`gparm_q_nse__get`) = c("SWIGFunction", class('gparm_q_nse__get'))

# Start of gparm_istat_l_set

`gparm_istat_l_set` = function(self, s_istat_l)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_istat_l = coerceIfNotSubclass(s_istat_l, "_p_unsigned_short") 
  .Call('R_swig_gparm_istat_l_set', self, s_istat_l, PACKAGE='iris')
  
}

attr(`gparm_istat_l_set`, 'returnType') = 'void'
attr(`gparm_istat_l_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_istat_l_set`) = c("SWIGFunction", class('gparm_istat_l_set'))

# Start of gparm_istat_l_get

`gparm_istat_l_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_istat_l_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_istat_l_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_istat_l_get`, "inputTypes") = c('_p_gparm')
class(`gparm_istat_l_get`) = c("SWIGFunction", class('gparm_istat_l_get'))

# Start of gparm_istat_i_set

`gparm_istat_i_set` = function(self, s_istat_i)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_istat_i = coerceIfNotSubclass(s_istat_i, "_p_unsigned_short") 
  .Call('R_swig_gparm_istat_i_set', self, s_istat_i, PACKAGE='iris')
  
}

attr(`gparm_istat_i_set`, 'returnType') = 'void'
attr(`gparm_istat_i_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_istat_i_set`) = c("SWIGFunction", class('gparm_istat_i_set'))

# Start of gparm_istat_i_get

`gparm_istat_i_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_istat_i_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_istat_i_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_istat_i_get`, "inputTypes") = c('_p_gparm')
class(`gparm_istat_i_get`) = c("SWIGFunction", class('gparm_istat_i_get'))

# Start of gparm_idiag_a_set

`gparm_idiag_a_set` = function(self, s_idiag_a)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_idiag_a = coerceIfNotSubclass(s_idiag_a, "_p_unsigned_short") 
  .Call('R_swig_gparm_idiag_a_set', self, s_idiag_a, PACKAGE='iris')
  
}

attr(`gparm_idiag_a_set`, 'returnType') = 'void'
attr(`gparm_idiag_a_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_idiag_a_set`) = c("SWIGFunction", class('gparm_idiag_a_set'))

# Start of gparm_idiag_a_get

`gparm_idiag_a_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_idiag_a_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_idiag_a_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_idiag_a_get`, "inputTypes") = c('_p_gparm')
class(`gparm_idiag_a_get`) = c("SWIGFunction", class('gparm_idiag_a_get'))

# Start of gparm_idiag_b_set

`gparm_idiag_b_set` = function(self, s_idiag_b)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_idiag_b = coerceIfNotSubclass(s_idiag_b, "_p_unsigned_short") 
  .Call('R_swig_gparm_idiag_b_set', self, s_idiag_b, PACKAGE='iris')
  
}

attr(`gparm_idiag_b_set`, 'returnType') = 'void'
attr(`gparm_idiag_b_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_idiag_b_set`) = c("SWIGFunction", class('gparm_idiag_b_set'))

# Start of gparm_idiag_b_get

`gparm_idiag_b_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_idiag_b_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_idiag_b_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_idiag_b_get`, "inputTypes") = c('_p_gparm')
class(`gparm_idiag_b_get`) = c("SWIGFunction", class('gparm_idiag_b_get'))

# Start of gparm_isamp_set

`gparm_isamp_set` = function(self, s_isamp)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_isamp = coerceIfNotSubclass(s_isamp, "_p_unsigned_short") 
  .Call('R_swig_gparm_isamp_set', self, s_isamp, PACKAGE='iris')
  
}

attr(`gparm_isamp_set`, 'returnType') = 'void'
attr(`gparm_isamp_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_isamp_set`) = c("SWIGFunction", class('gparm_isamp_set'))

# Start of gparm_isamp_get

`gparm_isamp_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_isamp_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_isamp_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_isamp_get`, "inputTypes") = c('_p_gparm')
class(`gparm_isamp_get`) = c("SWIGFunction", class('gparm_isamp_get'))

# Start of gparm_itrg_cnt_a_set

`gparm_itrg_cnt_a_set` = function(self, s_itrg_cnt_a)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_itrg_cnt_a = coerceIfNotSubclass(s_itrg_cnt_a, "_p_unsigned_short") 
  .Call('R_swig_gparm_itrg_cnt_a_set', self, s_itrg_cnt_a, PACKAGE='iris')
  
}

attr(`gparm_itrg_cnt_a_set`, 'returnType') = 'void'
attr(`gparm_itrg_cnt_a_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_itrg_cnt_a_set`) = c("SWIGFunction", class('gparm_itrg_cnt_a_set'))

# Start of gparm_itrg_cnt_a_get

`gparm_itrg_cnt_a_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_itrg_cnt_a_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_itrg_cnt_a_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_itrg_cnt_a_get`, "inputTypes") = c('_p_gparm')
class(`gparm_itrg_cnt_a_get`) = c("SWIGFunction", class('gparm_itrg_cnt_a_get'))

# Start of gparm_itrg_cnt_b_set

`gparm_itrg_cnt_b_set` = function(self, s_itrg_cnt_b)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_itrg_cnt_b = coerceIfNotSubclass(s_itrg_cnt_b, "_p_unsigned_short") 
  .Call('R_swig_gparm_itrg_cnt_b_set', self, s_itrg_cnt_b, PACKAGE='iris')
  
}

attr(`gparm_itrg_cnt_b_set`, 'returnType') = 'void'
attr(`gparm_itrg_cnt_b_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_itrg_cnt_b_set`) = c("SWIGFunction", class('gparm_itrg_cnt_b_set'))

# Start of gparm_itrg_cnt_b_get

`gparm_itrg_cnt_b_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_itrg_cnt_b_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_itrg_cnt_b_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_itrg_cnt_b_get`, "inputTypes") = c('_p_gparm')
class(`gparm_itrg_cnt_b_get`) = c("SWIGFunction", class('gparm_itrg_cnt_b_get'))

# Start of gparm_iaqbins_set

`gparm_iaqbins_set` = function(self, s_iaqbins)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iaqbins = coerceIfNotSubclass(s_iaqbins, "_p_unsigned_short") 
  .Call('R_swig_gparm_iaqbins_set', self, s_iaqbins, PACKAGE='iris')
  
}

attr(`gparm_iaqbins_set`, 'returnType') = 'void'
attr(`gparm_iaqbins_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iaqbins_set`) = c("SWIGFunction", class('gparm_iaqbins_set'))

# Start of gparm_iaqbins_get

`gparm_iaqbins_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iaqbins_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iaqbins_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iaqbins_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iaqbins_get`) = c("SWIGFunction", class('gparm_iaqbins_get'))

# Start of gparm_iprbins_set

`gparm_iprbins_set` = function(self, s_iprbins)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iprbins = coerceIfNotSubclass(s_iprbins, "_p_unsigned_short") 
  .Call('R_swig_gparm_iprbins_set', self, s_iprbins, PACKAGE='iris')
  
}

attr(`gparm_iprbins_set`, 'returnType') = 'void'
attr(`gparm_iprbins_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iprbins_set`) = c("SWIGFunction", class('gparm_iprbins_set'))

# Start of gparm_iprbins_get

`gparm_iprbins_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iprbins_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iprbins_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iprbins_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iprbins_get`) = c("SWIGFunction", class('gparm_iprbins_get'))

# Start of gparm_istat_i2_set

`gparm_istat_i2_set` = function(self, s_istat_i2)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_istat_i2 = coerceIfNotSubclass(s_istat_i2, "_p_unsigned_short") 
  .Call('R_swig_gparm_istat_i2_set', self, s_istat_i2, PACKAGE='iris')
  
}

attr(`gparm_istat_i2_set`, 'returnType') = 'void'
attr(`gparm_istat_i2_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_istat_i2_set`) = c("SWIGFunction", class('gparm_istat_i2_set'))

# Start of gparm_istat_i2_get

`gparm_istat_i2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_istat_i2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_istat_i2_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_istat_i2_get`, "inputTypes") = c('_p_gparm')
class(`gparm_istat_i2_get`) = c("SWIGFunction", class('gparm_istat_i2_get'))

# Start of gparm_inse_rng_set

`gparm_inse_rng_set` = function(self, s_inse_rng)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_inse_rng = coerceIfNotSubclass(s_inse_rng, "_p_unsigned_short") 
  .Call('R_swig_gparm_inse_rng_set', self, s_inse_rng, PACKAGE='iris')
  
}

attr(`gparm_inse_rng_set`, 'returnType') = 'void'
attr(`gparm_inse_rng_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_inse_rng_set`) = c("SWIGFunction", class('gparm_inse_rng_set'))

# Start of gparm_inse_rng_get

`gparm_inse_rng_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_inse_rng_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_inse_rng_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_inse_rng_get`, "inputTypes") = c('_p_gparm')
class(`gparm_inse_rng_get`) = c("SWIGFunction", class('gparm_inse_rng_get'))

# Start of gparm_inse_prt_set

`gparm_inse_prt_set` = function(self, s_inse_prt)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_inse_prt = coerceIfNotSubclass(s_inse_prt, "_p_unsigned_short") 
  .Call('R_swig_gparm_inse_prt_set', self, s_inse_prt, PACKAGE='iris')
  
}

attr(`gparm_inse_prt_set`, 'returnType') = 'void'
attr(`gparm_inse_prt_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_inse_prt_set`) = c("SWIGFunction", class('gparm_inse_prt_set'))

# Start of gparm_inse_prt_get

`gparm_inse_prt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_inse_prt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_inse_prt_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_inse_prt_get`, "inputTypes") = c('_p_gparm')
class(`gparm_inse_prt_get`) = c("SWIGFunction", class('gparm_inse_prt_get'))

# Start of gparm_ipwmin_0_set

`gparm_ipwmin_0_set` = function(self, s_ipwmin_0)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ipwmin_0 = coerceIfNotSubclass(s_ipwmin_0, "_p_unsigned_short") 
  .Call('R_swig_gparm_ipwmin_0_set', self, s_ipwmin_0, PACKAGE='iris')
  
}

attr(`gparm_ipwmin_0_set`, 'returnType') = 'void'
attr(`gparm_ipwmin_0_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ipwmin_0_set`) = c("SWIGFunction", class('gparm_ipwmin_0_set'))

# Start of gparm_ipwmin_0_get

`gparm_ipwmin_0_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ipwmin_0_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ipwmin_0_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ipwmin_0_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ipwmin_0_get`) = c("SWIGFunction", class('gparm_ipwmin_0_get'))

# Start of gparm_ipwmin_1_set

`gparm_ipwmin_1_set` = function(self, s_ipwmin_1)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ipwmin_1 = coerceIfNotSubclass(s_ipwmin_1, "_p_unsigned_short") 
  .Call('R_swig_gparm_ipwmin_1_set', self, s_ipwmin_1, PACKAGE='iris')
  
}

attr(`gparm_ipwmin_1_set`, 'returnType') = 'void'
attr(`gparm_ipwmin_1_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ipwmin_1_set`) = c("SWIGFunction", class('gparm_ipwmin_1_set'))

# Start of gparm_ipwmin_1_get

`gparm_ipwmin_1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ipwmin_1_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ipwmin_1_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ipwmin_1_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ipwmin_1_get`) = c("SWIGFunction", class('gparm_ipwmin_1_get'))

# Start of gparm_ipwmin_2_set

`gparm_ipwmin_2_set` = function(self, s_ipwmin_2)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ipwmin_2 = coerceIfNotSubclass(s_ipwmin_2, "_p_unsigned_short") 
  .Call('R_swig_gparm_ipwmin_2_set', self, s_ipwmin_2, PACKAGE='iris')
  
}

attr(`gparm_ipwmin_2_set`, 'returnType') = 'void'
attr(`gparm_ipwmin_2_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ipwmin_2_set`) = c("SWIGFunction", class('gparm_ipwmin_2_set'))

# Start of gparm_ipwmin_2_get

`gparm_ipwmin_2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ipwmin_2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ipwmin_2_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ipwmin_2_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ipwmin_2_get`) = c("SWIGFunction", class('gparm_ipwmin_2_get'))

# Start of gparm_ipwmin_3_set

`gparm_ipwmin_3_set` = function(self, s_ipwmin_3)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ipwmin_3 = coerceIfNotSubclass(s_ipwmin_3, "_p_unsigned_short") 
  .Call('R_swig_gparm_ipwmin_3_set', self, s_ipwmin_3, PACKAGE='iris')
  
}

attr(`gparm_ipwmin_3_set`, 'returnType') = 'void'
attr(`gparm_ipwmin_3_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ipwmin_3_set`) = c("SWIGFunction", class('gparm_ipwmin_3_set'))

# Start of gparm_ipwmin_3_get

`gparm_ipwmin_3_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ipwmin_3_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ipwmin_3_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ipwmin_3_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ipwmin_3_get`) = c("SWIGFunction", class('gparm_ipwmin_3_get'))

# Start of gparm_ipw_bits_set

`gparm_ipw_bits_set` = function(self, s_ipw_bits)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ipw_bits = coerceIfNotSubclass(s_ipw_bits, "_p_unsigned_short") 
  .Call('R_swig_gparm_ipw_bits_set', self, s_ipw_bits, PACKAGE='iris')
  
}

attr(`gparm_ipw_bits_set`, 'returnType') = 'void'
attr(`gparm_ipw_bits_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ipw_bits_set`) = c("SWIGFunction", class('gparm_ipw_bits_set'))

# Start of gparm_ipw_bits_get

`gparm_ipw_bits_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ipw_bits_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ipw_bits_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ipw_bits_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ipw_bits_get`) = c("SWIGFunction", class('gparm_ipw_bits_get'))

# Start of gparm_ipw_now_set

`gparm_ipw_now_set` = function(self, s_ipw_now)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ipw_now = coerceIfNotSubclass(s_ipw_now, "_p_unsigned_short") 
  .Call('R_swig_gparm_ipw_now_set', self, s_ipw_now, PACKAGE='iris')
  
}

attr(`gparm_ipw_now_set`, 'returnType') = 'void'
attr(`gparm_ipw_now_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ipw_now_set`) = c("SWIGFunction", class('gparm_ipw_now_set'))

# Start of gparm_ipw_now_get

`gparm_ipw_now_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ipw_now_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ipw_now_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ipw_now_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ipw_now_get`) = c("SWIGFunction", class('gparm_ipw_now_get'))

# Start of gparm_iprt_gen_set

`gparm_iprt_gen_set` = function(self, s_iprt_gen)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iprt_gen = coerceIfNotSubclass(s_iprt_gen, "_p_unsigned_short") 
  .Call('R_swig_gparm_iprt_gen_set', self, s_iprt_gen, PACKAGE='iris')
  
}

attr(`gparm_iprt_gen_set`, 'returnType') = 'void'
attr(`gparm_iprt_gen_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iprt_gen_set`) = c("SWIGFunction", class('gparm_iprt_gen_set'))

# Start of gparm_iprt_gen_get

`gparm_iprt_gen_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iprt_gen_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iprt_gen_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iprt_gen_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iprt_gen_get`) = c("SWIGFunction", class('gparm_iprt_gen_get'))

# Start of gparm_iprt_des_set

`gparm_iprt_des_set` = function(self, s_iprt_des)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iprt_des = coerceIfNotSubclass(s_iprt_des, "_p_unsigned_short") 
  .Call('R_swig_gparm_iprt_des_set', self, s_iprt_des, PACKAGE='iris')
  
}

attr(`gparm_iprt_des_set`, 'returnType') = 'void'
attr(`gparm_iprt_des_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iprt_des_set`) = c("SWIGFunction", class('gparm_iprt_des_set'))

# Start of gparm_iprt_des_get

`gparm_iprt_des_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iprt_des_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iprt_des_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iprt_des_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iprt_des_get`) = c("SWIGFunction", class('gparm_iprt_des_get'))

# Start of gparm_iprt_start_set

`gparm_iprt_start_set` = function(self, s_iprt_start)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iprt_start = coerceIfNotSubclass(s_iprt_start, "_p_unsigned_short") 
  .Call('R_swig_gparm_iprt_start_set', self, s_iprt_start, PACKAGE='iris')
  
}

attr(`gparm_iprt_start_set`, 'returnType') = 'void'
attr(`gparm_iprt_start_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iprt_start_set`) = c("SWIGFunction", class('gparm_iprt_start_set'))

# Start of gparm_iprt_start_get

`gparm_iprt_start_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iprt_start_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iprt_start_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iprt_start_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iprt_start_get`) = c("SWIGFunction", class('gparm_iprt_start_get'))

# Start of gparm_iprt_end_set

`gparm_iprt_end_set` = function(self, s_iprt_end)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iprt_end = coerceIfNotSubclass(s_iprt_end, "_p_unsigned_short") 
  .Call('R_swig_gparm_iprt_end_set', self, s_iprt_end, PACKAGE='iris')
  
}

attr(`gparm_iprt_end_set`, 'returnType') = 'void'
attr(`gparm_iprt_end_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iprt_end_set`) = c("SWIGFunction", class('gparm_iprt_end_set'))

# Start of gparm_iprt_end_get

`gparm_iprt_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iprt_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iprt_end_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iprt_end_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iprt_end_get`) = c("SWIGFunction", class('gparm_iprt_end_get'))

# Start of gparm_iflags_set

`gparm_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_unsigned_short") 
  .Call('R_swig_gparm_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`gparm_iflags_set`, 'returnType') = 'void'
attr(`gparm_iflags_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iflags_set`) = c("SWIGFunction", class('gparm_iflags_set'))

# Start of gparm_iflags_get

`gparm_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iflags_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iflags_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iflags_get`) = c("SWIGFunction", class('gparm_iflags_get'))

# Start of gparm_iz_slope_set

`gparm_iz_slope_set` = function(self, s_iz_slope)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iz_slope = coerceIfNotSubclass(s_iz_slope, "_p_short") 
  .Call('R_swig_gparm_iz_slope_set', self, s_iz_slope, PACKAGE='iris')
  
}

attr(`gparm_iz_slope_set`, 'returnType') = 'void'
attr(`gparm_iz_slope_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_iz_slope_set`) = c("SWIGFunction", class('gparm_iz_slope_set'))

# Start of gparm_iz_slope_get

`gparm_iz_slope_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iz_slope_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_iz_slope_get`, 'returnType') = '_p_short'
attr(`gparm_iz_slope_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iz_slope_get`) = c("SWIGFunction", class('gparm_iz_slope_get'))

# Start of gparm_izns_thr_set

`gparm_izns_thr_set` = function(self, s_izns_thr)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_izns_thr = coerceIfNotSubclass(s_izns_thr, "_p_short") 
  .Call('R_swig_gparm_izns_thr_set', self, s_izns_thr, PACKAGE='iris')
  
}

attr(`gparm_izns_thr_set`, 'returnType') = 'void'
attr(`gparm_izns_thr_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_izns_thr_set`) = c("SWIGFunction", class('gparm_izns_thr_set'))

# Start of gparm_izns_thr_get

`gparm_izns_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_izns_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_izns_thr_get`, 'returnType') = '_p_short'
attr(`gparm_izns_thr_get`, "inputTypes") = c('_p_gparm')
class(`gparm_izns_thr_get`) = c("SWIGFunction", class('gparm_izns_thr_get'))

# Start of gparm_iccr_thr_set

`gparm_iccr_thr_set` = function(self, s_iccr_thr)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iccr_thr = coerceIfNotSubclass(s_iccr_thr, "_p_short") 
  .Call('R_swig_gparm_iccr_thr_set', self, s_iccr_thr, PACKAGE='iris')
  
}

attr(`gparm_iccr_thr_set`, 'returnType') = 'void'
attr(`gparm_iccr_thr_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_iccr_thr_set`) = c("SWIGFunction", class('gparm_iccr_thr_set'))

# Start of gparm_iccr_thr_get

`gparm_iccr_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iccr_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_iccr_thr_get`, 'returnType') = '_p_short'
attr(`gparm_iccr_thr_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iccr_thr_get`) = c("SWIGFunction", class('gparm_iccr_thr_get'))

# Start of gparm_isqi_thr_set

`gparm_isqi_thr_set` = function(self, s_isqi_thr)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_isqi_thr = coerceIfNotSubclass(s_isqi_thr, "_p_unsigned_short") 
  .Call('R_swig_gparm_isqi_thr_set', self, s_isqi_thr, PACKAGE='iris')
  
}

attr(`gparm_isqi_thr_set`, 'returnType') = 'void'
attr(`gparm_isqi_thr_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_isqi_thr_set`) = c("SWIGFunction", class('gparm_isqi_thr_set'))

# Start of gparm_isqi_thr_get

`gparm_isqi_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_isqi_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_isqi_thr_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_isqi_thr_get`, "inputTypes") = c('_p_gparm')
class(`gparm_isqi_thr_get`) = c("SWIGFunction", class('gparm_isqi_thr_get'))

# Start of gparm_isig_thr_set

`gparm_isig_thr_set` = function(self, s_isig_thr)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_isig_thr = coerceIfNotSubclass(s_isig_thr, "_p_short") 
  .Call('R_swig_gparm_isig_thr_set', self, s_isig_thr, PACKAGE='iris')
  
}

attr(`gparm_isig_thr_set`, 'returnType') = 'void'
attr(`gparm_isig_thr_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_isig_thr_set`) = c("SWIGFunction", class('gparm_isig_thr_set'))

# Start of gparm_isig_thr_get

`gparm_isig_thr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_isig_thr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_isig_thr_get`, 'returnType') = '_p_short'
attr(`gparm_isig_thr_get`, "inputTypes") = c('_p_gparm')
class(`gparm_isig_thr_get`) = c("SWIGFunction", class('gparm_isig_thr_get'))

# Start of gparm_iz_calib_set

`gparm_iz_calib_set` = function(self, s_iz_calib)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iz_calib = coerceIfNotSubclass(s_iz_calib, "_p_short") 
  .Call('R_swig_gparm_iz_calib_set', self, s_iz_calib, PACKAGE='iris')
  
}

attr(`gparm_iz_calib_set`, 'returnType') = 'void'
attr(`gparm_iz_calib_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_iz_calib_set`) = c("SWIGFunction", class('gparm_iz_calib_set'))

# Start of gparm_iz_calib_get

`gparm_iz_calib_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iz_calib_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_iz_calib_get`, 'returnType') = '_p_short'
attr(`gparm_iz_calib_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iz_calib_get`) = c("SWIGFunction", class('gparm_iz_calib_get'))

# Start of gparm_iqi_now_set

`gparm_iqi_now_set` = function(self, s_iqi_now)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iqi_now = coerceIfNotSubclass(s_iqi_now, "_p_unsigned_short") 
  .Call('R_swig_gparm_iqi_now_set', self, s_iqi_now, PACKAGE='iris')
  
}

attr(`gparm_iqi_now_set`, 'returnType') = 'void'
attr(`gparm_iqi_now_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iqi_now_set`) = c("SWIGFunction", class('gparm_iqi_now_set'))

# Start of gparm_iqi_now_get

`gparm_iqi_now_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iqi_now_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iqi_now_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iqi_now_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iqi_now_get`) = c("SWIGFunction", class('gparm_iqi_now_get'))

# Start of gparm_iz_now_set

`gparm_iz_now_set` = function(self, s_iz_now)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iz_now = coerceIfNotSubclass(s_iz_now, "_p_unsigned_short") 
  .Call('R_swig_gparm_iz_now_set', self, s_iz_now, PACKAGE='iris')
  
}

attr(`gparm_iz_now_set`, 'returnType') = 'void'
attr(`gparm_iz_now_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iz_now_set`) = c("SWIGFunction", class('gparm_iz_now_set'))

# Start of gparm_iz_now_get

`gparm_iz_now_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iz_now_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iz_now_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iz_now_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iz_now_get`) = c("SWIGFunction", class('gparm_iz_now_get'))

# Start of gparm_ibin_avg_set

`gparm_ibin_avg_set` = function(self, s_ibin_avg)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_ibin_avg = coerceIfNotSubclass(s_ibin_avg, "_p_unsigned_short") 
  .Call('R_swig_gparm_ibin_avg_set', self, s_ibin_avg, PACKAGE='iris')
  
}

attr(`gparm_ibin_avg_set`, 'returnType') = 'void'
attr(`gparm_ibin_avg_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_ibin_avg_set`) = c("SWIGFunction", class('gparm_ibin_avg_set'))

# Start of gparm_ibin_avg_get

`gparm_ibin_avg_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_ibin_avg_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_ibin_avg_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_ibin_avg_get`, "inputTypes") = c('_p_gparm')
class(`gparm_ibin_avg_get`) = c("SWIGFunction", class('gparm_ibin_avg_get'))

# Start of gparm_idiag_c_set

`gparm_idiag_c_set` = function(self, s_idiag_c)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_idiag_c = coerceIfNotSubclass(s_idiag_c, "_p_unsigned_short") 
  .Call('R_swig_gparm_idiag_c_set', self, s_idiag_c, PACKAGE='iris')
  
}

attr(`gparm_idiag_c_set`, 'returnType') = 'void'
attr(`gparm_idiag_c_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_idiag_c_set`) = c("SWIGFunction", class('gparm_idiag_c_set'))

# Start of gparm_idiag_c_get

`gparm_idiag_c_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_idiag_c_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_idiag_c_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_idiag_c_get`, "inputTypes") = c('_p_gparm')
class(`gparm_idiag_c_get`) = c("SWIGFunction", class('gparm_idiag_c_get'))

# Start of gparm_idiag_d_set

`gparm_idiag_d_set` = function(self, s_idiag_d)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_idiag_d = coerceIfNotSubclass(s_idiag_d, "_p_unsigned_short") 
  .Call('R_swig_gparm_idiag_d_set', self, s_idiag_d, PACKAGE='iris')
  
}

attr(`gparm_idiag_d_set`, 'returnType') = 'void'
attr(`gparm_idiag_d_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_idiag_d_set`) = c("SWIGFunction", class('gparm_idiag_d_set'))

# Start of gparm_idiag_d_get

`gparm_idiag_d_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_idiag_d_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_idiag_d_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_idiag_d_get`, "inputTypes") = c('_p_gparm')
class(`gparm_idiag_d_get`) = c("SWIGFunction", class('gparm_idiag_d_get'))

# Start of gparm_iproc_hdr0_set

`gparm_iproc_hdr0_set` = function(self, s_iproc_hdr0)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iproc_hdr0 = coerceIfNotSubclass(s_iproc_hdr0, "_p_unsigned_short") 
  .Call('R_swig_gparm_iproc_hdr0_set', self, s_iproc_hdr0, PACKAGE='iris')
  
}

attr(`gparm_iproc_hdr0_set`, 'returnType') = 'void'
attr(`gparm_iproc_hdr0_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iproc_hdr0_set`) = c("SWIGFunction", class('gparm_iproc_hdr0_set'))

# Start of gparm_iproc_hdr0_get

`gparm_iproc_hdr0_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iproc_hdr0_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iproc_hdr0_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iproc_hdr0_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iproc_hdr0_get`) = c("SWIGFunction", class('gparm_iproc_hdr0_get'))

# Start of gparm_isq_lo_set

`gparm_isq_lo_set` = function(self, s_isq_lo)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_isq_lo = coerceIfNotSubclass(s_isq_lo, "_p_unsigned_short") 
  .Call('R_swig_gparm_isq_lo_set', self, s_isq_lo, PACKAGE='iris')
  
}

attr(`gparm_isq_lo_set`, 'returnType') = 'void'
attr(`gparm_isq_lo_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_isq_lo_set`) = c("SWIGFunction", class('gparm_isq_lo_set'))

# Start of gparm_isq_lo_get

`gparm_isq_lo_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_isq_lo_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_isq_lo_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_isq_lo_get`, "inputTypes") = c('_p_gparm')
class(`gparm_isq_lo_get`) = c("SWIGFunction", class('gparm_isq_lo_get'))

# Start of gparm_isq_hi_set

`gparm_isq_hi_set` = function(self, s_isq_hi)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_isq_hi = coerceIfNotSubclass(s_isq_hi, "_p_short") 
  .Call('R_swig_gparm_isq_hi_set', self, s_isq_hi, PACKAGE='iris')
  
}

attr(`gparm_isq_hi_set`, 'returnType') = 'void'
attr(`gparm_isq_hi_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_isq_hi_set`) = c("SWIGFunction", class('gparm_isq_hi_set'))

# Start of gparm_isq_hi_get

`gparm_isq_hi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_isq_hi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_isq_hi_get`, 'returnType') = '_p_short'
attr(`gparm_isq_hi_get`, "inputTypes") = c('_p_gparm')
class(`gparm_isq_hi_get`) = c("SWIGFunction", class('gparm_isq_hi_get'))

# Start of gparm_qsq_lo_set

`gparm_qsq_lo_set` = function(self, s_qsq_lo)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_qsq_lo = coerceIfNotSubclass(s_qsq_lo, "_p_unsigned_short") 
  .Call('R_swig_gparm_qsq_lo_set', self, s_qsq_lo, PACKAGE='iris')
  
}

attr(`gparm_qsq_lo_set`, 'returnType') = 'void'
attr(`gparm_qsq_lo_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_qsq_lo_set`) = c("SWIGFunction", class('gparm_qsq_lo_set'))

# Start of gparm_qsq_lo_get

`gparm_qsq_lo_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_qsq_lo_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_qsq_lo_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_qsq_lo_get`, "inputTypes") = c('_p_gparm')
class(`gparm_qsq_lo_get`) = c("SWIGFunction", class('gparm_qsq_lo_get'))

# Start of gparm_qsq_hi_set

`gparm_qsq_hi_set` = function(self, s_qsq_hi)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_qsq_hi = coerceIfNotSubclass(s_qsq_hi, "_p_short") 
  .Call('R_swig_gparm_qsq_hi_set', self, s_qsq_hi, PACKAGE='iris')
  
}

attr(`gparm_qsq_hi_set`, 'returnType') = 'void'
attr(`gparm_qsq_hi_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_qsq_hi_set`) = c("SWIGFunction", class('gparm_qsq_hi_set'))

# Start of gparm_qsq_hi_get

`gparm_qsq_hi_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_qsq_hi_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_qsq_hi_get`, 'returnType') = '_p_short'
attr(`gparm_qsq_hi_get`, "inputTypes") = c('_p_gparm')
class(`gparm_qsq_hi_get`) = c("SWIGFunction", class('gparm_qsq_hi_get'))

# Start of gparm_zlin_noise_set

`gparm_zlin_noise_set` = function(self, s_zlin_noise)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_zlin_noise = coerceIfNotSubclass(s_zlin_noise, "_p_short") 
  .Call('R_swig_gparm_zlin_noise_set', self, s_zlin_noise, PACKAGE='iris')
  
}

attr(`gparm_zlin_noise_set`, 'returnType') = 'void'
attr(`gparm_zlin_noise_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_zlin_noise_set`) = c("SWIGFunction", class('gparm_zlin_noise_set'))

# Start of gparm_zlin_noise_get

`gparm_zlin_noise_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_zlin_noise_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_zlin_noise_get`, 'returnType') = '_p_short'
attr(`gparm_zlin_noise_get`, "inputTypes") = c('_p_gparm')
class(`gparm_zlin_noise_get`) = c("SWIGFunction", class('gparm_zlin_noise_get'))

# Start of gparm_zlin_rms_set

`gparm_zlin_rms_set` = function(self, s_zlin_rms)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_zlin_rms = coerceIfNotSubclass(s_zlin_rms, "_p_short") 
  .Call('R_swig_gparm_zlin_rms_set', self, s_zlin_rms, PACKAGE='iris')
  
}

attr(`gparm_zlin_rms_set`, 'returnType') = 'void'
attr(`gparm_zlin_rms_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_zlin_rms_set`) = c("SWIGFunction", class('gparm_zlin_rms_set'))

# Start of gparm_zlin_rms_get

`gparm_zlin_rms_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_zlin_rms_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_zlin_rms_get`, 'returnType') = '_p_short'
attr(`gparm_zlin_rms_get`, "inputTypes") = c('_p_gparm')
class(`gparm_zlin_rms_get`) = c("SWIGFunction", class('gparm_zlin_rms_get'))

# Start of gparm_inse_hv_ratio_set

`gparm_inse_hv_ratio_set` = function(self, s_inse_hv_ratio)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_inse_hv_ratio = coerceIfNotSubclass(s_inse_hv_ratio, "_p_short") 
  .Call('R_swig_gparm_inse_hv_ratio_set', self, s_inse_hv_ratio, PACKAGE='iris')
  
}

attr(`gparm_inse_hv_ratio_set`, 'returnType') = 'void'
attr(`gparm_inse_hv_ratio_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_inse_hv_ratio_set`) = c("SWIGFunction", class('gparm_inse_hv_ratio_set'))

# Start of gparm_inse_hv_ratio_get

`gparm_inse_hv_ratio_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_inse_hv_ratio_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_inse_hv_ratio_get`, 'returnType') = '_p_short'
attr(`gparm_inse_hv_ratio_get`, "inputTypes") = c('_p_gparm')
class(`gparm_inse_hv_ratio_get`) = c("SWIGFunction", class('gparm_inse_hv_ratio_get'))

# Start of gparm_iafclevel_set

`gparm_iafclevel_set` = function(self, s_iafclevel)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iafclevel = coerceIfNotSubclass(s_iafclevel, "_p_short") 
  .Call('R_swig_gparm_iafclevel_set', self, s_iafclevel, PACKAGE='iris')
  
}

attr(`gparm_iafclevel_set`, 'returnType') = 'void'
attr(`gparm_iafclevel_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_iafclevel_set`) = c("SWIGFunction", class('gparm_iafclevel_set'))

# Start of gparm_iafclevel_get

`gparm_iafclevel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iafclevel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_iafclevel_get`, 'returnType') = '_p_short'
attr(`gparm_iafclevel_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iafclevel_get`) = c("SWIGFunction", class('gparm_iafclevel_get'))

# Start of gparm_intflt_set

`gparm_intflt_set` = function(self, s_intflt)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_intflt = coerceIfNotSubclass(s_intflt, "_p_unsigned_short") 
  .Call('R_swig_gparm_intflt_set', self, s_intflt, PACKAGE='iris')
  
}

attr(`gparm_intflt_set`, 'returnType') = 'void'
attr(`gparm_intflt_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_intflt_set`) = c("SWIGFunction", class('gparm_intflt_set'))

# Start of gparm_intflt_get

`gparm_intflt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_intflt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_intflt_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_intflt_get`, "inputTypes") = c('_p_gparm')
class(`gparm_intflt_get`) = c("SWIGFunction", class('gparm_intflt_get'))

# Start of gparm_intflt_p1_set

`gparm_intflt_p1_set` = function(self, s_intflt_p1)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_intflt_p1 = coerceIfNotSubclass(s_intflt_p1, "_p_short") 
  .Call('R_swig_gparm_intflt_p1_set', self, s_intflt_p1, PACKAGE='iris')
  
}

attr(`gparm_intflt_p1_set`, 'returnType') = 'void'
attr(`gparm_intflt_p1_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_intflt_p1_set`) = c("SWIGFunction", class('gparm_intflt_p1_set'))

# Start of gparm_intflt_p1_get

`gparm_intflt_p1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_intflt_p1_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_intflt_p1_get`, 'returnType') = '_p_short'
attr(`gparm_intflt_p1_get`, "inputTypes") = c('_p_gparm')
class(`gparm_intflt_p1_get`) = c("SWIGFunction", class('gparm_intflt_p1_get'))

# Start of gparm_intflt_p2_set

`gparm_intflt_p2_set` = function(self, s_intflt_p2)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_intflt_p2 = coerceIfNotSubclass(s_intflt_p2, "_p_short") 
  .Call('R_swig_gparm_intflt_p2_set', self, s_intflt_p2, PACKAGE='iris')
  
}

attr(`gparm_intflt_p2_set`, 'returnType') = 'void'
attr(`gparm_intflt_p2_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_intflt_p2_set`) = c("SWIGFunction", class('gparm_intflt_p2_set'))

# Start of gparm_intflt_p2_get

`gparm_intflt_p2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_intflt_p2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_intflt_p2_get`, 'returnType') = '_p_short'
attr(`gparm_intflt_p2_get`, "inputTypes") = c('_p_gparm')
class(`gparm_intflt_p2_get`) = c("SWIGFunction", class('gparm_intflt_p2_get'))

# Start of gparm_istat_i3_set

`gparm_istat_i3_set` = function(self, s_istat_i3)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_istat_i3 = coerceIfNotSubclass(s_istat_i3, "_p_unsigned_short") 
  .Call('R_swig_gparm_istat_i3_set', self, s_istat_i3, PACKAGE='iris')
  
}

attr(`gparm_istat_i3_set`, 'returnType') = 'void'
attr(`gparm_istat_i3_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_istat_i3_set`) = c("SWIGFunction", class('gparm_istat_i3_set'))

# Start of gparm_istat_i3_get

`gparm_istat_i3_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_istat_i3_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_istat_i3_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_istat_i3_get`, "inputTypes") = c('_p_gparm')
class(`gparm_istat_i3_get`) = c("SWIGFunction", class('gparm_istat_i3_get'))

# Start of gparm_itrigslew_set

`gparm_itrigslew_set` = function(self, s_itrigslew)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_itrigslew = coerceIfNotSubclass(s_itrigslew, "_p_short") 
  .Call('R_swig_gparm_itrigslew_set', self, s_itrigslew, PACKAGE='iris')
  
}

attr(`gparm_itrigslew_set`, 'returnType') = 'void'
attr(`gparm_itrigslew_set`, "inputTypes") = c('_p_gparm', '_p_short')
class(`gparm_itrigslew_set`) = c("SWIGFunction", class('gparm_itrigslew_set'))

# Start of gparm_itrigslew_get

`gparm_itrigslew_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_itrigslew_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`gparm_itrigslew_get`, 'returnType') = '_p_short'
attr(`gparm_itrigslew_get`, "inputTypes") = c('_p_gparm')
class(`gparm_itrigslew_get`) = c("SWIGFunction", class('gparm_itrigslew_get'))

# Start of gparm_iPolFlags_set

`gparm_iPolFlags_set` = function(self, s_iPolFlags)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iPolFlags = coerceIfNotSubclass(s_iPolFlags, "_p_unsigned_short") 
  .Call('R_swig_gparm_iPolFlags_set', self, s_iPolFlags, PACKAGE='iris')
  
}

attr(`gparm_iPolFlags_set`, 'returnType') = 'void'
attr(`gparm_iPolFlags_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iPolFlags_set`) = c("SWIGFunction", class('gparm_iPolFlags_set'))

# Start of gparm_iPolFlags_get

`gparm_iPolFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iPolFlags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iPolFlags_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iPolFlags_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iPolFlags_get`) = c("SWIGFunction", class('gparm_iPolFlags_get'))

# Start of gparm_iMaskSpacingCM_set

`gparm_iMaskSpacingCM_set` = function(self, s_iMaskSpacingCM)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_iMaskSpacingCM = coerceIfNotSubclass(s_iMaskSpacingCM, "_p_unsigned_short") 
  .Call('R_swig_gparm_iMaskSpacingCM_set', self, s_iMaskSpacingCM, PACKAGE='iris')
  
}

attr(`gparm_iMaskSpacingCM_set`, 'returnType') = 'void'
attr(`gparm_iMaskSpacingCM_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_iMaskSpacingCM_set`) = c("SWIGFunction", class('gparm_iMaskSpacingCM_set'))

# Start of gparm_iMaskSpacingCM_get

`gparm_iMaskSpacingCM_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_iMaskSpacingCM_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_iMaskSpacingCM_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_iMaskSpacingCM_get`, "inputTypes") = c('_p_gparm')
class(`gparm_iMaskSpacingCM_get`) = c("SWIGFunction", class('gparm_iMaskSpacingCM_get'))

# Start of gparm_istat_i4_set

`gparm_istat_i4_set` = function(self, s_istat_i4)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_istat_i4 = coerceIfNotSubclass(s_istat_i4, "_p_unsigned_short") 
  .Call('R_swig_gparm_istat_i4_set', self, s_istat_i4, PACKAGE='iris')
  
}

attr(`gparm_istat_i4_set`, 'returnType') = 'void'
attr(`gparm_istat_i4_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_istat_i4_set`) = c("SWIGFunction", class('gparm_istat_i4_set'))

# Start of gparm_istat_i4_get

`gparm_istat_i4_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_istat_i4_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_istat_i4_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_istat_i4_get`, "inputTypes") = c('_p_gparm')
class(`gparm_istat_i4_get`) = c("SWIGFunction", class('gparm_istat_i4_get'))

# Start of gparm_unused_word_60_set

`gparm_unused_word_60_set` = function(self, s_unused_word_60)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_unused_word_60 = coerceIfNotSubclass(s_unused_word_60, "_p_unsigned_short") 
  .Call('R_swig_gparm_unused_word_60_set', self, s_unused_word_60, PACKAGE='iris')
  
}

attr(`gparm_unused_word_60_set`, 'returnType') = 'void'
attr(`gparm_unused_word_60_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_unused_word_60_set`) = c("SWIGFunction", class('gparm_unused_word_60_set'))

# Start of gparm_unused_word_60_get

`gparm_unused_word_60_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_unused_word_60_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_unused_word_60_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_unused_word_60_get`, "inputTypes") = c('_p_gparm')
class(`gparm_unused_word_60_get`) = c("SWIGFunction", class('gparm_unused_word_60_get'))

# Start of gparm_unused_word_61_set

`gparm_unused_word_61_set` = function(self, s_unused_word_61)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_unused_word_61 = coerceIfNotSubclass(s_unused_word_61, "_p_unsigned_short") 
  .Call('R_swig_gparm_unused_word_61_set', self, s_unused_word_61, PACKAGE='iris')
  
}

attr(`gparm_unused_word_61_set`, 'returnType') = 'void'
attr(`gparm_unused_word_61_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_unused_word_61_set`) = c("SWIGFunction", class('gparm_unused_word_61_set'))

# Start of gparm_unused_word_61_get

`gparm_unused_word_61_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_unused_word_61_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_unused_word_61_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_unused_word_61_get`, "inputTypes") = c('_p_gparm')
class(`gparm_unused_word_61_get`) = c("SWIGFunction", class('gparm_unused_word_61_get'))

# Start of gparm_unused_word_62_set

`gparm_unused_word_62_set` = function(self, s_unused_word_62)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_unused_word_62 = coerceIfNotSubclass(s_unused_word_62, "_p_unsigned_short") 
  .Call('R_swig_gparm_unused_word_62_set', self, s_unused_word_62, PACKAGE='iris')
  
}

attr(`gparm_unused_word_62_set`, 'returnType') = 'void'
attr(`gparm_unused_word_62_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_unused_word_62_set`) = c("SWIGFunction", class('gparm_unused_word_62_set'))

# Start of gparm_unused_word_62_get

`gparm_unused_word_62_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_unused_word_62_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_unused_word_62_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_unused_word_62_get`, "inputTypes") = c('_p_gparm')
class(`gparm_unused_word_62_get`) = c("SWIGFunction", class('gparm_unused_word_62_get'))

# Start of gparm_unused_word_63_set

`gparm_unused_word_63_set` = function(self, s_unused_word_63)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_unused_word_63 = coerceIfNotSubclass(s_unused_word_63, "_p_unsigned_short") 
  .Call('R_swig_gparm_unused_word_63_set', self, s_unused_word_63, PACKAGE='iris')
  
}

attr(`gparm_unused_word_63_set`, 'returnType') = 'void'
attr(`gparm_unused_word_63_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_unused_word_63_set`) = c("SWIGFunction", class('gparm_unused_word_63_set'))

# Start of gparm_unused_word_63_get

`gparm_unused_word_63_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_unused_word_63_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_unused_word_63_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_unused_word_63_get`, "inputTypes") = c('_p_gparm')
class(`gparm_unused_word_63_get`) = c("SWIGFunction", class('gparm_unused_word_63_get'))

# Start of gparm_unused_word_64_set

`gparm_unused_word_64_set` = function(self, s_unused_word_64)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  s_unused_word_64 = coerceIfNotSubclass(s_unused_word_64, "_p_unsigned_short") 
  .Call('R_swig_gparm_unused_word_64_set', self, s_unused_word_64, PACKAGE='iris')
  
}

attr(`gparm_unused_word_64_set`, 'returnType') = 'void'
attr(`gparm_unused_word_64_set`, "inputTypes") = c('_p_gparm', '_p_unsigned_short')
class(`gparm_unused_word_64_set`) = c("SWIGFunction", class('gparm_unused_word_64_set'))

# Start of gparm_unused_word_64_get

`gparm_unused_word_64_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  ans = .Call('R_swig_gparm_unused_word_64_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`gparm_unused_word_64_get`, 'returnType') = '_p_unsigned_short'
attr(`gparm_unused_word_64_get`, "inputTypes") = c('_p_gparm')
class(`gparm_unused_word_64_get`) = c("SWIGFunction", class('gparm_unused_word_64_get'))

# Start of new_gparm

`gparm` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_gparm', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_gparm"
  
  ans
  
}

attr(`gparm`, 'returnType') = '_p_gparm'
class(`gparm`) = c("SWIGFunction", class('gparm'))

# Start of delete_gparm

`delete_gparm` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_gparm") 
  .Call('R_swig_delete_gparm', self, PACKAGE='iris')
  
}

attr(`delete_gparm`, 'returnType') = 'void'
attr(`delete_gparm`, "inputTypes") = c('_p_gparm')
class(`delete_gparm`) = c("SWIGFunction", class('delete_gparm'))

# Start of accessor method for gparm
setMethod('$', '_p_gparm', function(x, name)

{
  accessorFuns = list('irev_ser' = gparm_irev_ser_get, 'ibin_out_num' = gparm_ibin_out_num_get, 'iprt_mes' = gparm_iprt_mes_get, 'itaga' = gparm_itaga_get, 'itagb' = gparm_itagb_get, 'log_nse' = gparm_log_nse_get, 'i_nse_' = gparm_i_nse__get, 'q_nse_' = gparm_q_nse__get, 'istat_l' = gparm_istat_l_get, 'istat_i' = gparm_istat_i_get, 'idiag_a' = gparm_idiag_a_get, 'idiag_b' = gparm_idiag_b_get, 'isamp' = gparm_isamp_get, 'itrg_cnt_a' = gparm_itrg_cnt_a_get, 'itrg_cnt_b' = gparm_itrg_cnt_b_get, 'iaqbins' = gparm_iaqbins_get, 'iprbins' = gparm_iprbins_get, 'istat_i2' = gparm_istat_i2_get, 'inse_rng' = gparm_inse_rng_get, 'inse_prt' = gparm_inse_prt_get, 'ipwmin_0' = gparm_ipwmin_0_get, 'ipwmin_1' = gparm_ipwmin_1_get, 'ipwmin_2' = gparm_ipwmin_2_get, 'ipwmin_3' = gparm_ipwmin_3_get, 'ipw_bits' = gparm_ipw_bits_get, 'ipw_now' = gparm_ipw_now_get, 'iprt_gen' = gparm_iprt_gen_get, 'iprt_des' = gparm_iprt_des_get, 'iprt_start' = gparm_iprt_start_get, 'iprt_end' = gparm_iprt_end_get, 'iflags' = gparm_iflags_get, 'iz_slope' = gparm_iz_slope_get, 'izns_thr' = gparm_izns_thr_get, 'iccr_thr' = gparm_iccr_thr_get, 'isqi_thr' = gparm_isqi_thr_get, 'isig_thr' = gparm_isig_thr_get, 'iz_calib' = gparm_iz_calib_get, 'iqi_now' = gparm_iqi_now_get, 'iz_now' = gparm_iz_now_get, 'ibin_avg' = gparm_ibin_avg_get, 'idiag_c' = gparm_idiag_c_get, 'idiag_d' = gparm_idiag_d_get, 'iproc_hdr0' = gparm_iproc_hdr0_get, 'isq_lo' = gparm_isq_lo_get, 'isq_hi' = gparm_isq_hi_get, 'qsq_lo' = gparm_qsq_lo_get, 'qsq_hi' = gparm_qsq_hi_get, 'zlin_noise' = gparm_zlin_noise_get, 'zlin_rms' = gparm_zlin_rms_get, 'inse_hv_ratio' = gparm_inse_hv_ratio_get, 'iafclevel' = gparm_iafclevel_get, 'intflt' = gparm_intflt_get, 'intflt_p1' = gparm_intflt_p1_get, 'intflt_p2' = gparm_intflt_p2_get, 'istat_i3' = gparm_istat_i3_get, 'itrigslew' = gparm_itrigslew_get, 'iPolFlags' = gparm_iPolFlags_get, 'iMaskSpacingCM' = gparm_iMaskSpacingCM_get, 'istat_i4' = gparm_istat_i4_get, 'unused_word_60' = gparm_unused_word_60_get, 'unused_word_61' = gparm_unused_word_61_get, 'unused_word_62' = gparm_unused_word_62_get, 'unused_word_63' = gparm_unused_word_63_get, 'unused_word_64' = gparm_unused_word_64_get)
  vaccessors = c('irev_ser', 'ibin_out_num', 'iprt_mes', 'itaga', 'itagb', 'log_nse', 'i_nse_', 'q_nse_', 'istat_l', 'istat_i', 'idiag_a', 'idiag_b', 'isamp', 'itrg_cnt_a', 'itrg_cnt_b', 'iaqbins', 'iprbins', 'istat_i2', 'inse_rng', 'inse_prt', 'ipwmin_0', 'ipwmin_1', 'ipwmin_2', 'ipwmin_3', 'ipw_bits', 'ipw_now', 'iprt_gen', 'iprt_des', 'iprt_start', 'iprt_end', 'iflags', 'iz_slope', 'izns_thr', 'iccr_thr', 'isqi_thr', 'isig_thr', 'iz_calib', 'iqi_now', 'iz_now', 'ibin_avg', 'idiag_c', 'idiag_d', 'iproc_hdr0', 'isq_lo', 'isq_hi', 'qsq_lo', 'qsq_hi', 'zlin_noise', 'zlin_rms', 'inse_hv_ratio', 'iafclevel', 'intflt', 'intflt_p1', 'intflt_p2', 'istat_i3', 'itrigslew', 'iPolFlags', 'iMaskSpacingCM', 'istat_i4', 'unused_word_60', 'unused_word_61', 'unused_word_62', 'unused_word_63', 'unused_word_64')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for gparm
# Start of accessor method for gparm
setMethod('$<-', '_p_gparm', function(x, name, value)

{
  accessorFuns = list('irev_ser' = gparm_irev_ser_set, 'ibin_out_num' = gparm_ibin_out_num_set, 'iprt_mes' = gparm_iprt_mes_set, 'itaga' = gparm_itaga_set, 'itagb' = gparm_itagb_set, 'log_nse' = gparm_log_nse_set, 'i_nse_' = gparm_i_nse__set, 'q_nse_' = gparm_q_nse__set, 'istat_l' = gparm_istat_l_set, 'istat_i' = gparm_istat_i_set, 'idiag_a' = gparm_idiag_a_set, 'idiag_b' = gparm_idiag_b_set, 'isamp' = gparm_isamp_set, 'itrg_cnt_a' = gparm_itrg_cnt_a_set, 'itrg_cnt_b' = gparm_itrg_cnt_b_set, 'iaqbins' = gparm_iaqbins_set, 'iprbins' = gparm_iprbins_set, 'istat_i2' = gparm_istat_i2_set, 'inse_rng' = gparm_inse_rng_set, 'inse_prt' = gparm_inse_prt_set, 'ipwmin_0' = gparm_ipwmin_0_set, 'ipwmin_1' = gparm_ipwmin_1_set, 'ipwmin_2' = gparm_ipwmin_2_set, 'ipwmin_3' = gparm_ipwmin_3_set, 'ipw_bits' = gparm_ipw_bits_set, 'ipw_now' = gparm_ipw_now_set, 'iprt_gen' = gparm_iprt_gen_set, 'iprt_des' = gparm_iprt_des_set, 'iprt_start' = gparm_iprt_start_set, 'iprt_end' = gparm_iprt_end_set, 'iflags' = gparm_iflags_set, 'iz_slope' = gparm_iz_slope_set, 'izns_thr' = gparm_izns_thr_set, 'iccr_thr' = gparm_iccr_thr_set, 'isqi_thr' = gparm_isqi_thr_set, 'isig_thr' = gparm_isig_thr_set, 'iz_calib' = gparm_iz_calib_set, 'iqi_now' = gparm_iqi_now_set, 'iz_now' = gparm_iz_now_set, 'ibin_avg' = gparm_ibin_avg_set, 'idiag_c' = gparm_idiag_c_set, 'idiag_d' = gparm_idiag_d_set, 'iproc_hdr0' = gparm_iproc_hdr0_set, 'isq_lo' = gparm_isq_lo_set, 'isq_hi' = gparm_isq_hi_set, 'qsq_lo' = gparm_qsq_lo_set, 'qsq_hi' = gparm_qsq_hi_set, 'zlin_noise' = gparm_zlin_noise_set, 'zlin_rms' = gparm_zlin_rms_set, 'inse_hv_ratio' = gparm_inse_hv_ratio_set, 'iafclevel' = gparm_iafclevel_set, 'intflt' = gparm_intflt_set, 'intflt_p1' = gparm_intflt_p1_set, 'intflt_p2' = gparm_intflt_p2_set, 'istat_i3' = gparm_istat_i3_set, 'itrigslew' = gparm_itrigslew_set, 'iPolFlags' = gparm_iPolFlags_set, 'iMaskSpacingCM' = gparm_iMaskSpacingCM_set, 'istat_i4' = gparm_istat_i4_set, 'unused_word_60' = gparm_unused_word_60_set, 'unused_word_61' = gparm_unused_word_61_set, 'unused_word_62' = gparm_unused_word_62_set, 'unused_word_63' = gparm_unused_word_63_set, 'unused_word_64' = gparm_unused_word_64_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_gparm', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('irev_ser' = gparm_irev_ser_set, 'ibin_out_num' = gparm_ibin_out_num_set, 'iprt_mes' = gparm_iprt_mes_set, 'itaga' = gparm_itaga_set, 'itagb' = gparm_itagb_set, 'log_nse' = gparm_log_nse_set, 'i_nse_' = gparm_i_nse__set, 'q_nse_' = gparm_q_nse__set, 'istat_l' = gparm_istat_l_set, 'istat_i' = gparm_istat_i_set, 'idiag_a' = gparm_idiag_a_set, 'idiag_b' = gparm_idiag_b_set, 'isamp' = gparm_isamp_set, 'itrg_cnt_a' = gparm_itrg_cnt_a_set, 'itrg_cnt_b' = gparm_itrg_cnt_b_set, 'iaqbins' = gparm_iaqbins_set, 'iprbins' = gparm_iprbins_set, 'istat_i2' = gparm_istat_i2_set, 'inse_rng' = gparm_inse_rng_set, 'inse_prt' = gparm_inse_prt_set, 'ipwmin_0' = gparm_ipwmin_0_set, 'ipwmin_1' = gparm_ipwmin_1_set, 'ipwmin_2' = gparm_ipwmin_2_set, 'ipwmin_3' = gparm_ipwmin_3_set, 'ipw_bits' = gparm_ipw_bits_set, 'ipw_now' = gparm_ipw_now_set, 'iprt_gen' = gparm_iprt_gen_set, 'iprt_des' = gparm_iprt_des_set, 'iprt_start' = gparm_iprt_start_set, 'iprt_end' = gparm_iprt_end_set, 'iflags' = gparm_iflags_set, 'iz_slope' = gparm_iz_slope_set, 'izns_thr' = gparm_izns_thr_set, 'iccr_thr' = gparm_iccr_thr_set, 'isqi_thr' = gparm_isqi_thr_set, 'isig_thr' = gparm_isig_thr_set, 'iz_calib' = gparm_iz_calib_set, 'iqi_now' = gparm_iqi_now_set, 'iz_now' = gparm_iz_now_set, 'ibin_avg' = gparm_ibin_avg_set, 'idiag_c' = gparm_idiag_c_set, 'idiag_d' = gparm_idiag_d_set, 'iproc_hdr0' = gparm_iproc_hdr0_set, 'isq_lo' = gparm_isq_lo_set, 'isq_hi' = gparm_isq_hi_set, 'qsq_lo' = gparm_qsq_lo_set, 'qsq_hi' = gparm_qsq_hi_set, 'zlin_noise' = gparm_zlin_noise_set, 'zlin_rms' = gparm_zlin_rms_set, 'inse_hv_ratio' = gparm_inse_hv_ratio_set, 'iafclevel' = gparm_iafclevel_set, 'intflt' = gparm_intflt_set, 'intflt_p1' = gparm_intflt_p1_set, 'intflt_p2' = gparm_intflt_p2_set, 'istat_i3' = gparm_istat_i3_set, 'itrigslew' = gparm_itrigslew_set, 'iPolFlags' = gparm_iPolFlags_set, 'iMaskSpacingCM' = gparm_iMaskSpacingCM_set, 'istat_i4' = gparm_istat_i4_set, 'unused_word_60' = gparm_unused_word_60_set, 'unused_word_61' = gparm_unused_word_61_set, 'unused_word_62' = gparm_unused_word_62_set, 'unused_word_63' = gparm_unused_word_63_set, 'unused_word_64' = gparm_unused_word_64_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for gparm
setMethod('delete', '_p_gparm', function(obj) {delete_gparm(obj)})
# Start definition of copy functions & methods for gparm
CopyToR_gparm = function(value, obj = new("gparm"))
{
  obj
}



CopyToC_gparm = function(value, obj)
{
  obj
}



# Start definition of copy methods for gparm
setMethod('copyToR', '_p_gparm', CopyToR_gparm)
setMethod('copyToC', 'gparm', CopyToC_gparm)

# End definition of copy methods for gparm
# End definition of copy functions & methods for gparm
# Start of ingest_configuration_sfile_set

`ingest_configuration_sfile_set` = function(self, s_sfile)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_sfile))
  assert(all(sapply(s_sfile, class) == "_p_char"))     
  
  
#  assert(length(s_sfile) >= 80)
  
  .Call('R_swig_ingest_configuration_sfile_set', self, s_sfile, PACKAGE='iris')
  
}

attr(`ingest_configuration_sfile_set`, 'returnType') = 'void'
attr(`ingest_configuration_sfile_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_sfile_set`) = c("SWIGFunction", class('ingest_configuration_sfile_set'))

# Start of ingest_configuration_sfile_get

`ingest_configuration_sfile_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_sfile_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_sfile_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_sfile_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_sfile_get`) = c("SWIGFunction", class('ingest_configuration_sfile_get'))

# Start of ingest_configuration_idfnum_set

`ingest_configuration_idfnum_set` = function(self, s_idfnum)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_idfnum = coerceIfNotSubclass(s_idfnum, "_p_short") 
  .Call('R_swig_ingest_configuration_idfnum_set', self, s_idfnum, PACKAGE='iris')
  
}

attr(`ingest_configuration_idfnum_set`, 'returnType') = 'void'
attr(`ingest_configuration_idfnum_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_idfnum_set`) = c("SWIGFunction", class('ingest_configuration_idfnum_set'))

# Start of ingest_configuration_idfnum_get

`ingest_configuration_idfnum_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_idfnum_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_idfnum_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_idfnum_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_idfnum_get`) = c("SWIGFunction", class('ingest_configuration_idfnum_get'))

# Start of ingest_configuration_isweeps_done_set

`ingest_configuration_isweeps_done_set` = function(self, s_isweeps_done)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_isweeps_done = coerceIfNotSubclass(s_isweeps_done, "_p_short") 
  .Call('R_swig_ingest_configuration_isweeps_done_set', self, s_isweeps_done, PACKAGE='iris')
  
}

attr(`ingest_configuration_isweeps_done_set`, 'returnType') = 'void'
attr(`ingest_configuration_isweeps_done_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_isweeps_done_set`) = c("SWIGFunction", class('ingest_configuration_isweeps_done_set'))

# Start of ingest_configuration_isweeps_done_get

`ingest_configuration_isweeps_done_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_isweeps_done_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_isweeps_done_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_isweeps_done_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_isweeps_done_get`) = c("SWIGFunction", class('ingest_configuration_isweeps_done_get'))

# Start of ingest_configuration_idfsize_set

`ingest_configuration_idfsize_set` = function(self, s_idfsize)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_idfsize = as.integer(s_idfsize) 
  
  if(length(s_idfsize) > 1) {
    Rf_warning("using only the first element of s_idfsize")
  }
  
  .Call('R_swig_ingest_configuration_idfsize_set', self, s_idfsize, PACKAGE='iris')
  
}

attr(`ingest_configuration_idfsize_set`, 'returnType') = 'void'
attr(`ingest_configuration_idfsize_set`, "inputTypes") = c('_p_ingest_configuration', 'numeric')
class(`ingest_configuration_idfsize_set`) = c("SWIGFunction", class('ingest_configuration_idfsize_set'))

# Start of ingest_configuration_idfsize_get

`ingest_configuration_idfsize_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  .Call('R_swig_ingest_configuration_idfsize_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ingest_configuration_idfsize_get`, 'returnType') = 'numeric'
attr(`ingest_configuration_idfsize_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_idfsize_get`) = c("SWIGFunction", class('ingest_configuration_idfsize_get'))

# Start of ingest_configuration_VolumeYmds_set

`ingest_configuration_VolumeYmds_set` = function(self, s_VolumeYmds)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_VolumeYmds = coerceIfNotSubclass(s_VolumeYmds, "_p_ymds_time") 
  .Call('R_swig_ingest_configuration_VolumeYmds_set', self, s_VolumeYmds, PACKAGE='iris')
  
}

attr(`ingest_configuration_VolumeYmds_set`, 'returnType') = 'void'
attr(`ingest_configuration_VolumeYmds_set`, "inputTypes") = c('_p_ingest_configuration', '_p_ymds_time')
class(`ingest_configuration_VolumeYmds_set`) = c("SWIGFunction", class('ingest_configuration_VolumeYmds_set'))

# Start of ingest_configuration_VolumeYmds_get

`ingest_configuration_VolumeYmds_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_VolumeYmds_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`ingest_configuration_VolumeYmds_get`, 'returnType') = '_p_ymds_time'
attr(`ingest_configuration_VolumeYmds_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_VolumeYmds_get`) = c("SWIGFunction", class('ingest_configuration_VolumeYmds_get'))

# Start of ingest_configuration_ipad100x12_set

`ingest_configuration_ipad100x12_set` = function(self, s_ipad100x12)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_ipad100x12))
  assert(all(sapply(s_ipad100x12, class) == "_p_char"))     
  
  
#  assert(length(s_ipad100x12) >= 12)
  
  .Call('R_swig_ingest_configuration_ipad100x12_set', self, s_ipad100x12, PACKAGE='iris')
  
}

attr(`ingest_configuration_ipad100x12_set`, 'returnType') = 'void'
attr(`ingest_configuration_ipad100x12_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_ipad100x12_set`) = c("SWIGFunction", class('ingest_configuration_ipad100x12_set'))

# Start of ingest_configuration_ipad100x12_get

`ingest_configuration_ipad100x12_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ipad100x12_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_ipad100x12_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_ipad100x12_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ipad100x12_get`) = c("SWIGFunction", class('ingest_configuration_ipad100x12_get'))

# Start of ingest_configuration_ib_rayhed_set

`ingest_configuration_ib_rayhed_set` = function(self, s_ib_rayhed)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ib_rayhed = coerceIfNotSubclass(s_ib_rayhed, "_p_short") 
  .Call('R_swig_ingest_configuration_ib_rayhed_set', self, s_ib_rayhed, PACKAGE='iris')
  
}

attr(`ingest_configuration_ib_rayhed_set`, 'returnType') = 'void'
attr(`ingest_configuration_ib_rayhed_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_ib_rayhed_set`) = c("SWIGFunction", class('ingest_configuration_ib_rayhed_set'))

# Start of ingest_configuration_ib_rayhed_get

`ingest_configuration_ib_rayhed_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ib_rayhed_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_ib_rayhed_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_ib_rayhed_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ib_rayhed_get`) = c("SWIGFunction", class('ingest_configuration_ib_rayhed_get'))

# Start of ingest_configuration_ib_xhdr_set

`ingest_configuration_ib_xhdr_set` = function(self, s_ib_xhdr)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ib_xhdr = coerceIfNotSubclass(s_ib_xhdr, "_p_short") 
  .Call('R_swig_ingest_configuration_ib_xhdr_set', self, s_ib_xhdr, PACKAGE='iris')
  
}

attr(`ingest_configuration_ib_xhdr_set`, 'returnType') = 'void'
attr(`ingest_configuration_ib_xhdr_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_ib_xhdr_set`) = c("SWIGFunction", class('ingest_configuration_ib_xhdr_set'))

# Start of ingest_configuration_ib_xhdr_get

`ingest_configuration_ib_xhdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ib_xhdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_ib_xhdr_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_ib_xhdr_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ib_xhdr_get`) = c("SWIGFunction", class('ingest_configuration_ib_xhdr_get'))

# Start of ingest_configuration_ib_task_set

`ingest_configuration_ib_task_set` = function(self, s_ib_task)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ib_task = coerceIfNotSubclass(s_ib_task, "_p_short") 
  .Call('R_swig_ingest_configuration_ib_task_set', self, s_ib_task, PACKAGE='iris')
  
}

attr(`ingest_configuration_ib_task_set`, 'returnType') = 'void'
attr(`ingest_configuration_ib_task_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_ib_task_set`) = c("SWIGFunction", class('ingest_configuration_ib_task_set'))

# Start of ingest_configuration_ib_task_get

`ingest_configuration_ib_task_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ib_task_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_ib_task_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_ib_task_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ib_task_get`) = c("SWIGFunction", class('ingest_configuration_ib_task_get'))

# Start of ingest_configuration_iPlaybackVersion_set

`ingest_configuration_iPlaybackVersion_set` = function(self, s_iPlaybackVersion)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_iPlaybackVersion = coerceIfNotSubclass(s_iPlaybackVersion, "_p_short") 
  .Call('R_swig_ingest_configuration_iPlaybackVersion_set', self, s_iPlaybackVersion, PACKAGE='iris')
  
}

attr(`ingest_configuration_iPlaybackVersion_set`, 'returnType') = 'void'
attr(`ingest_configuration_iPlaybackVersion_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_iPlaybackVersion_set`) = c("SWIGFunction", class('ingest_configuration_iPlaybackVersion_set'))

# Start of ingest_configuration_iPlaybackVersion_get

`ingest_configuration_iPlaybackVersion_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_iPlaybackVersion_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_iPlaybackVersion_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_iPlaybackVersion_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_iPlaybackVersion_get`) = c("SWIGFunction", class('ingest_configuration_iPlaybackVersion_get'))

# Start of ingest_configuration_ipad120x4_set

`ingest_configuration_ipad120x4_set` = function(self, s_ipad120x4)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_ipad120x4))
  assert(all(sapply(s_ipad120x4, class) == "_p_char"))     
  
  
#  assert(length(s_ipad120x4) >= 4)
  
  .Call('R_swig_ingest_configuration_ipad120x4_set', self, s_ipad120x4, PACKAGE='iris')
  
}

attr(`ingest_configuration_ipad120x4_set`, 'returnType') = 'void'
attr(`ingest_configuration_ipad120x4_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_ipad120x4_set`) = c("SWIGFunction", class('ingest_configuration_ipad120x4_set'))

# Start of ingest_configuration_ipad120x4_get

`ingest_configuration_ipad120x4_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ipad120x4_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_ipad120x4_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_ipad120x4_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ipad120x4_get`) = c("SWIGFunction", class('ingest_configuration_ipad120x4_get'))

# Start of ingest_configuration_siris_version_set

`ingest_configuration_siris_version_set` = function(self, s_siris_version)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_siris_version))
  assert(all(sapply(s_siris_version, class) == "_p_char"))     
  
  
#  assert(length(s_siris_version) >= 8)
  
  .Call('R_swig_ingest_configuration_siris_version_set', self, s_siris_version, PACKAGE='iris')
  
}

attr(`ingest_configuration_siris_version_set`, 'returnType') = 'void'
attr(`ingest_configuration_siris_version_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_siris_version_set`) = c("SWIGFunction", class('ingest_configuration_siris_version_set'))

# Start of ingest_configuration_siris_version_get

`ingest_configuration_siris_version_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_siris_version_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_siris_version_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_siris_version_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_siris_version_get`) = c("SWIGFunction", class('ingest_configuration_siris_version_get'))

# Start of ingest_configuration_sHardwareName_set

`ingest_configuration_sHardwareName_set` = function(self, s_sHardwareName)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_sHardwareName))
  assert(all(sapply(s_sHardwareName, class) == "_p_char"))     
  
  
#  assert(length(s_sHardwareName) >= 16)
  
  .Call('R_swig_ingest_configuration_sHardwareName_set', self, s_sHardwareName, PACKAGE='iris')
  
}

attr(`ingest_configuration_sHardwareName_set`, 'returnType') = 'void'
attr(`ingest_configuration_sHardwareName_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_sHardwareName_set`) = c("SWIGFunction", class('ingest_configuration_sHardwareName_set'))

# Start of ingest_configuration_sHardwareName_get

`ingest_configuration_sHardwareName_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_sHardwareName_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_sHardwareName_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_sHardwareName_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_sHardwareName_get`) = c("SWIGFunction", class('ingest_configuration_sHardwareName_get'))

# Start of ingest_configuration_iLocalWest_set

`ingest_configuration_iLocalWest_set` = function(self, s_iLocalWest)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_iLocalWest = coerceIfNotSubclass(s_iLocalWest, "_p_short") 
  .Call('R_swig_ingest_configuration_iLocalWest_set', self, s_iLocalWest, PACKAGE='iris')
  
}

attr(`ingest_configuration_iLocalWest_set`, 'returnType') = 'void'
attr(`ingest_configuration_iLocalWest_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_iLocalWest_set`) = c("SWIGFunction", class('ingest_configuration_iLocalWest_set'))

# Start of ingest_configuration_iLocalWest_get

`ingest_configuration_iLocalWest_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_iLocalWest_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_iLocalWest_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_iLocalWest_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_iLocalWest_get`) = c("SWIGFunction", class('ingest_configuration_iLocalWest_get'))

# Start of ingest_configuration_sSitename_set

`ingest_configuration_sSitename_set` = function(self, s_sSitename)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_sSitename))
  assert(all(sapply(s_sSitename, class) == "_p_char"))     
  
  
#  assert(length(s_sSitename) >= 16)
  
  .Call('R_swig_ingest_configuration_sSitename_set', self, s_sSitename, PACKAGE='iris')
  
}

attr(`ingest_configuration_sSitename_set`, 'returnType') = 'void'
attr(`ingest_configuration_sSitename_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_sSitename_set`) = c("SWIGFunction", class('ingest_configuration_sSitename_set'))

# Start of ingest_configuration_sSitename_get

`ingest_configuration_sSitename_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_sSitename_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_sSitename_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_sSitename_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_sSitename_get`) = c("SWIGFunction", class('ingest_configuration_sSitename_get'))

# Start of ingest_configuration_iMinutesWest_set

`ingest_configuration_iMinutesWest_set` = function(self, s_iMinutesWest)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_iMinutesWest = coerceIfNotSubclass(s_iMinutesWest, "_p_short") 
  .Call('R_swig_ingest_configuration_iMinutesWest_set', self, s_iMinutesWest, PACKAGE='iris')
  
}

attr(`ingest_configuration_iMinutesWest_set`, 'returnType') = 'void'
attr(`ingest_configuration_iMinutesWest_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_iMinutesWest_set`) = c("SWIGFunction", class('ingest_configuration_iMinutesWest_set'))

# Start of ingest_configuration_iMinutesWest_get

`ingest_configuration_iMinutesWest_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_iMinutesWest_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_iMinutesWest_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_iMinutesWest_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_iMinutesWest_get`) = c("SWIGFunction", class('ingest_configuration_iMinutesWest_get'))

# Start of ingest_configuration_ilat_set

`ingest_configuration_ilat_set` = function(self, s_ilat)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ilat = as.numeric(s_ilat) 
  
  assert(length(s_ilat) == 1 && s_ilat >= 0, "All values must be non-negative")
  
  .Call('R_swig_ingest_configuration_ilat_set', self, s_ilat, PACKAGE='iris')
  
}

attr(`ingest_configuration_ilat_set`, 'returnType') = 'void'
attr(`ingest_configuration_ilat_set`, "inputTypes") = c('_p_ingest_configuration', 'numeric')
class(`ingest_configuration_ilat_set`) = c("SWIGFunction", class('ingest_configuration_ilat_set'))

# Start of ingest_configuration_ilat_get

`ingest_configuration_ilat_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  .Call('R_swig_ingest_configuration_ilat_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ingest_configuration_ilat_get`, 'returnType') = 'numeric'
attr(`ingest_configuration_ilat_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ilat_get`) = c("SWIGFunction", class('ingest_configuration_ilat_get'))

# Start of ingest_configuration_ilon_set

`ingest_configuration_ilon_set` = function(self, s_ilon)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ilon = as.numeric(s_ilon) 
  
  assert(length(s_ilon) == 1 && s_ilon >= 0, "All values must be non-negative")
  
  .Call('R_swig_ingest_configuration_ilon_set', self, s_ilon, PACKAGE='iris')
  
}

attr(`ingest_configuration_ilon_set`, 'returnType') = 'void'
attr(`ingest_configuration_ilon_set`, "inputTypes") = c('_p_ingest_configuration', 'numeric')
class(`ingest_configuration_ilon_set`) = c("SWIGFunction", class('ingest_configuration_ilon_set'))

# Start of ingest_configuration_ilon_get

`ingest_configuration_ilon_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  .Call('R_swig_ingest_configuration_ilon_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ingest_configuration_ilon_get`, 'returnType') = 'numeric'
attr(`ingest_configuration_ilon_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ilon_get`) = c("SWIGFunction", class('ingest_configuration_ilon_get'))

# Start of ingest_configuration_ignd_hgt_set

`ingest_configuration_ignd_hgt_set` = function(self, s_ignd_hgt)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ignd_hgt = coerceIfNotSubclass(s_ignd_hgt, "_p_short") 
  .Call('R_swig_ingest_configuration_ignd_hgt_set', self, s_ignd_hgt, PACKAGE='iris')
  
}

attr(`ingest_configuration_ignd_hgt_set`, 'returnType') = 'void'
attr(`ingest_configuration_ignd_hgt_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_ignd_hgt_set`) = c("SWIGFunction", class('ingest_configuration_ignd_hgt_set'))

# Start of ingest_configuration_ignd_hgt_get

`ingest_configuration_ignd_hgt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ignd_hgt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_ignd_hgt_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_ignd_hgt_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ignd_hgt_get`) = c("SWIGFunction", class('ingest_configuration_ignd_hgt_get'))

# Start of ingest_configuration_irad_hgt_set

`ingest_configuration_irad_hgt_set` = function(self, s_irad_hgt)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_irad_hgt = coerceIfNotSubclass(s_irad_hgt, "_p_short") 
  .Call('R_swig_ingest_configuration_irad_hgt_set', self, s_irad_hgt, PACKAGE='iris')
  
}

attr(`ingest_configuration_irad_hgt_set`, 'returnType') = 'void'
attr(`ingest_configuration_irad_hgt_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_irad_hgt_set`) = c("SWIGFunction", class('ingest_configuration_irad_hgt_set'))

# Start of ingest_configuration_irad_hgt_get

`ingest_configuration_irad_hgt_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_irad_hgt_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_irad_hgt_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_irad_hgt_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_irad_hgt_get`) = c("SWIGFunction", class('ingest_configuration_irad_hgt_get'))

# Start of ingest_configuration_inrev_set

`ingest_configuration_inrev_set` = function(self, s_inrev)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_inrev = coerceIfNotSubclass(s_inrev, "_p_short") 
  .Call('R_swig_ingest_configuration_inrev_set', self, s_inrev, PACKAGE='iris')
  
}

attr(`ingest_configuration_inrev_set`, 'returnType') = 'void'
attr(`ingest_configuration_inrev_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_inrev_set`) = c("SWIGFunction", class('ingest_configuration_inrev_set'))

# Start of ingest_configuration_inrev_get

`ingest_configuration_inrev_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_inrev_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_inrev_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_inrev_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_inrev_get`) = c("SWIGFunction", class('ingest_configuration_inrev_get'))

# Start of ingest_configuration_isndx_set

`ingest_configuration_isndx_set` = function(self, s_isndx)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_isndx = coerceIfNotSubclass(s_isndx, "_p_short") 
  .Call('R_swig_ingest_configuration_isndx_set', self, s_isndx, PACKAGE='iris')
  
}

attr(`ingest_configuration_isndx_set`, 'returnType') = 'void'
attr(`ingest_configuration_isndx_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_isndx_set`) = c("SWIGFunction", class('ingest_configuration_isndx_set'))

# Start of ingest_configuration_isndx_get

`ingest_configuration_isndx_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_isndx_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_isndx_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_isndx_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_isndx_get`) = c("SWIGFunction", class('ingest_configuration_isndx_get'))

# Start of ingest_configuration_irtotl_set

`ingest_configuration_irtotl_set` = function(self, s_irtotl)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_irtotl = coerceIfNotSubclass(s_irtotl, "_p_short") 
  .Call('R_swig_ingest_configuration_irtotl_set', self, s_irtotl, PACKAGE='iris')
  
}

attr(`ingest_configuration_irtotl_set`, 'returnType') = 'void'
attr(`ingest_configuration_irtotl_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_irtotl_set`) = c("SWIGFunction", class('ingest_configuration_irtotl_set'))

# Start of ingest_configuration_irtotl_get

`ingest_configuration_irtotl_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_irtotl_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_irtotl_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_irtotl_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_irtotl_get`) = c("SWIGFunction", class('ingest_configuration_irtotl_get'))

# Start of ingest_configuration_ib_gparm_set

`ingest_configuration_ib_gparm_set` = function(self, s_ib_gparm)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ib_gparm = coerceIfNotSubclass(s_ib_gparm, "_p_short") 
  .Call('R_swig_ingest_configuration_ib_gparm_set', self, s_ib_gparm, PACKAGE='iris')
  
}

attr(`ingest_configuration_ib_gparm_set`, 'returnType') = 'void'
attr(`ingest_configuration_ib_gparm_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_ib_gparm_set`) = c("SWIGFunction", class('ingest_configuration_ib_gparm_set'))

# Start of ingest_configuration_ib_gparm_get

`ingest_configuration_ib_gparm_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ib_gparm_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_ib_gparm_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_ib_gparm_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ib_gparm_get`) = c("SWIGFunction", class('ingest_configuration_ib_gparm_get'))

# Start of ingest_configuration_ialtitude_set

`ingest_configuration_ialtitude_set` = function(self, s_ialtitude)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_ialtitude = as.integer(s_ialtitude) 
  
  if(length(s_ialtitude) > 1) {
    Rf_warning("using only the first element of s_ialtitude")
  }
  
  .Call('R_swig_ingest_configuration_ialtitude_set', self, s_ialtitude, PACKAGE='iris')
  
}

attr(`ingest_configuration_ialtitude_set`, 'returnType') = 'void'
attr(`ingest_configuration_ialtitude_set`, "inputTypes") = c('_p_ingest_configuration', 'numeric')
class(`ingest_configuration_ialtitude_set`) = c("SWIGFunction", class('ingest_configuration_ialtitude_set'))

# Start of ingest_configuration_ialtitude_get

`ingest_configuration_ialtitude_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  .Call('R_swig_ingest_configuration_ialtitude_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ingest_configuration_ialtitude_get`, 'returnType') = 'numeric'
attr(`ingest_configuration_ialtitude_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ialtitude_get`) = c("SWIGFunction", class('ingest_configuration_ialtitude_get'))

# Start of ingest_configuration_inu_vel_set

`ingest_configuration_inu_vel_set` = function(self, s_inu_vel)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_inu_vel = as.integer(s_inu_vel) 
  
#  assert(length(s_inu_vel) >= 3)
  
  .Call('R_swig_ingest_configuration_inu_vel_set', self, s_inu_vel, PACKAGE='iris')
  
}

attr(`ingest_configuration_inu_vel_set`, 'returnType') = 'void'
attr(`ingest_configuration_inu_vel_set`, "inputTypes") = c('_p_ingest_configuration', '_p_int')
class(`ingest_configuration_inu_vel_set`) = c("SWIGFunction", class('ingest_configuration_inu_vel_set'))

# Start of ingest_configuration_inu_vel_get

`ingest_configuration_inu_vel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_inu_vel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_int"
  
  ans
  
}

attr(`ingest_configuration_inu_vel_get`, 'returnType') = '_p_int'
attr(`ingest_configuration_inu_vel_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_inu_vel_get`) = c("SWIGFunction", class('ingest_configuration_inu_vel_get'))

# Start of ingest_configuration_inu_offset_set

`ingest_configuration_inu_offset_set` = function(self, s_inu_offset)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_inu_offset = as.integer(s_inu_offset) 
  
#  assert(length(s_inu_offset) >= 3)
  
  .Call('R_swig_ingest_configuration_inu_offset_set', self, s_inu_offset, PACKAGE='iris')
  
}

attr(`ingest_configuration_inu_offset_set`, 'returnType') = 'void'
attr(`ingest_configuration_inu_offset_set`, "inputTypes") = c('_p_ingest_configuration', '_p_int')
class(`ingest_configuration_inu_offset_set`) = c("SWIGFunction", class('ingest_configuration_inu_offset_set'))

# Start of ingest_configuration_inu_offset_get

`ingest_configuration_inu_offset_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_inu_offset_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_int"
  
  ans
  
}

attr(`ingest_configuration_inu_offset_get`, 'returnType') = '_p_int'
attr(`ingest_configuration_inu_offset_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_inu_offset_get`) = c("SWIGFunction", class('ingest_configuration_inu_offset_get'))

# Start of ingest_configuration_iFaultBits_set

`ingest_configuration_iFaultBits_set` = function(self, s_iFaultBits)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_iFaultBits = as.numeric(s_iFaultBits) 
  
  assert(length(s_iFaultBits) == 1 && s_iFaultBits >= 0, "All values must be non-negative")
  
  .Call('R_swig_ingest_configuration_iFaultBits_set', self, s_iFaultBits, PACKAGE='iris')
  
}

attr(`ingest_configuration_iFaultBits_set`, 'returnType') = 'void'
attr(`ingest_configuration_iFaultBits_set`, "inputTypes") = c('_p_ingest_configuration', 'numeric')
class(`ingest_configuration_iFaultBits_set`) = c("SWIGFunction", class('ingest_configuration_iFaultBits_set'))

# Start of ingest_configuration_iFaultBits_get

`ingest_configuration_iFaultBits_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  .Call('R_swig_ingest_configuration_iFaultBits_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ingest_configuration_iFaultBits_get`, 'returnType') = 'numeric'
attr(`ingest_configuration_iFaultBits_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_iFaultBits_get`) = c("SWIGFunction", class('ingest_configuration_iFaultBits_get'))

# Start of ingest_configuration_iMeltingHeight_set

`ingest_configuration_iMeltingHeight_set` = function(self, s_iMeltingHeight)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_iMeltingHeight = coerceIfNotSubclass(s_iMeltingHeight, "_p_short") 
  .Call('R_swig_ingest_configuration_iMeltingHeight_set', self, s_iMeltingHeight, PACKAGE='iris')
  
}

attr(`ingest_configuration_iMeltingHeight_set`, 'returnType') = 'void'
attr(`ingest_configuration_iMeltingHeight_set`, "inputTypes") = c('_p_ingest_configuration', '_p_short')
class(`ingest_configuration_iMeltingHeight_set`) = c("SWIGFunction", class('ingest_configuration_iMeltingHeight_set'))

# Start of ingest_configuration_iMeltingHeight_get

`ingest_configuration_iMeltingHeight_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_iMeltingHeight_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_configuration_iMeltingHeight_get`, 'returnType') = '_p_short'
attr(`ingest_configuration_iMeltingHeight_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_iMeltingHeight_get`) = c("SWIGFunction", class('ingest_configuration_iMeltingHeight_get'))

# Start of ingest_configuration_ipad222x2_set

`ingest_configuration_ipad222x2_set` = function(self, s_ipad222x2)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_ipad222x2))
  assert(all(sapply(s_ipad222x2, class) == "_p_char"))     
  
  
#  assert(length(s_ipad222x2) >= 2)
  
  .Call('R_swig_ingest_configuration_ipad222x2_set', self, s_ipad222x2, PACKAGE='iris')
  
}

attr(`ingest_configuration_ipad222x2_set`, 'returnType') = 'void'
attr(`ingest_configuration_ipad222x2_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_ipad222x2_set`) = c("SWIGFunction", class('ingest_configuration_ipad222x2_set'))

# Start of ingest_configuration_ipad222x2_get

`ingest_configuration_ipad222x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ipad222x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_ipad222x2_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_ipad222x2_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ipad222x2_get`) = c("SWIGFunction", class('ingest_configuration_ipad222x2_get'))

# Start of ingest_configuration_sLocalTZName_set

`ingest_configuration_sLocalTZName_set` = function(self, s_sLocalTZName)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_sLocalTZName))
  assert(all(sapply(s_sLocalTZName, class) == "_p_char"))     
  
  
#  assert(length(s_sLocalTZName) >= 8)
  
  .Call('R_swig_ingest_configuration_sLocalTZName_set', self, s_sLocalTZName, PACKAGE='iris')
  
}

attr(`ingest_configuration_sLocalTZName_set`, 'returnType') = 'void'
attr(`ingest_configuration_sLocalTZName_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_sLocalTZName_set`) = c("SWIGFunction", class('ingest_configuration_sLocalTZName_set'))

# Start of ingest_configuration_sLocalTZName_get

`ingest_configuration_sLocalTZName_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_sLocalTZName_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_sLocalTZName_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_sLocalTZName_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_sLocalTZName_get`) = c("SWIGFunction", class('ingest_configuration_sLocalTZName_get'))

# Start of ingest_configuration_iIcfFlags_set

`ingest_configuration_iIcfFlags_set` = function(self, s_iIcfFlags)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  s_iIcfFlags = as.numeric(s_iIcfFlags) 
  
  assert(length(s_iIcfFlags) == 1 && s_iIcfFlags >= 0, "All values must be non-negative")
  
  .Call('R_swig_ingest_configuration_iIcfFlags_set', self, s_iIcfFlags, PACKAGE='iris')
  
}

attr(`ingest_configuration_iIcfFlags_set`, 'returnType') = 'void'
attr(`ingest_configuration_iIcfFlags_set`, "inputTypes") = c('_p_ingest_configuration', 'numeric')
class(`ingest_configuration_iIcfFlags_set`) = c("SWIGFunction", class('ingest_configuration_iIcfFlags_set'))

# Start of ingest_configuration_iIcfFlags_get

`ingest_configuration_iIcfFlags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  .Call('R_swig_ingest_configuration_iIcfFlags_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`ingest_configuration_iIcfFlags_get`, 'returnType') = 'numeric'
attr(`ingest_configuration_iIcfFlags_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_iIcfFlags_get`) = c("SWIGFunction", class('ingest_configuration_iIcfFlags_get'))

# Start of ingest_configuration_sDpolappConfigName_set

`ingest_configuration_sDpolappConfigName_set` = function(self, s_sDpolappConfigName)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_sDpolappConfigName))
  assert(all(sapply(s_sDpolappConfigName, class) == "_p_char"))     
  
  
#  assert(length(s_sDpolappConfigName) >= (16))
  
  .Call('R_swig_ingest_configuration_sDpolappConfigName_set', self, s_sDpolappConfigName, PACKAGE='iris')
  
}

attr(`ingest_configuration_sDpolappConfigName_set`, 'returnType') = 'void'
attr(`ingest_configuration_sDpolappConfigName_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_sDpolappConfigName_set`) = c("SWIGFunction", class('ingest_configuration_sDpolappConfigName_set'))

# Start of ingest_configuration_sDpolappConfigName_get

`ingest_configuration_sDpolappConfigName_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_sDpolappConfigName_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_sDpolappConfigName_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_sDpolappConfigName_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_sDpolappConfigName_get`) = c("SWIGFunction", class('ingest_configuration_sDpolappConfigName_get'))

# Start of ingest_configuration_ipad_end_set

`ingest_configuration_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= 228)
  
  .Call('R_swig_ingest_configuration_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`ingest_configuration_ipad_end_set`, 'returnType') = 'void'
attr(`ingest_configuration_ipad_end_set`, "inputTypes") = c('_p_ingest_configuration', '_p_char')
class(`ingest_configuration_ipad_end_set`) = c("SWIGFunction", class('ingest_configuration_ipad_end_set'))

# Start of ingest_configuration_ipad_end_get

`ingest_configuration_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  ans = .Call('R_swig_ingest_configuration_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_configuration_ipad_end_get`, 'returnType') = '_p_char'
attr(`ingest_configuration_ipad_end_get`, "inputTypes") = c('_p_ingest_configuration')
class(`ingest_configuration_ipad_end_get`) = c("SWIGFunction", class('ingest_configuration_ipad_end_get'))

# Start of new_ingest_configuration

`ingest_configuration` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ingest_configuration', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ingest_configuration"
  
  ans
  
}

attr(`ingest_configuration`, 'returnType') = '_p_ingest_configuration'
class(`ingest_configuration`) = c("SWIGFunction", class('ingest_configuration'))

# Start of delete_ingest_configuration

`delete_ingest_configuration` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ingest_configuration") 
  .Call('R_swig_delete_ingest_configuration', self, PACKAGE='iris')
  
}

attr(`delete_ingest_configuration`, 'returnType') = 'void'
attr(`delete_ingest_configuration`, "inputTypes") = c('_p_ingest_configuration')
class(`delete_ingest_configuration`) = c("SWIGFunction", class('delete_ingest_configuration'))

# Start of accessor method for ingest_configuration
setMethod('$', '_p_ingest_configuration', function(x, name)

{
  accessorFuns = list('sfile' = ingest_configuration_sfile_get, 'idfnum' = ingest_configuration_idfnum_get, 'isweeps_done' = ingest_configuration_isweeps_done_get, 'idfsize' = ingest_configuration_idfsize_get, 'VolumeYmds' = ingest_configuration_VolumeYmds_get, 'ipad100x12' = ingest_configuration_ipad100x12_get, 'ib_rayhed' = ingest_configuration_ib_rayhed_get, 'ib_xhdr' = ingest_configuration_ib_xhdr_get, 'ib_task' = ingest_configuration_ib_task_get, 'iPlaybackVersion' = ingest_configuration_iPlaybackVersion_get, 'ipad120x4' = ingest_configuration_ipad120x4_get, 'siris_version' = ingest_configuration_siris_version_get, 'sHardwareName' = ingest_configuration_sHardwareName_get, 'iLocalWest' = ingest_configuration_iLocalWest_get, 'sSitename' = ingest_configuration_sSitename_get, 'iMinutesWest' = ingest_configuration_iMinutesWest_get, 'ilat' = ingest_configuration_ilat_get, 'ilon' = ingest_configuration_ilon_get, 'ignd_hgt' = ingest_configuration_ignd_hgt_get, 'irad_hgt' = ingest_configuration_irad_hgt_get, 'inrev' = ingest_configuration_inrev_get, 'isndx' = ingest_configuration_isndx_get, 'irtotl' = ingest_configuration_irtotl_get, 'ib_gparm' = ingest_configuration_ib_gparm_get, 'ialtitude' = ingest_configuration_ialtitude_get, 'inu_vel' = ingest_configuration_inu_vel_get, 'inu_offset' = ingest_configuration_inu_offset_get, 'iFaultBits' = ingest_configuration_iFaultBits_get, 'iMeltingHeight' = ingest_configuration_iMeltingHeight_get, 'ipad222x2' = ingest_configuration_ipad222x2_get, 'sLocalTZName' = ingest_configuration_sLocalTZName_get, 'iIcfFlags' = ingest_configuration_iIcfFlags_get, 'sDpolappConfigName' = ingest_configuration_sDpolappConfigName_get, 'ipad_end' = ingest_configuration_ipad_end_get)
  vaccessors = c('sfile', 'idfnum', 'isweeps_done', 'idfsize', 'VolumeYmds', 'ipad100x12', 'ib_rayhed', 'ib_xhdr', 'ib_task', 'iPlaybackVersion', 'ipad120x4', 'siris_version', 'sHardwareName', 'iLocalWest', 'sSitename', 'iMinutesWest', 'ilat', 'ilon', 'ignd_hgt', 'irad_hgt', 'inrev', 'isndx', 'irtotl', 'ib_gparm', 'ialtitude', 'inu_vel', 'inu_offset', 'iFaultBits', 'iMeltingHeight', 'ipad222x2', 'sLocalTZName', 'iIcfFlags', 'sDpolappConfigName', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ingest_configuration
# Start of accessor method for ingest_configuration
setMethod('$<-', '_p_ingest_configuration', function(x, name, value)

{
  accessorFuns = list('sfile' = ingest_configuration_sfile_set, 'idfnum' = ingest_configuration_idfnum_set, 'isweeps_done' = ingest_configuration_isweeps_done_set, 'idfsize' = ingest_configuration_idfsize_set, 'VolumeYmds' = ingest_configuration_VolumeYmds_set, 'ipad100x12' = ingest_configuration_ipad100x12_set, 'ib_rayhed' = ingest_configuration_ib_rayhed_set, 'ib_xhdr' = ingest_configuration_ib_xhdr_set, 'ib_task' = ingest_configuration_ib_task_set, 'iPlaybackVersion' = ingest_configuration_iPlaybackVersion_set, 'ipad120x4' = ingest_configuration_ipad120x4_set, 'siris_version' = ingest_configuration_siris_version_set, 'sHardwareName' = ingest_configuration_sHardwareName_set, 'iLocalWest' = ingest_configuration_iLocalWest_set, 'sSitename' = ingest_configuration_sSitename_set, 'iMinutesWest' = ingest_configuration_iMinutesWest_set, 'ilat' = ingest_configuration_ilat_set, 'ilon' = ingest_configuration_ilon_set, 'ignd_hgt' = ingest_configuration_ignd_hgt_set, 'irad_hgt' = ingest_configuration_irad_hgt_set, 'inrev' = ingest_configuration_inrev_set, 'isndx' = ingest_configuration_isndx_set, 'irtotl' = ingest_configuration_irtotl_set, 'ib_gparm' = ingest_configuration_ib_gparm_set, 'ialtitude' = ingest_configuration_ialtitude_set, 'inu_vel' = ingest_configuration_inu_vel_set, 'inu_offset' = ingest_configuration_inu_offset_set, 'iFaultBits' = ingest_configuration_iFaultBits_set, 'iMeltingHeight' = ingest_configuration_iMeltingHeight_set, 'ipad222x2' = ingest_configuration_ipad222x2_set, 'sLocalTZName' = ingest_configuration_sLocalTZName_set, 'iIcfFlags' = ingest_configuration_iIcfFlags_set, 'sDpolappConfigName' = ingest_configuration_sDpolappConfigName_set, 'ipad_end' = ingest_configuration_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ingest_configuration', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('sfile' = ingest_configuration_sfile_set, 'idfnum' = ingest_configuration_idfnum_set, 'isweeps_done' = ingest_configuration_isweeps_done_set, 'idfsize' = ingest_configuration_idfsize_set, 'VolumeYmds' = ingest_configuration_VolumeYmds_set, 'ipad100x12' = ingest_configuration_ipad100x12_set, 'ib_rayhed' = ingest_configuration_ib_rayhed_set, 'ib_xhdr' = ingest_configuration_ib_xhdr_set, 'ib_task' = ingest_configuration_ib_task_set, 'iPlaybackVersion' = ingest_configuration_iPlaybackVersion_set, 'ipad120x4' = ingest_configuration_ipad120x4_set, 'siris_version' = ingest_configuration_siris_version_set, 'sHardwareName' = ingest_configuration_sHardwareName_set, 'iLocalWest' = ingest_configuration_iLocalWest_set, 'sSitename' = ingest_configuration_sSitename_set, 'iMinutesWest' = ingest_configuration_iMinutesWest_set, 'ilat' = ingest_configuration_ilat_set, 'ilon' = ingest_configuration_ilon_set, 'ignd_hgt' = ingest_configuration_ignd_hgt_set, 'irad_hgt' = ingest_configuration_irad_hgt_set, 'inrev' = ingest_configuration_inrev_set, 'isndx' = ingest_configuration_isndx_set, 'irtotl' = ingest_configuration_irtotl_set, 'ib_gparm' = ingest_configuration_ib_gparm_set, 'ialtitude' = ingest_configuration_ialtitude_set, 'inu_vel' = ingest_configuration_inu_vel_set, 'inu_offset' = ingest_configuration_inu_offset_set, 'iFaultBits' = ingest_configuration_iFaultBits_set, 'iMeltingHeight' = ingest_configuration_iMeltingHeight_set, 'ipad222x2' = ingest_configuration_ipad222x2_set, 'sLocalTZName' = ingest_configuration_sLocalTZName_set, 'iIcfFlags' = ingest_configuration_iIcfFlags_set, 'sDpolappConfigName' = ingest_configuration_sDpolappConfigName_set, 'ipad_end' = ingest_configuration_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ingest_configuration
setMethod('delete', '_p_ingest_configuration', function(obj) {delete_ingest_configuration(obj)})
# Start definition of copy functions & methods for ingest_configuration
CopyToR_ingest_configuration = function(value, obj = new("ingest_configuration"))
{
  obj@sfile = value$sfile
  obj@idfsize = value$idfsize
  obj@ipad100x12 = value$ipad100x12
  obj@ipad120x4 = value$ipad120x4
  obj@siris_version = value$siris_version
  obj@sHardwareName = value$sHardwareName
  obj@sSitename = value$sSitename
  obj@ilat = value$ilat
  obj@ilon = value$ilon
  obj@ialtitude = value$ialtitude
  obj@inu_vel = value$inu_vel
  obj@inu_offset = value$inu_offset
  obj@iFaultBits = value$iFaultBits
  obj@ipad222x2 = value$ipad222x2
  obj@sLocalTZName = value$sLocalTZName
  obj@iIcfFlags = value$iIcfFlags
  obj@sDpolappConfigName = value$sDpolappConfigName
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_ingest_configuration = function(value, obj)
{
  obj$sfile = value@sfile
  obj$idfsize = value@idfsize
  obj$ipad100x12 = value@ipad100x12
  obj$ipad120x4 = value@ipad120x4
  obj$siris_version = value@siris_version
  obj$sHardwareName = value@sHardwareName
  obj$sSitename = value@sSitename
  obj$ilat = value@ilat
  obj$ilon = value@ilon
  obj$ialtitude = value@ialtitude
  obj$inu_vel = value@inu_vel
  obj$inu_offset = value@inu_offset
  obj$iFaultBits = value@iFaultBits
  obj$ipad222x2 = value@ipad222x2
  obj$sLocalTZName = value@sLocalTZName
  obj$iIcfFlags = value@iIcfFlags
  obj$sDpolappConfigName = value@sDpolappConfigName
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for ingest_configuration
setMethod('copyToR', '_p_ingest_configuration', CopyToR_ingest_configuration)
setMethod('copyToC', 'ingest_configuration', CopyToC_ingest_configuration)

# End definition of copy methods for ingest_configuration
# End definition of copy functions & methods for ingest_configuration
# Start of ingest_header_hdr_set

`ingest_header_hdr_set` = function(self, s_hdr)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  s_hdr = coerceIfNotSubclass(s_hdr, "_p_structure_header") 
  .Call('R_swig_ingest_header_hdr_set', self, s_hdr, PACKAGE='iris')
  
}

attr(`ingest_header_hdr_set`, 'returnType') = 'void'
attr(`ingest_header_hdr_set`, "inputTypes") = c('_p_ingest_header', '_p_structure_header')
class(`ingest_header_hdr_set`) = c("SWIGFunction", class('ingest_header_hdr_set'))

# Start of ingest_header_hdr_get

`ingest_header_hdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  ans = .Call('R_swig_ingest_header_hdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_structure_header"
  
  ans
  
}

attr(`ingest_header_hdr_get`, 'returnType') = '_p_structure_header'
attr(`ingest_header_hdr_get`, "inputTypes") = c('_p_ingest_header')
class(`ingest_header_hdr_get`) = c("SWIGFunction", class('ingest_header_hdr_get'))

# Start of ingest_header_icf_set

`ingest_header_icf_set` = function(self, s_icf)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  s_icf = coerceIfNotSubclass(s_icf, "_p_ingest_configuration") 
  .Call('R_swig_ingest_header_icf_set', self, s_icf, PACKAGE='iris')
  
}

attr(`ingest_header_icf_set`, 'returnType') = 'void'
attr(`ingest_header_icf_set`, "inputTypes") = c('_p_ingest_header', '_p_ingest_configuration')
class(`ingest_header_icf_set`) = c("SWIGFunction", class('ingest_header_icf_set'))

# Start of ingest_header_icf_get

`ingest_header_icf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  ans = .Call('R_swig_ingest_header_icf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ingest_configuration"
  
  ans
  
}

attr(`ingest_header_icf_get`, 'returnType') = '_p_ingest_configuration'
attr(`ingest_header_icf_get`, "inputTypes") = c('_p_ingest_header')
class(`ingest_header_icf_get`) = c("SWIGFunction", class('ingest_header_icf_get'))

# Start of ingest_header_tcf_set

`ingest_header_tcf_set` = function(self, s_tcf)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  s_tcf = coerceIfNotSubclass(s_tcf, "_p_task_configuration") 
  .Call('R_swig_ingest_header_tcf_set', self, s_tcf, PACKAGE='iris')
  
}

attr(`ingest_header_tcf_set`, 'returnType') = 'void'
attr(`ingest_header_tcf_set`, "inputTypes") = c('_p_ingest_header', '_p_task_configuration')
class(`ingest_header_tcf_set`) = c("SWIGFunction", class('ingest_header_tcf_set'))

# Start of ingest_header_tcf_get

`ingest_header_tcf_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  ans = .Call('R_swig_ingest_header_tcf_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_task_configuration"
  
  ans
  
}

attr(`ingest_header_tcf_get`, 'returnType') = '_p_task_configuration'
attr(`ingest_header_tcf_get`, "inputTypes") = c('_p_ingest_header')
class(`ingest_header_tcf_get`) = c("SWIGFunction", class('ingest_header_tcf_get'))

# Start of ingest_header_ipad_3104x732_set

`ingest_header_ipad_3104x732_set` = function(self, s_ipad_3104x732)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  
  if(is.list(s_ipad_3104x732))
  assert(all(sapply(s_ipad_3104x732, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_3104x732) >= 732)
  
  .Call('R_swig_ingest_header_ipad_3104x732_set', self, s_ipad_3104x732, PACKAGE='iris')
  
}

attr(`ingest_header_ipad_3104x732_set`, 'returnType') = 'void'
attr(`ingest_header_ipad_3104x732_set`, "inputTypes") = c('_p_ingest_header', '_p_char')
class(`ingest_header_ipad_3104x732_set`) = c("SWIGFunction", class('ingest_header_ipad_3104x732_set'))

# Start of ingest_header_ipad_3104x732_get

`ingest_header_ipad_3104x732_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  ans = .Call('R_swig_ingest_header_ipad_3104x732_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_header_ipad_3104x732_get`, 'returnType') = '_p_char'
attr(`ingest_header_ipad_3104x732_get`, "inputTypes") = c('_p_ingest_header')
class(`ingest_header_ipad_3104x732_get`) = c("SWIGFunction", class('ingest_header_ipad_3104x732_get'))

# Start of ingest_header_GParm_set

`ingest_header_GParm_set` = function(self, s_GParm)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  s_GParm = coerceIfNotSubclass(s_GParm, "_p_gparm") 
  .Call('R_swig_ingest_header_GParm_set', self, s_GParm, PACKAGE='iris')
  
}

attr(`ingest_header_GParm_set`, 'returnType') = 'void'
attr(`ingest_header_GParm_set`, "inputTypes") = c('_p_ingest_header', '_p_gparm')
class(`ingest_header_GParm_set`) = c("SWIGFunction", class('ingest_header_GParm_set'))

# Start of ingest_header_GParm_get

`ingest_header_GParm_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  ans = .Call('R_swig_ingest_header_GParm_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_gparm"
  
  ans
  
}

attr(`ingest_header_GParm_get`, 'returnType') = '_p_gparm'
attr(`ingest_header_GParm_get`, "inputTypes") = c('_p_ingest_header')
class(`ingest_header_GParm_get`) = c("SWIGFunction", class('ingest_header_GParm_get'))

# Start of ingest_header_ipad_end_set

`ingest_header_ipad_end_set` = function(self, s_ipad_end)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  
  if(is.list(s_ipad_end))
  assert(all(sapply(s_ipad_end, class) == "_p_char"))     
  
  
#  assert(length(s_ipad_end) >= 920)
  
  .Call('R_swig_ingest_header_ipad_end_set', self, s_ipad_end, PACKAGE='iris')
  
}

attr(`ingest_header_ipad_end_set`, 'returnType') = 'void'
attr(`ingest_header_ipad_end_set`, "inputTypes") = c('_p_ingest_header', '_p_char')
class(`ingest_header_ipad_end_set`) = c("SWIGFunction", class('ingest_header_ipad_end_set'))

# Start of ingest_header_ipad_end_get

`ingest_header_ipad_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  ans = .Call('R_swig_ingest_header_ipad_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_header_ipad_end_get`, 'returnType') = '_p_char'
attr(`ingest_header_ipad_end_get`, "inputTypes") = c('_p_ingest_header')
class(`ingest_header_ipad_end_get`) = c("SWIGFunction", class('ingest_header_ipad_end_get'))

# Start of new_ingest_header

`ingest_header` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ingest_header', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ingest_header"
  
  ans
  
}

attr(`ingest_header`, 'returnType') = '_p_ingest_header'
class(`ingest_header`) = c("SWIGFunction", class('ingest_header'))

# Start of delete_ingest_header

`delete_ingest_header` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ingest_header") 
  .Call('R_swig_delete_ingest_header', self, PACKAGE='iris')
  
}

attr(`delete_ingest_header`, 'returnType') = 'void'
attr(`delete_ingest_header`, "inputTypes") = c('_p_ingest_header')
class(`delete_ingest_header`) = c("SWIGFunction", class('delete_ingest_header'))

# Start of accessor method for ingest_header
setMethod('$', '_p_ingest_header', function(x, name)

{
  accessorFuns = list('hdr' = ingest_header_hdr_get, 'icf' = ingest_header_icf_get, 'tcf' = ingest_header_tcf_get, 'ipad_3104x732' = ingest_header_ipad_3104x732_get, 'GParm' = ingest_header_GParm_get, 'ipad_end' = ingest_header_ipad_end_get)
  vaccessors = c('hdr', 'icf', 'tcf', 'ipad_3104x732', 'GParm', 'ipad_end')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ingest_header
# Start of accessor method for ingest_header
setMethod('$<-', '_p_ingest_header', function(x, name, value)

{
  accessorFuns = list('hdr' = ingest_header_hdr_set, 'icf' = ingest_header_icf_set, 'tcf' = ingest_header_tcf_set, 'ipad_3104x732' = ingest_header_ipad_3104x732_set, 'GParm' = ingest_header_GParm_set, 'ipad_end' = ingest_header_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ingest_header', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('hdr' = ingest_header_hdr_set, 'icf' = ingest_header_icf_set, 'tcf' = ingest_header_tcf_set, 'ipad_3104x732' = ingest_header_ipad_3104x732_set, 'GParm' = ingest_header_GParm_set, 'ipad_end' = ingest_header_ipad_end_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ingest_header
setMethod('delete', '_p_ingest_header', function(obj) {delete_ingest_header(obj)})
# Start definition of copy functions & methods for ingest_header
CopyToR_ingest_header = function(value, obj = new("ingest_header"))
{
  obj@ipad_3104x732 = value$ipad_3104x732
  obj@ipad_end = value$ipad_end
  obj
}



CopyToC_ingest_header = function(value, obj)
{
  obj$ipad_3104x732 = value@ipad_3104x732
  obj$ipad_end = value@ipad_end
  obj
}



# Start definition of copy methods for ingest_header
setMethod('copyToR', '_p_ingest_header', CopyToR_ingest_header)
setMethod('copyToC', 'ingest_header', CopyToC_ingest_header)

# End definition of copy methods for ingest_header
# End definition of copy functions & methods for ingest_header
# Start of ingest_data_header_hdr_set

`ingest_data_header_hdr_set` = function(self, s_hdr)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_hdr = coerceIfNotSubclass(s_hdr, "_p_structure_header") 
  .Call('R_swig_ingest_data_header_hdr_set', self, s_hdr, PACKAGE='iris')
  
}

attr(`ingest_data_header_hdr_set`, 'returnType') = 'void'
attr(`ingest_data_header_hdr_set`, "inputTypes") = c('_p_ingest_data_header', '_p_structure_header')
class(`ingest_data_header_hdr_set`) = c("SWIGFunction", class('ingest_data_header_hdr_set'))

# Start of ingest_data_header_hdr_get

`ingest_data_header_hdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_hdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_structure_header"
  
  ans
  
}

attr(`ingest_data_header_hdr_get`, 'returnType') = '_p_structure_header'
attr(`ingest_data_header_hdr_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_hdr_get`) = c("SWIGFunction", class('ingest_data_header_hdr_get'))

# Start of ingest_data_header_time_set

`ingest_data_header_time_set` = function(self, s_time)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_time = coerceIfNotSubclass(s_time, "_p_ymds_time") 
  .Call('R_swig_ingest_data_header_time_set', self, s_time, PACKAGE='iris')
  
}

attr(`ingest_data_header_time_set`, 'returnType') = 'void'
attr(`ingest_data_header_time_set`, "inputTypes") = c('_p_ingest_data_header', '_p_ymds_time')
class(`ingest_data_header_time_set`) = c("SWIGFunction", class('ingest_data_header_time_set'))

# Start of ingest_data_header_time_get

`ingest_data_header_time_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_time_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ymds_time"
  
  ans
  
}

attr(`ingest_data_header_time_get`, 'returnType') = '_p_ymds_time'
attr(`ingest_data_header_time_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_time_get`) = c("SWIGFunction", class('ingest_data_header_time_get'))

# Start of ingest_data_header_isweep_set

`ingest_data_header_isweep_set` = function(self, s_isweep)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_isweep = coerceIfNotSubclass(s_isweep, "_p_short") 
  .Call('R_swig_ingest_data_header_isweep_set', self, s_isweep, PACKAGE='iris')
  
}

attr(`ingest_data_header_isweep_set`, 'returnType') = 'void'
attr(`ingest_data_header_isweep_set`, "inputTypes") = c('_p_ingest_data_header', '_p_short')
class(`ingest_data_header_isweep_set`) = c("SWIGFunction", class('ingest_data_header_isweep_set'))

# Start of ingest_data_header_isweep_get

`ingest_data_header_isweep_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_isweep_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_data_header_isweep_get`, 'returnType') = '_p_short'
attr(`ingest_data_header_isweep_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_isweep_get`) = c("SWIGFunction", class('ingest_data_header_isweep_get'))

# Start of ingest_data_header_inrev_set

`ingest_data_header_inrev_set` = function(self, s_inrev)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_inrev = coerceIfNotSubclass(s_inrev, "_p_short") 
  .Call('R_swig_ingest_data_header_inrev_set', self, s_inrev, PACKAGE='iris')
  
}

attr(`ingest_data_header_inrev_set`, 'returnType') = 'void'
attr(`ingest_data_header_inrev_set`, "inputTypes") = c('_p_ingest_data_header', '_p_short')
class(`ingest_data_header_inrev_set`) = c("SWIGFunction", class('ingest_data_header_inrev_set'))

# Start of ingest_data_header_inrev_get

`ingest_data_header_inrev_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_inrev_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_data_header_inrev_get`, 'returnType') = '_p_short'
attr(`ingest_data_header_inrev_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_inrev_get`) = c("SWIGFunction", class('ingest_data_header_inrev_get'))

# Start of ingest_data_header_isndx_set

`ingest_data_header_isndx_set` = function(self, s_isndx)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_isndx = coerceIfNotSubclass(s_isndx, "_p_short") 
  .Call('R_swig_ingest_data_header_isndx_set', self, s_isndx, PACKAGE='iris')
  
}

attr(`ingest_data_header_isndx_set`, 'returnType') = 'void'
attr(`ingest_data_header_isndx_set`, "inputTypes") = c('_p_ingest_data_header', '_p_short')
class(`ingest_data_header_isndx_set`) = c("SWIGFunction", class('ingest_data_header_isndx_set'))

# Start of ingest_data_header_isndx_get

`ingest_data_header_isndx_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_isndx_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_data_header_isndx_get`, 'returnType') = '_p_short'
attr(`ingest_data_header_isndx_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_isndx_get`) = c("SWIGFunction", class('ingest_data_header_isndx_get'))

# Start of ingest_data_header_irtotl_set

`ingest_data_header_irtotl_set` = function(self, s_irtotl)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_irtotl = coerceIfNotSubclass(s_irtotl, "_p_short") 
  .Call('R_swig_ingest_data_header_irtotl_set', self, s_irtotl, PACKAGE='iris')
  
}

attr(`ingest_data_header_irtotl_set`, 'returnType') = 'void'
attr(`ingest_data_header_irtotl_set`, "inputTypes") = c('_p_ingest_data_header', '_p_short')
class(`ingest_data_header_irtotl_set`) = c("SWIGFunction", class('ingest_data_header_irtotl_set'))

# Start of ingest_data_header_irtotl_get

`ingest_data_header_irtotl_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_irtotl_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_data_header_irtotl_get`, 'returnType') = '_p_short'
attr(`ingest_data_header_irtotl_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_irtotl_get`) = c("SWIGFunction", class('ingest_data_header_irtotl_get'))

# Start of ingest_data_header_iwritn_set

`ingest_data_header_iwritn_set` = function(self, s_iwritn)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_iwritn = coerceIfNotSubclass(s_iwritn, "_p_short") 
  .Call('R_swig_ingest_data_header_iwritn_set', self, s_iwritn, PACKAGE='iris')
  
}

attr(`ingest_data_header_iwritn_set`, 'returnType') = 'void'
attr(`ingest_data_header_iwritn_set`, "inputTypes") = c('_p_ingest_data_header', '_p_short')
class(`ingest_data_header_iwritn_set`) = c("SWIGFunction", class('ingest_data_header_iwritn_set'))

# Start of ingest_data_header_iwritn_get

`ingest_data_header_iwritn_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_iwritn_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_data_header_iwritn_get`, 'returnType') = '_p_short'
attr(`ingest_data_header_iwritn_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_iwritn_get`) = c("SWIGFunction", class('ingest_data_header_iwritn_get'))

# Start of ingest_data_header_iangle_set

`ingest_data_header_iangle_set` = function(self, s_iangle)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_iangle = coerceIfNotSubclass(s_iangle, "_p_unsigned_short") 
  .Call('R_swig_ingest_data_header_iangle_set', self, s_iangle, PACKAGE='iris')
  
}

attr(`ingest_data_header_iangle_set`, 'returnType') = 'void'
attr(`ingest_data_header_iangle_set`, "inputTypes") = c('_p_ingest_data_header', '_p_unsigned_short')
class(`ingest_data_header_iangle_set`) = c("SWIGFunction", class('ingest_data_header_iangle_set'))

# Start of ingest_data_header_iangle_get

`ingest_data_header_iangle_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_iangle_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ingest_data_header_iangle_get`, 'returnType') = '_p_unsigned_short'
attr(`ingest_data_header_iangle_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_iangle_get`) = c("SWIGFunction", class('ingest_data_header_iangle_get'))

# Start of ingest_data_header_ibits_bin_set

`ingest_data_header_ibits_bin_set` = function(self, s_ibits_bin)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_ibits_bin = coerceIfNotSubclass(s_ibits_bin, "_p_short") 
  .Call('R_swig_ingest_data_header_ibits_bin_set', self, s_ibits_bin, PACKAGE='iris')
  
}

attr(`ingest_data_header_ibits_bin_set`, 'returnType') = 'void'
attr(`ingest_data_header_ibits_bin_set`, "inputTypes") = c('_p_ingest_data_header', '_p_short')
class(`ingest_data_header_ibits_bin_set`) = c("SWIGFunction", class('ingest_data_header_ibits_bin_set'))

# Start of ingest_data_header_ibits_bin_get

`ingest_data_header_ibits_bin_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_ibits_bin_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ingest_data_header_ibits_bin_get`, 'returnType') = '_p_short'
attr(`ingest_data_header_ibits_bin_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_ibits_bin_get`) = c("SWIGFunction", class('ingest_data_header_ibits_bin_get'))

# Start of ingest_data_header_idata_set

`ingest_data_header_idata_set` = function(self, s_idata)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  s_idata = coerceIfNotSubclass(s_idata, "_p_unsigned_short") 
  .Call('R_swig_ingest_data_header_idata_set', self, s_idata, PACKAGE='iris')
  
}

attr(`ingest_data_header_idata_set`, 'returnType') = 'void'
attr(`ingest_data_header_idata_set`, "inputTypes") = c('_p_ingest_data_header', '_p_unsigned_short')
class(`ingest_data_header_idata_set`) = c("SWIGFunction", class('ingest_data_header_idata_set'))

# Start of ingest_data_header_idata_get

`ingest_data_header_idata_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_idata_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ingest_data_header_idata_get`, 'returnType') = '_p_unsigned_short'
attr(`ingest_data_header_idata_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_idata_get`) = c("SWIGFunction", class('ingest_data_header_idata_get'))

# Start of ingest_data_header_ipad40x36_set

`ingest_data_header_ipad40x36_set` = function(self, s_ipad40x36)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  
  if(is.list(s_ipad40x36))
  assert(all(sapply(s_ipad40x36, class) == "_p_char"))     
  
  
#  assert(length(s_ipad40x36) >= 36)
  
  .Call('R_swig_ingest_data_header_ipad40x36_set', self, s_ipad40x36, PACKAGE='iris')
  
}

attr(`ingest_data_header_ipad40x36_set`, 'returnType') = 'void'
attr(`ingest_data_header_ipad40x36_set`, "inputTypes") = c('_p_ingest_data_header', '_p_char')
class(`ingest_data_header_ipad40x36_set`) = c("SWIGFunction", class('ingest_data_header_ipad40x36_set'))

# Start of ingest_data_header_ipad40x36_get

`ingest_data_header_ipad40x36_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  ans = .Call('R_swig_ingest_data_header_ipad40x36_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`ingest_data_header_ipad40x36_get`, 'returnType') = '_p_char'
attr(`ingest_data_header_ipad40x36_get`, "inputTypes") = c('_p_ingest_data_header')
class(`ingest_data_header_ipad40x36_get`) = c("SWIGFunction", class('ingest_data_header_ipad40x36_get'))

# Start of new_ingest_data_header

`ingest_data_header` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ingest_data_header', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ingest_data_header"
  
  ans
  
}

attr(`ingest_data_header`, 'returnType') = '_p_ingest_data_header'
class(`ingest_data_header`) = c("SWIGFunction", class('ingest_data_header'))

# Start of delete_ingest_data_header

`delete_ingest_data_header` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ingest_data_header") 
  .Call('R_swig_delete_ingest_data_header', self, PACKAGE='iris')
  
}

attr(`delete_ingest_data_header`, 'returnType') = 'void'
attr(`delete_ingest_data_header`, "inputTypes") = c('_p_ingest_data_header')
class(`delete_ingest_data_header`) = c("SWIGFunction", class('delete_ingest_data_header'))

# Start of accessor method for ingest_data_header
setMethod('$', '_p_ingest_data_header', function(x, name)

{
  accessorFuns = list('hdr' = ingest_data_header_hdr_get, 'time' = ingest_data_header_time_get, 'isweep' = ingest_data_header_isweep_get, 'inrev' = ingest_data_header_inrev_get, 'isndx' = ingest_data_header_isndx_get, 'irtotl' = ingest_data_header_irtotl_get, 'iwritn' = ingest_data_header_iwritn_get, 'iangle' = ingest_data_header_iangle_get, 'ibits_bin' = ingest_data_header_ibits_bin_get, 'idata' = ingest_data_header_idata_get, 'ipad40x36' = ingest_data_header_ipad40x36_get)
  vaccessors = c('hdr', 'time', 'isweep', 'inrev', 'isndx', 'irtotl', 'iwritn', 'iangle', 'ibits_bin', 'idata', 'ipad40x36')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ingest_data_header
# Start of accessor method for ingest_data_header
setMethod('$<-', '_p_ingest_data_header', function(x, name, value)

{
  accessorFuns = list('hdr' = ingest_data_header_hdr_set, 'time' = ingest_data_header_time_set, 'isweep' = ingest_data_header_isweep_set, 'inrev' = ingest_data_header_inrev_set, 'isndx' = ingest_data_header_isndx_set, 'irtotl' = ingest_data_header_irtotl_set, 'iwritn' = ingest_data_header_iwritn_set, 'iangle' = ingest_data_header_iangle_set, 'ibits_bin' = ingest_data_header_ibits_bin_set, 'idata' = ingest_data_header_idata_set, 'ipad40x36' = ingest_data_header_ipad40x36_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ingest_data_header', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('hdr' = ingest_data_header_hdr_set, 'time' = ingest_data_header_time_set, 'isweep' = ingest_data_header_isweep_set, 'inrev' = ingest_data_header_inrev_set, 'isndx' = ingest_data_header_isndx_set, 'irtotl' = ingest_data_header_irtotl_set, 'iwritn' = ingest_data_header_iwritn_set, 'iangle' = ingest_data_header_iangle_set, 'ibits_bin' = ingest_data_header_ibits_bin_set, 'idata' = ingest_data_header_idata_set, 'ipad40x36' = ingest_data_header_ipad40x36_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ingest_data_header
setMethod('delete', '_p_ingest_data_header', function(obj) {delete_ingest_data_header(obj)})
# Start definition of copy functions & methods for ingest_data_header
CopyToR_ingest_data_header = function(value, obj = new("ingest_data_header"))
{
  obj@ipad40x36 = value$ipad40x36
  obj
}



CopyToC_ingest_data_header = function(value, obj)
{
  obj$ipad40x36 = value@ipad40x36
  obj
}



# Start definition of copy methods for ingest_data_header
setMethod('copyToR', '_p_ingest_data_header', CopyToR_ingest_data_header)
setMethod('copyToC', 'ingest_data_header', CopyToC_ingest_data_header)

# End definition of copy methods for ingest_data_header
# End definition of copy functions & methods for ingest_data_header
# Start of raw_prod_bhdr_irec_set

`raw_prod_bhdr_irec_set` = function(self, s_irec)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  s_irec = coerceIfNotSubclass(s_irec, "_p_short") 
  .Call('R_swig_raw_prod_bhdr_irec_set', self, s_irec, PACKAGE='iris')
  
}

attr(`raw_prod_bhdr_irec_set`, 'returnType') = 'void'
attr(`raw_prod_bhdr_irec_set`, "inputTypes") = c('_p_raw_prod_bhdr', '_p_short')
class(`raw_prod_bhdr_irec_set`) = c("SWIGFunction", class('raw_prod_bhdr_irec_set'))

# Start of raw_prod_bhdr_irec_get

`raw_prod_bhdr_irec_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  ans = .Call('R_swig_raw_prod_bhdr_irec_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`raw_prod_bhdr_irec_get`, 'returnType') = '_p_short'
attr(`raw_prod_bhdr_irec_get`, "inputTypes") = c('_p_raw_prod_bhdr')
class(`raw_prod_bhdr_irec_get`) = c("SWIGFunction", class('raw_prod_bhdr_irec_get'))

# Start of raw_prod_bhdr_isweep_set

`raw_prod_bhdr_isweep_set` = function(self, s_isweep)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  s_isweep = coerceIfNotSubclass(s_isweep, "_p_short") 
  .Call('R_swig_raw_prod_bhdr_isweep_set', self, s_isweep, PACKAGE='iris')
  
}

attr(`raw_prod_bhdr_isweep_set`, 'returnType') = 'void'
attr(`raw_prod_bhdr_isweep_set`, "inputTypes") = c('_p_raw_prod_bhdr', '_p_short')
class(`raw_prod_bhdr_isweep_set`) = c("SWIGFunction", class('raw_prod_bhdr_isweep_set'))

# Start of raw_prod_bhdr_isweep_get

`raw_prod_bhdr_isweep_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  ans = .Call('R_swig_raw_prod_bhdr_isweep_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`raw_prod_bhdr_isweep_get`, 'returnType') = '_p_short'
attr(`raw_prod_bhdr_isweep_get`, "inputTypes") = c('_p_raw_prod_bhdr')
class(`raw_prod_bhdr_isweep_get`) = c("SWIGFunction", class('raw_prod_bhdr_isweep_get'))

# Start of raw_prod_bhdr_iray_ptr_set

`raw_prod_bhdr_iray_ptr_set` = function(self, s_iray_ptr)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  s_iray_ptr = coerceIfNotSubclass(s_iray_ptr, "_p_short") 
  .Call('R_swig_raw_prod_bhdr_iray_ptr_set', self, s_iray_ptr, PACKAGE='iris')
  
}

attr(`raw_prod_bhdr_iray_ptr_set`, 'returnType') = 'void'
attr(`raw_prod_bhdr_iray_ptr_set`, "inputTypes") = c('_p_raw_prod_bhdr', '_p_short')
class(`raw_prod_bhdr_iray_ptr_set`) = c("SWIGFunction", class('raw_prod_bhdr_iray_ptr_set'))

# Start of raw_prod_bhdr_iray_ptr_get

`raw_prod_bhdr_iray_ptr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  ans = .Call('R_swig_raw_prod_bhdr_iray_ptr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`raw_prod_bhdr_iray_ptr_get`, 'returnType') = '_p_short'
attr(`raw_prod_bhdr_iray_ptr_get`, "inputTypes") = c('_p_raw_prod_bhdr')
class(`raw_prod_bhdr_iray_ptr_get`) = c("SWIGFunction", class('raw_prod_bhdr_iray_ptr_get'))

# Start of raw_prod_bhdr_iray_num_set

`raw_prod_bhdr_iray_num_set` = function(self, s_iray_num)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  s_iray_num = coerceIfNotSubclass(s_iray_num, "_p_short") 
  .Call('R_swig_raw_prod_bhdr_iray_num_set', self, s_iray_num, PACKAGE='iris')
  
}

attr(`raw_prod_bhdr_iray_num_set`, 'returnType') = 'void'
attr(`raw_prod_bhdr_iray_num_set`, "inputTypes") = c('_p_raw_prod_bhdr', '_p_short')
class(`raw_prod_bhdr_iray_num_set`) = c("SWIGFunction", class('raw_prod_bhdr_iray_num_set'))

# Start of raw_prod_bhdr_iray_num_get

`raw_prod_bhdr_iray_num_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  ans = .Call('R_swig_raw_prod_bhdr_iray_num_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`raw_prod_bhdr_iray_num_get`, 'returnType') = '_p_short'
attr(`raw_prod_bhdr_iray_num_get`, "inputTypes") = c('_p_raw_prod_bhdr')
class(`raw_prod_bhdr_iray_num_get`) = c("SWIGFunction", class('raw_prod_bhdr_iray_num_get'))

# Start of raw_prod_bhdr_iflags_set

`raw_prod_bhdr_iflags_set` = function(self, s_iflags)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  s_iflags = coerceIfNotSubclass(s_iflags, "_p_unsigned_short") 
  .Call('R_swig_raw_prod_bhdr_iflags_set', self, s_iflags, PACKAGE='iris')
  
}

attr(`raw_prod_bhdr_iflags_set`, 'returnType') = 'void'
attr(`raw_prod_bhdr_iflags_set`, "inputTypes") = c('_p_raw_prod_bhdr', '_p_unsigned_short')
class(`raw_prod_bhdr_iflags_set`) = c("SWIGFunction", class('raw_prod_bhdr_iflags_set'))

# Start of raw_prod_bhdr_iflags_get

`raw_prod_bhdr_iflags_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  ans = .Call('R_swig_raw_prod_bhdr_iflags_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`raw_prod_bhdr_iflags_get`, 'returnType') = '_p_unsigned_short'
attr(`raw_prod_bhdr_iflags_get`, "inputTypes") = c('_p_raw_prod_bhdr')
class(`raw_prod_bhdr_iflags_get`) = c("SWIGFunction", class('raw_prod_bhdr_iflags_get'))

# Start of raw_prod_bhdr_ipad10x2_set

`raw_prod_bhdr_ipad10x2_set` = function(self, s_ipad10x2)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  
  if(is.list(s_ipad10x2))
  assert(all(sapply(s_ipad10x2, class) == "_p_unsigned_char"))     
  
  
#  assert(length(s_ipad10x2) >= 2)
  
  .Call('R_swig_raw_prod_bhdr_ipad10x2_set', self, s_ipad10x2, PACKAGE='iris')
  
}

attr(`raw_prod_bhdr_ipad10x2_set`, 'returnType') = 'void'
attr(`raw_prod_bhdr_ipad10x2_set`, "inputTypes") = c('_p_raw_prod_bhdr', '_p_unsigned_char')
class(`raw_prod_bhdr_ipad10x2_set`) = c("SWIGFunction", class('raw_prod_bhdr_ipad10x2_set'))

# Start of raw_prod_bhdr_ipad10x2_get

`raw_prod_bhdr_ipad10x2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  ans = .Call('R_swig_raw_prod_bhdr_ipad10x2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`raw_prod_bhdr_ipad10x2_get`, 'returnType') = '_p_unsigned_char'
attr(`raw_prod_bhdr_ipad10x2_get`, "inputTypes") = c('_p_raw_prod_bhdr')
class(`raw_prod_bhdr_ipad10x2_get`) = c("SWIGFunction", class('raw_prod_bhdr_ipad10x2_get'))

# Start of new_raw_prod_bhdr

`raw_prod_bhdr` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_raw_prod_bhdr', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_raw_prod_bhdr"
  
  ans
  
}

attr(`raw_prod_bhdr`, 'returnType') = '_p_raw_prod_bhdr'
class(`raw_prod_bhdr`) = c("SWIGFunction", class('raw_prod_bhdr'))

# Start of delete_raw_prod_bhdr

`delete_raw_prod_bhdr` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_bhdr") 
  .Call('R_swig_delete_raw_prod_bhdr', self, PACKAGE='iris')
  
}

attr(`delete_raw_prod_bhdr`, 'returnType') = 'void'
attr(`delete_raw_prod_bhdr`, "inputTypes") = c('_p_raw_prod_bhdr')
class(`delete_raw_prod_bhdr`) = c("SWIGFunction", class('delete_raw_prod_bhdr'))

# Start of accessor method for raw_prod_bhdr
setMethod('$', '_p_raw_prod_bhdr', function(x, name)

{
  accessorFuns = list('irec' = raw_prod_bhdr_irec_get, 'isweep' = raw_prod_bhdr_isweep_get, 'iray_ptr' = raw_prod_bhdr_iray_ptr_get, 'iray_num' = raw_prod_bhdr_iray_num_get, 'iflags' = raw_prod_bhdr_iflags_get, 'ipad10x2' = raw_prod_bhdr_ipad10x2_get)
  vaccessors = c('irec', 'isweep', 'iray_ptr', 'iray_num', 'iflags', 'ipad10x2')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for raw_prod_bhdr
# Start of accessor method for raw_prod_bhdr
setMethod('$<-', '_p_raw_prod_bhdr', function(x, name, value)

{
  accessorFuns = list('irec' = raw_prod_bhdr_irec_set, 'isweep' = raw_prod_bhdr_isweep_set, 'iray_ptr' = raw_prod_bhdr_iray_ptr_set, 'iray_num' = raw_prod_bhdr_iray_num_set, 'iflags' = raw_prod_bhdr_iflags_set, 'ipad10x2' = raw_prod_bhdr_ipad10x2_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_raw_prod_bhdr', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('irec' = raw_prod_bhdr_irec_set, 'isweep' = raw_prod_bhdr_isweep_set, 'iray_ptr' = raw_prod_bhdr_iray_ptr_set, 'iray_num' = raw_prod_bhdr_iray_num_set, 'iflags' = raw_prod_bhdr_iflags_set, 'ipad10x2' = raw_prod_bhdr_ipad10x2_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for raw_prod_bhdr
setMethod('delete', '_p_raw_prod_bhdr', function(obj) {delete_raw_prod_bhdr(obj)})
# Start definition of copy functions & methods for raw_prod_bhdr
CopyToR_raw_prod_bhdr = function(value, obj = new("raw_prod_bhdr"))
{
  obj
}



CopyToC_raw_prod_bhdr = function(value, obj)
{
  obj
}



# Start definition of copy methods for raw_prod_bhdr
setMethod('copyToR', '_p_raw_prod_bhdr', CopyToR_raw_prod_bhdr)
setMethod('copyToC', 'raw_prod_bhdr', CopyToC_raw_prod_bhdr)

# End definition of copy methods for raw_prod_bhdr
# End definition of copy functions & methods for raw_prod_bhdr
# Start of raw_prod_block_hdr_set

`raw_prod_block_hdr_set` = function(self, s_hdr)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_block") 
  s_hdr = coerceIfNotSubclass(s_hdr, "_p_raw_prod_bhdr") 
  .Call('R_swig_raw_prod_block_hdr_set', self, s_hdr, PACKAGE='iris')
  
}

attr(`raw_prod_block_hdr_set`, 'returnType') = 'void'
attr(`raw_prod_block_hdr_set`, "inputTypes") = c('_p_raw_prod_block', '_p_raw_prod_bhdr')
class(`raw_prod_block_hdr_set`) = c("SWIGFunction", class('raw_prod_block_hdr_set'))

# Start of raw_prod_block_hdr_get

`raw_prod_block_hdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_block") 
  ans = .Call('R_swig_raw_prod_block_hdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_raw_prod_bhdr"
  
  ans
  
}

attr(`raw_prod_block_hdr_get`, 'returnType') = '_p_raw_prod_bhdr'
attr(`raw_prod_block_hdr_get`, "inputTypes") = c('_p_raw_prod_block')
class(`raw_prod_block_hdr_get`) = c("SWIGFunction", class('raw_prod_block_hdr_get'))

# Start of raw_prod_block_ibytes_set

`raw_prod_block_ibytes_set` = function(self, s_ibytes)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_block") 
  
  if(is.list(s_ibytes))
  assert(all(sapply(s_ibytes, class) == "_p_unsigned_char"))     
  
  
#  assert(length(s_ibytes) >= ((6144) -(12)))
  
  .Call('R_swig_raw_prod_block_ibytes_set', self, s_ibytes, PACKAGE='iris')
  
}

attr(`raw_prod_block_ibytes_set`, 'returnType') = 'void'
attr(`raw_prod_block_ibytes_set`, "inputTypes") = c('_p_raw_prod_block', '_p_unsigned_char')
class(`raw_prod_block_ibytes_set`) = c("SWIGFunction", class('raw_prod_block_ibytes_set'))

# Start of raw_prod_block_ibytes_get

`raw_prod_block_ibytes_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_block") 
  ans = .Call('R_swig_raw_prod_block_ibytes_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`raw_prod_block_ibytes_get`, 'returnType') = '_p_unsigned_char'
attr(`raw_prod_block_ibytes_get`, "inputTypes") = c('_p_raw_prod_block')
class(`raw_prod_block_ibytes_get`) = c("SWIGFunction", class('raw_prod_block_ibytes_get'))

# Start of new_raw_prod_block

`raw_prod_block` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_raw_prod_block', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_raw_prod_block"
  
  ans
  
}

attr(`raw_prod_block`, 'returnType') = '_p_raw_prod_block'
class(`raw_prod_block`) = c("SWIGFunction", class('raw_prod_block'))

# Start of delete_raw_prod_block

`delete_raw_prod_block` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_raw_prod_block") 
  .Call('R_swig_delete_raw_prod_block', self, PACKAGE='iris')
  
}

attr(`delete_raw_prod_block`, 'returnType') = 'void'
attr(`delete_raw_prod_block`, "inputTypes") = c('_p_raw_prod_block')
class(`delete_raw_prod_block`) = c("SWIGFunction", class('delete_raw_prod_block'))

# Start of accessor method for raw_prod_block
setMethod('$', '_p_raw_prod_block', function(x, name)

{
  accessorFuns = list('hdr' = raw_prod_block_hdr_get, 'ibytes' = raw_prod_block_ibytes_get)
  vaccessors = c('hdr', 'ibytes')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for raw_prod_block
# Start of accessor method for raw_prod_block
setMethod('$<-', '_p_raw_prod_block', function(x, name, value)

{
  accessorFuns = list('hdr' = raw_prod_block_hdr_set, 'ibytes' = raw_prod_block_ibytes_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_raw_prod_block', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('hdr' = raw_prod_block_hdr_set, 'ibytes' = raw_prod_block_ibytes_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for raw_prod_block
setMethod('delete', '_p_raw_prod_block', function(obj) {delete_raw_prod_block(obj)})
# Start definition of copy functions & methods for raw_prod_block
CopyToR_raw_prod_block = function(value, obj = new("raw_prod_block"))
{
  obj
}



CopyToC_raw_prod_block = function(value, obj)
{
  obj
}



# Start definition of copy methods for raw_prod_block
setMethod('copyToR', '_p_raw_prod_block', CopyToR_raw_prod_block)
setMethod('copyToC', 'raw_prod_block', CopyToC_raw_prod_block)

# End definition of copy methods for raw_prod_block
# End definition of copy functions & methods for raw_prod_block
# Start of ray_header_iaz_start_set

`ray_header_iaz_start_set` = function(self, s_iaz_start)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  s_iaz_start = coerceIfNotSubclass(s_iaz_start, "_p_unsigned_short") 
  .Call('R_swig_ray_header_iaz_start_set', self, s_iaz_start, PACKAGE='iris')
  
}

attr(`ray_header_iaz_start_set`, 'returnType') = 'void'
attr(`ray_header_iaz_start_set`, "inputTypes") = c('_p_ray_header', '_p_unsigned_short')
class(`ray_header_iaz_start_set`) = c("SWIGFunction", class('ray_header_iaz_start_set'))

# Start of ray_header_iaz_start_get

`ray_header_iaz_start_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  ans = .Call('R_swig_ray_header_iaz_start_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ray_header_iaz_start_get`, 'returnType') = '_p_unsigned_short'
attr(`ray_header_iaz_start_get`, "inputTypes") = c('_p_ray_header')
class(`ray_header_iaz_start_get`) = c("SWIGFunction", class('ray_header_iaz_start_get'))

# Start of ray_header_iel_start_set

`ray_header_iel_start_set` = function(self, s_iel_start)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  s_iel_start = coerceIfNotSubclass(s_iel_start, "_p_unsigned_short") 
  .Call('R_swig_ray_header_iel_start_set', self, s_iel_start, PACKAGE='iris')
  
}

attr(`ray_header_iel_start_set`, 'returnType') = 'void'
attr(`ray_header_iel_start_set`, "inputTypes") = c('_p_ray_header', '_p_unsigned_short')
class(`ray_header_iel_start_set`) = c("SWIGFunction", class('ray_header_iel_start_set'))

# Start of ray_header_iel_start_get

`ray_header_iel_start_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  ans = .Call('R_swig_ray_header_iel_start_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ray_header_iel_start_get`, 'returnType') = '_p_unsigned_short'
attr(`ray_header_iel_start_get`, "inputTypes") = c('_p_ray_header')
class(`ray_header_iel_start_get`) = c("SWIGFunction", class('ray_header_iel_start_get'))

# Start of ray_header_iaz_end_set

`ray_header_iaz_end_set` = function(self, s_iaz_end)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  s_iaz_end = coerceIfNotSubclass(s_iaz_end, "_p_unsigned_short") 
  .Call('R_swig_ray_header_iaz_end_set', self, s_iaz_end, PACKAGE='iris')
  
}

attr(`ray_header_iaz_end_set`, 'returnType') = 'void'
attr(`ray_header_iaz_end_set`, "inputTypes") = c('_p_ray_header', '_p_unsigned_short')
class(`ray_header_iaz_end_set`) = c("SWIGFunction", class('ray_header_iaz_end_set'))

# Start of ray_header_iaz_end_get

`ray_header_iaz_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  ans = .Call('R_swig_ray_header_iaz_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ray_header_iaz_end_get`, 'returnType') = '_p_unsigned_short'
attr(`ray_header_iaz_end_get`, "inputTypes") = c('_p_ray_header')
class(`ray_header_iaz_end_get`) = c("SWIGFunction", class('ray_header_iaz_end_get'))

# Start of ray_header_iel_end_set

`ray_header_iel_end_set` = function(self, s_iel_end)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  s_iel_end = coerceIfNotSubclass(s_iel_end, "_p_unsigned_short") 
  .Call('R_swig_ray_header_iel_end_set', self, s_iel_end, PACKAGE='iris')
  
}

attr(`ray_header_iel_end_set`, 'returnType') = 'void'
attr(`ray_header_iel_end_set`, "inputTypes") = c('_p_ray_header', '_p_unsigned_short')
class(`ray_header_iel_end_set`) = c("SWIGFunction", class('ray_header_iel_end_set'))

# Start of ray_header_iel_end_get

`ray_header_iel_end_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  ans = .Call('R_swig_ray_header_iel_end_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ray_header_iel_end_get`, 'returnType') = '_p_unsigned_short'
attr(`ray_header_iel_end_get`, "inputTypes") = c('_p_ray_header')
class(`ray_header_iel_end_get`) = c("SWIGFunction", class('ray_header_iel_end_get'))

# Start of ray_header_ibincount_set

`ray_header_ibincount_set` = function(self, s_ibincount)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  s_ibincount = coerceIfNotSubclass(s_ibincount, "_p_short") 
  .Call('R_swig_ray_header_ibincount_set', self, s_ibincount, PACKAGE='iris')
  
}

attr(`ray_header_ibincount_set`, 'returnType') = 'void'
attr(`ray_header_ibincount_set`, "inputTypes") = c('_p_ray_header', '_p_short')
class(`ray_header_ibincount_set`) = c("SWIGFunction", class('ray_header_ibincount_set'))

# Start of ray_header_ibincount_get

`ray_header_ibincount_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  ans = .Call('R_swig_ray_header_ibincount_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`ray_header_ibincount_get`, 'returnType') = '_p_short'
attr(`ray_header_ibincount_get`, "inputTypes") = c('_p_ray_header')
class(`ray_header_ibincount_get`) = c("SWIGFunction", class('ray_header_ibincount_get'))

# Start of ray_header_itime_set

`ray_header_itime_set` = function(self, s_itime)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  s_itime = coerceIfNotSubclass(s_itime, "_p_unsigned_short") 
  .Call('R_swig_ray_header_itime_set', self, s_itime, PACKAGE='iris')
  
}

attr(`ray_header_itime_set`, 'returnType') = 'void'
attr(`ray_header_itime_set`, "inputTypes") = c('_p_ray_header', '_p_unsigned_short')
class(`ray_header_itime_set`) = c("SWIGFunction", class('ray_header_itime_set'))

# Start of ray_header_itime_get

`ray_header_itime_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  ans = .Call('R_swig_ray_header_itime_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ray_header_itime_get`, 'returnType') = '_p_unsigned_short'
attr(`ray_header_itime_get`, "inputTypes") = c('_p_ray_header')
class(`ray_header_itime_get`) = c("SWIGFunction", class('ray_header_itime_get'))

# Start of new_ray_header

`ray_header` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ray_header', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ray_header"
  
  ans
  
}

attr(`ray_header`, 'returnType') = '_p_ray_header'
class(`ray_header`) = c("SWIGFunction", class('ray_header'))

# Start of delete_ray_header

`delete_ray_header` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ray_header") 
  .Call('R_swig_delete_ray_header', self, PACKAGE='iris')
  
}

attr(`delete_ray_header`, 'returnType') = 'void'
attr(`delete_ray_header`, "inputTypes") = c('_p_ray_header')
class(`delete_ray_header`) = c("SWIGFunction", class('delete_ray_header'))

# Start of accessor method for ray_header
setMethod('$', '_p_ray_header', function(x, name)

{
  accessorFuns = list('iaz_start' = ray_header_iaz_start_get, 'iel_start' = ray_header_iel_start_get, 'iaz_end' = ray_header_iaz_end_get, 'iel_end' = ray_header_iel_end_get, 'ibincount' = ray_header_ibincount_get, 'itime' = ray_header_itime_get)
  vaccessors = c('iaz_start', 'iel_start', 'iaz_end', 'iel_end', 'ibincount', 'itime')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ray_header
# Start of accessor method for ray_header
setMethod('$<-', '_p_ray_header', function(x, name, value)

{
  accessorFuns = list('iaz_start' = ray_header_iaz_start_set, 'iel_start' = ray_header_iel_start_set, 'iaz_end' = ray_header_iaz_end_set, 'iel_end' = ray_header_iel_end_set, 'ibincount' = ray_header_ibincount_set, 'itime' = ray_header_itime_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ray_header', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iaz_start' = ray_header_iaz_start_set, 'iel_start' = ray_header_iel_start_set, 'iaz_end' = ray_header_iaz_end_set, 'iel_end' = ray_header_iel_end_set, 'ibincount' = ray_header_ibincount_set, 'itime' = ray_header_itime_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ray_header
setMethod('delete', '_p_ray_header', function(obj) {delete_ray_header(obj)})
# Start definition of copy functions & methods for ray_header
CopyToR_ray_header = function(value, obj = new("ray_header"))
{
  obj
}



CopyToC_ray_header = function(value, obj)
{
  obj
}



# Start definition of copy methods for ray_header
setMethod('copyToR', '_p_ray_header', CopyToR_ray_header)
setMethod('copyToC', 'ray_header', CopyToC_ray_header)

# End definition of copy methods for ray_header
# End definition of copy functions & methods for ray_header
# Start of extended_header_v0_itimems_set

`extended_header_v0_itimems_set` = function(self, s_itimems)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v0") 
  s_itimems = as.integer(s_itimems) 
  
  if(length(s_itimems) > 1) {
    Rf_warning("using only the first element of s_itimems")
  }
  
  .Call('R_swig_extended_header_v0_itimems_set', self, s_itimems, PACKAGE='iris')
  
}

attr(`extended_header_v0_itimems_set`, 'returnType') = 'void'
attr(`extended_header_v0_itimems_set`, "inputTypes") = c('_p_extended_header_v0', 'numeric')
class(`extended_header_v0_itimems_set`) = c("SWIGFunction", class('extended_header_v0_itimems_set'))

# Start of extended_header_v0_itimems_get

`extended_header_v0_itimems_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v0") 
  .Call('R_swig_extended_header_v0_itimems_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`extended_header_v0_itimems_get`, 'returnType') = 'numeric'
attr(`extended_header_v0_itimems_get`, "inputTypes") = c('_p_extended_header_v0')
class(`extended_header_v0_itimems_get`) = c("SWIGFunction", class('extended_header_v0_itimems_get'))

# Start of extended_header_v0_icallevel_set

`extended_header_v0_icallevel_set` = function(self, s_icallevel)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v0") 
  s_icallevel = coerceIfNotSubclass(s_icallevel, "_p_short") 
  .Call('R_swig_extended_header_v0_icallevel_set', self, s_icallevel, PACKAGE='iris')
  
}

attr(`extended_header_v0_icallevel_set`, 'returnType') = 'void'
attr(`extended_header_v0_icallevel_set`, "inputTypes") = c('_p_extended_header_v0', '_p_short')
class(`extended_header_v0_icallevel_set`) = c("SWIGFunction", class('extended_header_v0_icallevel_set'))

# Start of extended_header_v0_icallevel_get

`extended_header_v0_icallevel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v0") 
  ans = .Call('R_swig_extended_header_v0_icallevel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`extended_header_v0_icallevel_get`, 'returnType') = '_p_short'
attr(`extended_header_v0_icallevel_get`, "inputTypes") = c('_p_extended_header_v0')
class(`extended_header_v0_icallevel_get`) = c("SWIGFunction", class('extended_header_v0_icallevel_get'))

# Start of extended_header_v0_ipad6x14_set

`extended_header_v0_ipad6x14_set` = function(self, s_ipad6x14)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v0") 
  
  if(is.list(s_ipad6x14))
  assert(all(sapply(s_ipad6x14, class) == "_p_char"))     
  
  
#  assert(length(s_ipad6x14) >= 14)
  
  .Call('R_swig_extended_header_v0_ipad6x14_set', self, s_ipad6x14, PACKAGE='iris')
  
}

attr(`extended_header_v0_ipad6x14_set`, 'returnType') = 'void'
attr(`extended_header_v0_ipad6x14_set`, "inputTypes") = c('_p_extended_header_v0', '_p_char')
class(`extended_header_v0_ipad6x14_set`) = c("SWIGFunction", class('extended_header_v0_ipad6x14_set'))

# Start of extended_header_v0_ipad6x14_get

`extended_header_v0_ipad6x14_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v0") 
  ans = .Call('R_swig_extended_header_v0_ipad6x14_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_char"
  
  ans
  
}

attr(`extended_header_v0_ipad6x14_get`, 'returnType') = '_p_char'
attr(`extended_header_v0_ipad6x14_get`, "inputTypes") = c('_p_extended_header_v0')
class(`extended_header_v0_ipad6x14_get`) = c("SWIGFunction", class('extended_header_v0_ipad6x14_get'))

# Start of new_extended_header_v0

`extended_header_v0` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_extended_header_v0', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_extended_header_v0"
  
  ans
  
}

attr(`extended_header_v0`, 'returnType') = '_p_extended_header_v0'
class(`extended_header_v0`) = c("SWIGFunction", class('extended_header_v0'))

# Start of delete_extended_header_v0

`delete_extended_header_v0` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v0") 
  .Call('R_swig_delete_extended_header_v0', self, PACKAGE='iris')
  
}

attr(`delete_extended_header_v0`, 'returnType') = 'void'
attr(`delete_extended_header_v0`, "inputTypes") = c('_p_extended_header_v0')
class(`delete_extended_header_v0`) = c("SWIGFunction", class('delete_extended_header_v0'))

# Start of accessor method for extended_header_v0
setMethod('$', '_p_extended_header_v0', function(x, name)

{
  accessorFuns = list('itimems' = extended_header_v0_itimems_get, 'icallevel' = extended_header_v0_icallevel_get, 'ipad6x14' = extended_header_v0_ipad6x14_get)
  vaccessors = c('itimems', 'icallevel', 'ipad6x14')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for extended_header_v0
# Start of accessor method for extended_header_v0
setMethod('$<-', '_p_extended_header_v0', function(x, name, value)

{
  accessorFuns = list('itimems' = extended_header_v0_itimems_set, 'icallevel' = extended_header_v0_icallevel_set, 'ipad6x14' = extended_header_v0_ipad6x14_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_extended_header_v0', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('itimems' = extended_header_v0_itimems_set, 'icallevel' = extended_header_v0_icallevel_set, 'ipad6x14' = extended_header_v0_ipad6x14_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for extended_header_v0
setMethod('delete', '_p_extended_header_v0', function(obj) {delete_extended_header_v0(obj)})
# Start definition of copy functions & methods for extended_header_v0
CopyToR_extended_header_v0 = function(value, obj = new("extended_header_v0"))
{
  obj@itimems = value$itimems
  obj@ipad6x14 = value$ipad6x14
  obj
}



CopyToC_extended_header_v0 = function(value, obj)
{
  obj$itimems = value@itimems
  obj$ipad6x14 = value@ipad6x14
  obj
}



# Start definition of copy methods for extended_header_v0
setMethod('copyToR', '_p_extended_header_v0', CopyToR_extended_header_v0)
setMethod('copyToC', 'extended_header_v0', CopyToC_extended_header_v0)

# End definition of copy methods for extended_header_v0
# End definition of copy functions & methods for extended_header_v0
# Start of extended_header_v1_itimems_set

`extended_header_v1_itimems_set` = function(self, s_itimems)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_itimems = as.integer(s_itimems) 
  
  if(length(s_itimems) > 1) {
    Rf_warning("using only the first element of s_itimems")
  }
  
  .Call('R_swig_extended_header_v1_itimems_set', self, s_itimems, PACKAGE='iris')
  
}

attr(`extended_header_v1_itimems_set`, 'returnType') = 'void'
attr(`extended_header_v1_itimems_set`, "inputTypes") = c('_p_extended_header_v1', 'numeric')
class(`extended_header_v1_itimems_set`) = c("SWIGFunction", class('extended_header_v1_itimems_set'))

# Start of extended_header_v1_itimems_get

`extended_header_v1_itimems_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  .Call('R_swig_extended_header_v1_itimems_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`extended_header_v1_itimems_get`, 'returnType') = 'numeric'
attr(`extended_header_v1_itimems_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_itimems_get`) = c("SWIGFunction", class('extended_header_v1_itimems_get'))

# Start of extended_header_v1_icallevel_set

`extended_header_v1_icallevel_set` = function(self, s_icallevel)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_icallevel = coerceIfNotSubclass(s_icallevel, "_p_short") 
  .Call('R_swig_extended_header_v1_icallevel_set', self, s_icallevel, PACKAGE='iris')
  
}

attr(`extended_header_v1_icallevel_set`, 'returnType') = 'void'
attr(`extended_header_v1_icallevel_set`, "inputTypes") = c('_p_extended_header_v1', '_p_short')
class(`extended_header_v1_icallevel_set`) = c("SWIGFunction", class('extended_header_v1_icallevel_set'))

# Start of extended_header_v1_icallevel_get

`extended_header_v1_icallevel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_icallevel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`extended_header_v1_icallevel_get`, 'returnType') = '_p_short'
attr(`extended_header_v1_icallevel_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_icallevel_get`) = c("SWIGFunction", class('extended_header_v1_icallevel_get'))

# Start of extended_header_v1_iaz_set

`extended_header_v1_iaz_set` = function(self, s_iaz)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_iaz = coerceIfNotSubclass(s_iaz, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_iaz_set', self, s_iaz, PACKAGE='iris')
  
}

attr(`extended_header_v1_iaz_set`, 'returnType') = 'void'
attr(`extended_header_v1_iaz_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_iaz_set`) = c("SWIGFunction", class('extended_header_v1_iaz_set'))

# Start of extended_header_v1_iaz_get

`extended_header_v1_iaz_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_iaz_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_iaz_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_iaz_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_iaz_get`) = c("SWIGFunction", class('extended_header_v1_iaz_get'))

# Start of extended_header_v1_iel_set

`extended_header_v1_iel_set` = function(self, s_iel)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_iel = coerceIfNotSubclass(s_iel, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_iel_set', self, s_iel, PACKAGE='iris')
  
}

attr(`extended_header_v1_iel_set`, 'returnType') = 'void'
attr(`extended_header_v1_iel_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_iel_set`) = c("SWIGFunction", class('extended_header_v1_iel_set'))

# Start of extended_header_v1_iel_get

`extended_header_v1_iel_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_iel_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_iel_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_iel_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_iel_get`) = c("SWIGFunction", class('extended_header_v1_iel_get'))

# Start of extended_header_v1_itrain_set

`extended_header_v1_itrain_set` = function(self, s_itrain)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_itrain = coerceIfNotSubclass(s_itrain, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_itrain_set', self, s_itrain, PACKAGE='iris')
  
}

attr(`extended_header_v1_itrain_set`, 'returnType') = 'void'
attr(`extended_header_v1_itrain_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_itrain_set`) = c("SWIGFunction", class('extended_header_v1_itrain_set'))

# Start of extended_header_v1_itrain_get

`extended_header_v1_itrain_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_itrain_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_itrain_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_itrain_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_itrain_get`) = c("SWIGFunction", class('extended_header_v1_itrain_get'))

# Start of extended_header_v1_ielor_set

`extended_header_v1_ielor_set` = function(self, s_ielor)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ielor = coerceIfNotSubclass(s_ielor, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_ielor_set', self, s_ielor, PACKAGE='iris')
  
}

attr(`extended_header_v1_ielor_set`, 'returnType') = 'void'
attr(`extended_header_v1_ielor_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_ielor_set`) = c("SWIGFunction", class('extended_header_v1_ielor_set'))

# Start of extended_header_v1_ielor_get

`extended_header_v1_ielor_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ielor_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_ielor_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_ielor_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ielor_get`) = c("SWIGFunction", class('extended_header_v1_ielor_get'))

# Start of extended_header_v1_ipitch_set

`extended_header_v1_ipitch_set` = function(self, s_ipitch)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ipitch = coerceIfNotSubclass(s_ipitch, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_ipitch_set', self, s_ipitch, PACKAGE='iris')
  
}

attr(`extended_header_v1_ipitch_set`, 'returnType') = 'void'
attr(`extended_header_v1_ipitch_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_ipitch_set`) = c("SWIGFunction", class('extended_header_v1_ipitch_set'))

# Start of extended_header_v1_ipitch_get

`extended_header_v1_ipitch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ipitch_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_ipitch_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_ipitch_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ipitch_get`) = c("SWIGFunction", class('extended_header_v1_ipitch_get'))

# Start of extended_header_v1_iroll_set

`extended_header_v1_iroll_set` = function(self, s_iroll)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_iroll = coerceIfNotSubclass(s_iroll, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_iroll_set', self, s_iroll, PACKAGE='iris')
  
}

attr(`extended_header_v1_iroll_set`, 'returnType') = 'void'
attr(`extended_header_v1_iroll_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_iroll_set`) = c("SWIGFunction", class('extended_header_v1_iroll_set'))

# Start of extended_header_v1_iroll_get

`extended_header_v1_iroll_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_iroll_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_iroll_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_iroll_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_iroll_get`) = c("SWIGFunction", class('extended_header_v1_iroll_get'))

# Start of extended_header_v1_iheading_set

`extended_header_v1_iheading_set` = function(self, s_iheading)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_iheading = coerceIfNotSubclass(s_iheading, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_iheading_set', self, s_iheading, PACKAGE='iris')
  
}

attr(`extended_header_v1_iheading_set`, 'returnType') = 'void'
attr(`extended_header_v1_iheading_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_iheading_set`) = c("SWIGFunction", class('extended_header_v1_iheading_set'))

# Start of extended_header_v1_iheading_get

`extended_header_v1_iheading_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_iheading_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_iheading_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_iheading_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_iheading_get`) = c("SWIGFunction", class('extended_header_v1_iheading_get'))

# Start of extended_header_v1_ivel_az_set

`extended_header_v1_ivel_az_set` = function(self, s_ivel_az)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_az = coerceIfNotSubclass(s_ivel_az, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_ivel_az_set', self, s_ivel_az, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_az_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_az_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_ivel_az_set`) = c("SWIGFunction", class('extended_header_v1_ivel_az_set'))

# Start of extended_header_v1_ivel_az_get

`extended_header_v1_ivel_az_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_az_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_az_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_ivel_az_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_az_get`) = c("SWIGFunction", class('extended_header_v1_ivel_az_get'))

# Start of extended_header_v1_ivel_el_set

`extended_header_v1_ivel_el_set` = function(self, s_ivel_el)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_el = coerceIfNotSubclass(s_ivel_el, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_ivel_el_set', self, s_ivel_el, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_el_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_el_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_ivel_el_set`) = c("SWIGFunction", class('extended_header_v1_ivel_el_set'))

# Start of extended_header_v1_ivel_el_get

`extended_header_v1_ivel_el_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_el_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_el_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_ivel_el_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_el_get`) = c("SWIGFunction", class('extended_header_v1_ivel_el_get'))

# Start of extended_header_v1_ivel_pitch_set

`extended_header_v1_ivel_pitch_set` = function(self, s_ivel_pitch)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_pitch = coerceIfNotSubclass(s_ivel_pitch, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_ivel_pitch_set', self, s_ivel_pitch, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_pitch_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_pitch_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_ivel_pitch_set`) = c("SWIGFunction", class('extended_header_v1_ivel_pitch_set'))

# Start of extended_header_v1_ivel_pitch_get

`extended_header_v1_ivel_pitch_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_pitch_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_pitch_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_ivel_pitch_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_pitch_get`) = c("SWIGFunction", class('extended_header_v1_ivel_pitch_get'))

# Start of extended_header_v1_ivel_roll_set

`extended_header_v1_ivel_roll_set` = function(self, s_ivel_roll)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_roll = coerceIfNotSubclass(s_ivel_roll, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_ivel_roll_set', self, s_ivel_roll, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_roll_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_roll_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_ivel_roll_set`) = c("SWIGFunction", class('extended_header_v1_ivel_roll_set'))

# Start of extended_header_v1_ivel_roll_get

`extended_header_v1_ivel_roll_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_roll_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_roll_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_ivel_roll_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_roll_get`) = c("SWIGFunction", class('extended_header_v1_ivel_roll_get'))

# Start of extended_header_v1_ilatitude_set

`extended_header_v1_ilatitude_set` = function(self, s_ilatitude)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ilatitude = as.numeric(s_ilatitude) 
  
  assert(length(s_ilatitude) == 1 && s_ilatitude >= 0, "All values must be non-negative")
  
  .Call('R_swig_extended_header_v1_ilatitude_set', self, s_ilatitude, PACKAGE='iris')
  
}

attr(`extended_header_v1_ilatitude_set`, 'returnType') = 'void'
attr(`extended_header_v1_ilatitude_set`, "inputTypes") = c('_p_extended_header_v1', 'numeric')
class(`extended_header_v1_ilatitude_set`) = c("SWIGFunction", class('extended_header_v1_ilatitude_set'))

# Start of extended_header_v1_ilatitude_get

`extended_header_v1_ilatitude_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  .Call('R_swig_extended_header_v1_ilatitude_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`extended_header_v1_ilatitude_get`, 'returnType') = 'numeric'
attr(`extended_header_v1_ilatitude_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ilatitude_get`) = c("SWIGFunction", class('extended_header_v1_ilatitude_get'))

# Start of extended_header_v1_ilongitude_set

`extended_header_v1_ilongitude_set` = function(self, s_ilongitude)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ilongitude = as.numeric(s_ilongitude) 
  
  assert(length(s_ilongitude) == 1 && s_ilongitude >= 0, "All values must be non-negative")
  
  .Call('R_swig_extended_header_v1_ilongitude_set', self, s_ilongitude, PACKAGE='iris')
  
}

attr(`extended_header_v1_ilongitude_set`, 'returnType') = 'void'
attr(`extended_header_v1_ilongitude_set`, "inputTypes") = c('_p_extended_header_v1', 'numeric')
class(`extended_header_v1_ilongitude_set`) = c("SWIGFunction", class('extended_header_v1_ilongitude_set'))

# Start of extended_header_v1_ilongitude_get

`extended_header_v1_ilongitude_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  .Call('R_swig_extended_header_v1_ilongitude_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`extended_header_v1_ilongitude_get`, 'returnType') = 'numeric'
attr(`extended_header_v1_ilongitude_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ilongitude_get`) = c("SWIGFunction", class('extended_header_v1_ilongitude_get'))

# Start of extended_header_v1_ivel_heading_set

`extended_header_v1_ivel_heading_set` = function(self, s_ivel_heading)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_heading = coerceIfNotSubclass(s_ivel_heading, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_ivel_heading_set', self, s_ivel_heading, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_heading_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_heading_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_ivel_heading_set`) = c("SWIGFunction", class('extended_header_v1_ivel_heading_set'))

# Start of extended_header_v1_ivel_heading_get

`extended_header_v1_ivel_heading_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_heading_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_heading_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_ivel_heading_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_heading_get`) = c("SWIGFunction", class('extended_header_v1_ivel_heading_get'))

# Start of extended_header_v1_ialtitude_set

`extended_header_v1_ialtitude_set` = function(self, s_ialtitude)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ialtitude = coerceIfNotSubclass(s_ialtitude, "_p_short") 
  .Call('R_swig_extended_header_v1_ialtitude_set', self, s_ialtitude, PACKAGE='iris')
  
}

attr(`extended_header_v1_ialtitude_set`, 'returnType') = 'void'
attr(`extended_header_v1_ialtitude_set`, "inputTypes") = c('_p_extended_header_v1', '_p_short')
class(`extended_header_v1_ialtitude_set`) = c("SWIGFunction", class('extended_header_v1_ialtitude_set'))

# Start of extended_header_v1_ialtitude_get

`extended_header_v1_ialtitude_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ialtitude_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`extended_header_v1_ialtitude_get`, 'returnType') = '_p_short'
attr(`extended_header_v1_ialtitude_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ialtitude_get`) = c("SWIGFunction", class('extended_header_v1_ialtitude_get'))

# Start of extended_header_v1_ivel_east_set

`extended_header_v1_ivel_east_set` = function(self, s_ivel_east)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_east = coerceIfNotSubclass(s_ivel_east, "_p_short") 
  .Call('R_swig_extended_header_v1_ivel_east_set', self, s_ivel_east, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_east_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_east_set`, "inputTypes") = c('_p_extended_header_v1', '_p_short')
class(`extended_header_v1_ivel_east_set`) = c("SWIGFunction", class('extended_header_v1_ivel_east_set'))

# Start of extended_header_v1_ivel_east_get

`extended_header_v1_ivel_east_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_east_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_east_get`, 'returnType') = '_p_short'
attr(`extended_header_v1_ivel_east_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_east_get`) = c("SWIGFunction", class('extended_header_v1_ivel_east_get'))

# Start of extended_header_v1_ivel_north_set

`extended_header_v1_ivel_north_set` = function(self, s_ivel_north)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_north = coerceIfNotSubclass(s_ivel_north, "_p_short") 
  .Call('R_swig_extended_header_v1_ivel_north_set', self, s_ivel_north, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_north_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_north_set`, "inputTypes") = c('_p_extended_header_v1', '_p_short')
class(`extended_header_v1_ivel_north_set`) = c("SWIGFunction", class('extended_header_v1_ivel_north_set'))

# Start of extended_header_v1_ivel_north_get

`extended_header_v1_ivel_north_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_north_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_north_get`, 'returnType') = '_p_short'
attr(`extended_header_v1_ivel_north_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_north_get`) = c("SWIGFunction", class('extended_header_v1_ivel_north_get'))

# Start of extended_header_v1_iupdate_age_set

`extended_header_v1_iupdate_age_set` = function(self, s_iupdate_age)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_iupdate_age = as.integer(s_iupdate_age) 
  
  if(length(s_iupdate_age) > 1) {
    Rf_warning("using only the first element of s_iupdate_age")
  }
  
  .Call('R_swig_extended_header_v1_iupdate_age_set', self, s_iupdate_age, PACKAGE='iris')
  
}

attr(`extended_header_v1_iupdate_age_set`, 'returnType') = 'void'
attr(`extended_header_v1_iupdate_age_set`, "inputTypes") = c('_p_extended_header_v1', 'numeric')
class(`extended_header_v1_iupdate_age_set`) = c("SWIGFunction", class('extended_header_v1_iupdate_age_set'))

# Start of extended_header_v1_iupdate_age_get

`extended_header_v1_iupdate_age_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  .Call('R_swig_extended_header_v1_iupdate_age_get', self, as.logical(.copy), PACKAGE='iris')
  
}

attr(`extended_header_v1_iupdate_age_get`, 'returnType') = 'numeric'
attr(`extended_header_v1_iupdate_age_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_iupdate_age_get`) = c("SWIGFunction", class('extended_header_v1_iupdate_age_get'))

# Start of extended_header_v1_ivel_up_set

`extended_header_v1_ivel_up_set` = function(self, s_ivel_up)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_up = coerceIfNotSubclass(s_ivel_up, "_p_short") 
  .Call('R_swig_extended_header_v1_ivel_up_set', self, s_ivel_up, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_up_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_up_set`, "inputTypes") = c('_p_extended_header_v1', '_p_short')
class(`extended_header_v1_ivel_up_set`) = c("SWIGFunction", class('extended_header_v1_ivel_up_set'))

# Start of extended_header_v1_ivel_up_get

`extended_header_v1_ivel_up_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_up_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_up_get`, 'returnType') = '_p_short'
attr(`extended_header_v1_ivel_up_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_up_get`) = c("SWIGFunction", class('extended_header_v1_ivel_up_get'))

# Start of extended_header_v1_iflag_set

`extended_header_v1_iflag_set` = function(self, s_iflag)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_iflag = coerceIfNotSubclass(s_iflag, "_p_unsigned_short") 
  .Call('R_swig_extended_header_v1_iflag_set', self, s_iflag, PACKAGE='iris')
  
}

attr(`extended_header_v1_iflag_set`, 'returnType') = 'void'
attr(`extended_header_v1_iflag_set`, "inputTypes") = c('_p_extended_header_v1', '_p_unsigned_short')
class(`extended_header_v1_iflag_set`) = c("SWIGFunction", class('extended_header_v1_iflag_set'))

# Start of extended_header_v1_iflag_get

`extended_header_v1_iflag_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_iflag_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`extended_header_v1_iflag_get`, 'returnType') = '_p_unsigned_short'
attr(`extended_header_v1_iflag_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_iflag_get`) = c("SWIGFunction", class('extended_header_v1_iflag_get'))

# Start of extended_header_v1_ivel_correction_set

`extended_header_v1_ivel_correction_set` = function(self, s_ivel_correction)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  s_ivel_correction = coerceIfNotSubclass(s_ivel_correction, "_p_short") 
  .Call('R_swig_extended_header_v1_ivel_correction_set', self, s_ivel_correction, PACKAGE='iris')
  
}

attr(`extended_header_v1_ivel_correction_set`, 'returnType') = 'void'
attr(`extended_header_v1_ivel_correction_set`, "inputTypes") = c('_p_extended_header_v1', '_p_short')
class(`extended_header_v1_ivel_correction_set`) = c("SWIGFunction", class('extended_header_v1_ivel_correction_set'))

# Start of extended_header_v1_ivel_correction_get

`extended_header_v1_ivel_correction_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  ans = .Call('R_swig_extended_header_v1_ivel_correction_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_short"
  
  ans
  
}

attr(`extended_header_v1_ivel_correction_get`, 'returnType') = '_p_short'
attr(`extended_header_v1_ivel_correction_get`, "inputTypes") = c('_p_extended_header_v1')
class(`extended_header_v1_ivel_correction_get`) = c("SWIGFunction", class('extended_header_v1_ivel_correction_get'))

# Start of new_extended_header_v1

`extended_header_v1` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_extended_header_v1', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_extended_header_v1"
  
  ans
  
}

attr(`extended_header_v1`, 'returnType') = '_p_extended_header_v1'
class(`extended_header_v1`) = c("SWIGFunction", class('extended_header_v1'))

# Start of delete_extended_header_v1

`delete_extended_header_v1` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_extended_header_v1") 
  .Call('R_swig_delete_extended_header_v1', self, PACKAGE='iris')
  
}

attr(`delete_extended_header_v1`, 'returnType') = 'void'
attr(`delete_extended_header_v1`, "inputTypes") = c('_p_extended_header_v1')
class(`delete_extended_header_v1`) = c("SWIGFunction", class('delete_extended_header_v1'))

# Start of accessor method for extended_header_v1
setMethod('$', '_p_extended_header_v1', function(x, name)

{
  accessorFuns = list('itimems' = extended_header_v1_itimems_get, 'icallevel' = extended_header_v1_icallevel_get, 'iaz' = extended_header_v1_iaz_get, 'iel' = extended_header_v1_iel_get, 'itrain' = extended_header_v1_itrain_get, 'ielor' = extended_header_v1_ielor_get, 'ipitch' = extended_header_v1_ipitch_get, 'iroll' = extended_header_v1_iroll_get, 'iheading' = extended_header_v1_iheading_get, 'ivel_az' = extended_header_v1_ivel_az_get, 'ivel_el' = extended_header_v1_ivel_el_get, 'ivel_pitch' = extended_header_v1_ivel_pitch_get, 'ivel_roll' = extended_header_v1_ivel_roll_get, 'ilatitude' = extended_header_v1_ilatitude_get, 'ilongitude' = extended_header_v1_ilongitude_get, 'ivel_heading' = extended_header_v1_ivel_heading_get, 'ialtitude' = extended_header_v1_ialtitude_get, 'ivel_east' = extended_header_v1_ivel_east_get, 'ivel_north' = extended_header_v1_ivel_north_get, 'iupdate_age' = extended_header_v1_iupdate_age_get, 'ivel_up' = extended_header_v1_ivel_up_get, 'iflag' = extended_header_v1_iflag_get, 'ivel_correction' = extended_header_v1_ivel_correction_get)
  vaccessors = c('itimems', 'icallevel', 'iaz', 'iel', 'itrain', 'ielor', 'ipitch', 'iroll', 'iheading', 'ivel_az', 'ivel_el', 'ivel_pitch', 'ivel_roll', 'ilatitude', 'ilongitude', 'ivel_heading', 'ialtitude', 'ivel_east', 'ivel_north', 'iupdate_age', 'ivel_up', 'iflag', 'ivel_correction')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for extended_header_v1
# Start of accessor method for extended_header_v1
setMethod('$<-', '_p_extended_header_v1', function(x, name, value)

{
  accessorFuns = list('itimems' = extended_header_v1_itimems_set, 'icallevel' = extended_header_v1_icallevel_set, 'iaz' = extended_header_v1_iaz_set, 'iel' = extended_header_v1_iel_set, 'itrain' = extended_header_v1_itrain_set, 'ielor' = extended_header_v1_ielor_set, 'ipitch' = extended_header_v1_ipitch_set, 'iroll' = extended_header_v1_iroll_set, 'iheading' = extended_header_v1_iheading_set, 'ivel_az' = extended_header_v1_ivel_az_set, 'ivel_el' = extended_header_v1_ivel_el_set, 'ivel_pitch' = extended_header_v1_ivel_pitch_set, 'ivel_roll' = extended_header_v1_ivel_roll_set, 'ilatitude' = extended_header_v1_ilatitude_set, 'ilongitude' = extended_header_v1_ilongitude_set, 'ivel_heading' = extended_header_v1_ivel_heading_set, 'ialtitude' = extended_header_v1_ialtitude_set, 'ivel_east' = extended_header_v1_ivel_east_set, 'ivel_north' = extended_header_v1_ivel_north_set, 'iupdate_age' = extended_header_v1_iupdate_age_set, 'ivel_up' = extended_header_v1_ivel_up_set, 'iflag' = extended_header_v1_iflag_set, 'ivel_correction' = extended_header_v1_ivel_correction_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_extended_header_v1', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('itimems' = extended_header_v1_itimems_set, 'icallevel' = extended_header_v1_icallevel_set, 'iaz' = extended_header_v1_iaz_set, 'iel' = extended_header_v1_iel_set, 'itrain' = extended_header_v1_itrain_set, 'ielor' = extended_header_v1_ielor_set, 'ipitch' = extended_header_v1_ipitch_set, 'iroll' = extended_header_v1_iroll_set, 'iheading' = extended_header_v1_iheading_set, 'ivel_az' = extended_header_v1_ivel_az_set, 'ivel_el' = extended_header_v1_ivel_el_set, 'ivel_pitch' = extended_header_v1_ivel_pitch_set, 'ivel_roll' = extended_header_v1_ivel_roll_set, 'ilatitude' = extended_header_v1_ilatitude_set, 'ilongitude' = extended_header_v1_ilongitude_set, 'ivel_heading' = extended_header_v1_ivel_heading_set, 'ialtitude' = extended_header_v1_ialtitude_set, 'ivel_east' = extended_header_v1_ivel_east_set, 'ivel_north' = extended_header_v1_ivel_north_set, 'iupdate_age' = extended_header_v1_iupdate_age_set, 'ivel_up' = extended_header_v1_ivel_up_set, 'iflag' = extended_header_v1_iflag_set, 'ivel_correction' = extended_header_v1_ivel_correction_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for extended_header_v1
setMethod('delete', '_p_extended_header_v1', function(obj) {delete_extended_header_v1(obj)})
# Start definition of copy functions & methods for extended_header_v1
CopyToR_extended_header_v1 = function(value, obj = new("extended_header_v1"))
{
  obj@itimems = value$itimems
  obj@ilatitude = value$ilatitude
  obj@ilongitude = value$ilongitude
  obj@iupdate_age = value$iupdate_age
  obj
}



CopyToC_extended_header_v1 = function(value, obj)
{
  obj$itimems = value@itimems
  obj$ilatitude = value@ilatitude
  obj$ilongitude = value@ilongitude
  obj$iupdate_age = value@iupdate_age
  obj
}



# Start definition of copy methods for extended_header_v1
setMethod('copyToR', '_p_extended_header_v1', CopyToR_extended_header_v1)
setMethod('copyToC', 'extended_header_v1', CopyToC_extended_header_v1)

# End definition of copy methods for extended_header_v1
# End definition of copy functions & methods for extended_header_v1
# Start of ppp_time_series_iits_set

`ppp_time_series_iits_set` = function(self, s_iits)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  s_iits = coerceIfNotSubclass(s_iits, "_p_unsigned_char") 
  .Call('R_swig_ppp_time_series_iits_set', self, s_iits, PACKAGE='iris')
  
}

attr(`ppp_time_series_iits_set`, 'returnType') = 'void'
attr(`ppp_time_series_iits_set`, "inputTypes") = c('_p_ppp_time_series', '_p_unsigned_char')
class(`ppp_time_series_iits_set`) = c("SWIGFunction", class('ppp_time_series_iits_set'))

# Start of ppp_time_series_iits_get

`ppp_time_series_iits_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  ans = .Call('R_swig_ppp_time_series_iits_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`ppp_time_series_iits_get`, 'returnType') = '_p_unsigned_char'
attr(`ppp_time_series_iits_get`, "inputTypes") = c('_p_ppp_time_series')
class(`ppp_time_series_iits_get`) = c("SWIGFunction", class('ppp_time_series_iits_get'))

# Start of ppp_time_series_iqts_set

`ppp_time_series_iqts_set` = function(self, s_iqts)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  s_iqts = coerceIfNotSubclass(s_iqts, "_p_unsigned_char") 
  .Call('R_swig_ppp_time_series_iqts_set', self, s_iqts, PACKAGE='iris')
  
}

attr(`ppp_time_series_iqts_set`, 'returnType') = 'void'
attr(`ppp_time_series_iqts_set`, "inputTypes") = c('_p_ppp_time_series', '_p_unsigned_char')
class(`ppp_time_series_iqts_set`) = c("SWIGFunction", class('ppp_time_series_iqts_set'))

# Start of ppp_time_series_iqts_get

`ppp_time_series_iqts_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  ans = .Call('R_swig_ppp_time_series_iqts_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`ppp_time_series_iqts_get`, 'returnType') = '_p_unsigned_char'
attr(`ppp_time_series_iqts_get`, "inputTypes") = c('_p_ppp_time_series')
class(`ppp_time_series_iqts_get`) = c("SWIGFunction", class('ppp_time_series_iqts_get'))

# Start of ppp_time_series_ilts_set

`ppp_time_series_ilts_set` = function(self, s_ilts)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  s_ilts = coerceIfNotSubclass(s_ilts, "_p_unsigned_char") 
  .Call('R_swig_ppp_time_series_ilts_set', self, s_ilts, PACKAGE='iris')
  
}

attr(`ppp_time_series_ilts_set`, 'returnType') = 'void'
attr(`ppp_time_series_ilts_set`, "inputTypes") = c('_p_ppp_time_series', '_p_unsigned_char')
class(`ppp_time_series_ilts_set`) = c("SWIGFunction", class('ppp_time_series_ilts_set'))

# Start of ppp_time_series_ilts_get

`ppp_time_series_ilts_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  ans = .Call('R_swig_ppp_time_series_ilts_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`ppp_time_series_ilts_get`, 'returnType') = '_p_unsigned_char'
attr(`ppp_time_series_ilts_get`, "inputTypes") = c('_p_ppp_time_series')
class(`ppp_time_series_ilts_get`) = c("SWIGFunction", class('ppp_time_series_ilts_get'))

# Start of ppp_time_series_izero_set

`ppp_time_series_izero_set` = function(self, s_izero)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  s_izero = coerceIfNotSubclass(s_izero, "_p_unsigned_char") 
  .Call('R_swig_ppp_time_series_izero_set', self, s_izero, PACKAGE='iris')
  
}

attr(`ppp_time_series_izero_set`, 'returnType') = 'void'
attr(`ppp_time_series_izero_set`, "inputTypes") = c('_p_ppp_time_series', '_p_unsigned_char')
class(`ppp_time_series_izero_set`) = c("SWIGFunction", class('ppp_time_series_izero_set'))

# Start of ppp_time_series_izero_get

`ppp_time_series_izero_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  ans = .Call('R_swig_ppp_time_series_izero_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`ppp_time_series_izero_get`, 'returnType') = '_p_unsigned_char'
attr(`ppp_time_series_izero_get`, "inputTypes") = c('_p_ppp_time_series')
class(`ppp_time_series_izero_get`) = c("SWIGFunction", class('ppp_time_series_izero_get'))

# Start of new_ppp_time_series

`ppp_time_series` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_ppp_time_series', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ppp_time_series"
  
  ans
  
}

attr(`ppp_time_series`, 'returnType') = '_p_ppp_time_series'
class(`ppp_time_series`) = c("SWIGFunction", class('ppp_time_series'))

# Start of delete_ppp_time_series

`delete_ppp_time_series` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ppp_time_series") 
  .Call('R_swig_delete_ppp_time_series', self, PACKAGE='iris')
  
}

attr(`delete_ppp_time_series`, 'returnType') = 'void'
attr(`delete_ppp_time_series`, "inputTypes") = c('_p_ppp_time_series')
class(`delete_ppp_time_series`) = c("SWIGFunction", class('delete_ppp_time_series'))

# Start of accessor method for ppp_time_series
setMethod('$', '_p_ppp_time_series', function(x, name)

{
  accessorFuns = list('iits' = ppp_time_series_iits_get, 'iqts' = ppp_time_series_iqts_get, 'ilts' = ppp_time_series_ilts_get, 'izero' = ppp_time_series_izero_get)
  vaccessors = c('iits', 'iqts', 'ilts', 'izero')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ppp_time_series
# Start of accessor method for ppp_time_series
setMethod('$<-', '_p_ppp_time_series', function(x, name, value)

{
  accessorFuns = list('iits' = ppp_time_series_iits_set, 'iqts' = ppp_time_series_iqts_set, 'ilts' = ppp_time_series_ilts_set, 'izero' = ppp_time_series_izero_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ppp_time_series', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iits' = ppp_time_series_iits_set, 'iqts' = ppp_time_series_iqts_set, 'ilts' = ppp_time_series_ilts_set, 'izero' = ppp_time_series_izero_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ppp_time_series
setMethod('delete', '_p_ppp_time_series', function(obj) {delete_ppp_time_series(obj)})
# Start definition of copy functions & methods for ppp_time_series
CopyToR_ppp_time_series = function(value, obj = new("ppp_time_series"))
{
  obj
}



CopyToC_ppp_time_series = function(value, obj)
{
  obj
}



# Start definition of copy methods for ppp_time_series
setMethod('copyToR', '_p_ppp_time_series', CopyToR_ppp_time_series)
setMethod('copyToC', 'ppp_time_series', CopyToC_ppp_time_series)

# End definition of copy methods for ppp_time_series
# End definition of copy functions & methods for ppp_time_series
# Start of ray_data_iData1_set

`ray_data_iData1_set` = function(self, s_iData1)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  
  if(is.list(s_iData1))
  assert(all(sapply(s_iData1, class) == "_p_unsigned_char"))     
  
  
#  assert(length(s_iData1) >= (3072))
  
  .Call('R_swig_ray_data_iData1_set', self, s_iData1, PACKAGE='iris')
  
}

attr(`ray_data_iData1_set`, 'returnType') = 'void'
attr(`ray_data_iData1_set`, "inputTypes") = c('_p_ray_data', '_p_unsigned_char')
class(`ray_data_iData1_set`) = c("SWIGFunction", class('ray_data_iData1_set'))

# Start of ray_data_iData1_get

`ray_data_iData1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  ans = .Call('R_swig_ray_data_iData1_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_char"
  
  ans
  
}

attr(`ray_data_iData1_get`, 'returnType') = '_p_unsigned_char'
attr(`ray_data_iData1_get`, "inputTypes") = c('_p_ray_data')
class(`ray_data_iData1_get`) = c("SWIGFunction", class('ray_data_iData1_get'))

# Start of ray_data_iData2_set

`ray_data_iData2_set` = function(self, s_iData2)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  
  if(is.list(s_iData2))
  assert(all(sapply(s_iData2, class) == "_p_unsigned_short"))     
  
  
#  assert(length(s_iData2) >= (3072))
  
  .Call('R_swig_ray_data_iData2_set', self, s_iData2, PACKAGE='iris')
  
}

attr(`ray_data_iData2_set`, 'returnType') = 'void'
attr(`ray_data_iData2_set`, "inputTypes") = c('_p_ray_data', '_p_unsigned_short')
class(`ray_data_iData2_set`) = c("SWIGFunction", class('ray_data_iData2_set'))

# Start of ray_data_iData2_get

`ray_data_iData2_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  ans = .Call('R_swig_ray_data_iData2_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_unsigned_short"
  
  ans
  
}

attr(`ray_data_iData2_get`, 'returnType') = '_p_unsigned_short'
attr(`ray_data_iData2_get`, "inputTypes") = c('_p_ray_data')
class(`ray_data_iData2_get`) = c("SWIGFunction", class('ray_data_iData2_get'))

# Start of ray_data_xh0_set

`ray_data_xh0_set` = function(self, s_xh0)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  s_xh0 = coerceIfNotSubclass(s_xh0, "_p_extended_header_v0") 
  .Call('R_swig_ray_data_xh0_set', self, s_xh0, PACKAGE='iris')
  
}

attr(`ray_data_xh0_set`, 'returnType') = 'void'
attr(`ray_data_xh0_set`, "inputTypes") = c('_p_ray_data', '_p_extended_header_v0')
class(`ray_data_xh0_set`) = c("SWIGFunction", class('ray_data_xh0_set'))

# Start of ray_data_xh0_get

`ray_data_xh0_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  ans = .Call('R_swig_ray_data_xh0_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_extended_header_v0"
  
  ans
  
}

attr(`ray_data_xh0_get`, 'returnType') = '_p_extended_header_v0'
attr(`ray_data_xh0_get`, "inputTypes") = c('_p_ray_data')
class(`ray_data_xh0_get`) = c("SWIGFunction", class('ray_data_xh0_get'))

# Start of ray_data_xh1_set

`ray_data_xh1_set` = function(self, s_xh1)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  s_xh1 = coerceIfNotSubclass(s_xh1, "_p_extended_header_v1") 
  .Call('R_swig_ray_data_xh1_set', self, s_xh1, PACKAGE='iris')
  
}

attr(`ray_data_xh1_set`, 'returnType') = 'void'
attr(`ray_data_xh1_set`, "inputTypes") = c('_p_ray_data', '_p_extended_header_v1')
class(`ray_data_xh1_set`) = c("SWIGFunction", class('ray_data_xh1_set'))

# Start of ray_data_xh1_get

`ray_data_xh1_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  ans = .Call('R_swig_ray_data_xh1_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_extended_header_v1"
  
  ans
  
}

attr(`ray_data_xh1_get`, 'returnType') = '_p_extended_header_v1'
attr(`ray_data_xh1_get`, "inputTypes") = c('_p_ray_data')
class(`ray_data_xh1_get`) = c("SWIGFunction", class('ray_data_xh1_get'))

# Start of new_ray_data

`ray_data` = function()
{
  ans = .Call('R_swig_new_ray_data', PACKAGE='iris')
  class(ans) <- "_p_ray_data"
  
  ans
  
}

attr(`ray_data`, 'returnType') = '_p_ray_data'
class(`ray_data`) = c("SWIGFunction", class('ray_data'))

# Start of delete_ray_data

`delete_ray_data` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_ray_data") 
  .Call('R_swig_delete_ray_data', self, PACKAGE='iris')
  
}

attr(`delete_ray_data`, 'returnType') = 'void'
attr(`delete_ray_data`, "inputTypes") = c('_p_ray_data')
class(`delete_ray_data`) = c("SWIGFunction", class('delete_ray_data'))

# Start of accessor method for ray_data
setMethod('$', '_p_ray_data', function(x, name)

{
  accessorFuns = list('iData1' = ray_data_iData1_get, 'iData2' = ray_data_iData2_get, 'xh0' = ray_data_xh0_get, 'xh1' = ray_data_xh1_get)
  vaccessors = c('iData1', 'iData2', 'xh0', 'xh1')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for ray_data
# Start of accessor method for ray_data
setMethod('$<-', '_p_ray_data', function(x, name, value)

{
  accessorFuns = list('iData1' = ray_data_iData1_set, 'iData2' = ray_data_iData2_set, 'xh0' = ray_data_xh0_set, 'xh1' = ray_data_xh1_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_ray_data', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('iData1' = ray_data_iData1_set, 'iData2' = ray_data_iData2_set, 'xh0' = ray_data_xh0_set, 'xh1' = ray_data_xh1_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for ray_data
setMethod('delete', '_p_ray_data', function(obj) {delete_ray_data(obj)})
# Start of data_ray_hdr_set

`data_ray_hdr_set` = function(self, s_hdr)
{
  self = coerceIfNotSubclass(self, "_p_data_ray") 
  s_hdr = coerceIfNotSubclass(s_hdr, "_p_ray_header") 
  .Call('R_swig_data_ray_hdr_set', self, s_hdr, PACKAGE='iris')
  
}

attr(`data_ray_hdr_set`, 'returnType') = 'void'
attr(`data_ray_hdr_set`, "inputTypes") = c('_p_data_ray', '_p_ray_header')
class(`data_ray_hdr_set`) = c("SWIGFunction", class('data_ray_hdr_set'))

# Start of data_ray_hdr_get

`data_ray_hdr_get` = function(self, .copy = FALSE)
{
  self = coerceIfNotSubclass(self, "_p_data_ray") 
  ans = .Call('R_swig_data_ray_hdr_get', self, as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_ray_header"
  
  ans
  
}

attr(`data_ray_hdr_get`, 'returnType') = '_p_ray_header'
attr(`data_ray_hdr_get`, "inputTypes") = c('_p_data_ray')
class(`data_ray_hdr_get`) = c("SWIGFunction", class('data_ray_hdr_get'))

# Start of data_ray_data_set

`data_ray_data_set` = function(self, s_data)
{
  self = coerceIfNotSubclass(self, "_p_data_ray") 
  s_data = coerceIfNotSubclass(s_data, "_p_ray_data") 
  .Call('R_swig_data_ray_data_set', self, s_data, PACKAGE='iris')
  
}

attr(`data_ray_data_set`, 'returnType') = 'void'
attr(`data_ray_data_set`, "inputTypes") = c('_p_data_ray', '_p_ray_data')
class(`data_ray_data_set`) = c("SWIGFunction", class('data_ray_data_set'))

# Start of data_ray_data_get

`data_ray_data_get` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_data_ray") 
  ans = .Call('R_swig_data_ray_data_get', self, PACKAGE='iris')
  class(ans) <- "_p_ray_data"
  
  ans
  
}

attr(`data_ray_data_get`, 'returnType') = '_p_ray_data'
attr(`data_ray_data_get`, "inputTypes") = c('_p_data_ray')
class(`data_ray_data_get`) = c("SWIGFunction", class('data_ray_data_get'))

# Start of new_data_ray

`data_ray` = function(.copy = FALSE)
{
  ans = .Call('R_swig_new_data_ray', as.logical(.copy), PACKAGE='iris')
  class(ans) <- "_p_data_ray"
  
  ans
  
}

attr(`data_ray`, 'returnType') = '_p_data_ray'
class(`data_ray`) = c("SWIGFunction", class('data_ray'))

# Start of delete_data_ray

`delete_data_ray` = function(self)
{
  self = coerceIfNotSubclass(self, "_p_data_ray") 
  .Call('R_swig_delete_data_ray', self, PACKAGE='iris')
  
}

attr(`delete_data_ray`, 'returnType') = 'void'
attr(`delete_data_ray`, "inputTypes") = c('_p_data_ray')
class(`delete_data_ray`) = c("SWIGFunction", class('delete_data_ray'))

# Start of accessor method for data_ray
setMethod('$', '_p_data_ray', function(x, name)

{
  accessorFuns = list('hdr' = data_ray_hdr_get, 'data' = data_ray_data_get)
  vaccessors = c('hdr', 'data')
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name))
  f = accessorFuns[[idx]]
  formals(f)[[1]] = x
  if (is.na(match(name, vaccessors))) f else f(x)
}


)
# end of accessor method for data_ray
# Start of accessor method for data_ray
setMethod('$<-', '_p_data_ray', function(x, name, value)

{
  accessorFuns = list('hdr' = data_ray_hdr_set, 'data' = data_ray_data_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
setMethod('[[<-', c('_p_data_ray', 'character'),function(x, i, j, ..., value)

{
  name = i
  accessorFuns = list('hdr' = data_ray_hdr_set, 'data' = data_ray_data_set)
  idx = pmatch(name, names(accessorFuns))
  if(is.na(idx)) 
  return(callNextMethod(x, name, value))
  f = accessorFuns[[idx]]
  f(x, value)
  x
}


)
# end of accessor method for data_ray
setMethod('delete', '_p_data_ray', function(obj) {delete_data_ray(obj)})
# Start definition of copy functions & methods for data_ray
CopyToR_data_ray = function(value, obj = new("data_ray"))
{
  obj
}



CopyToC_data_ray = function(value, obj)
{
  obj
}



# Start definition of copy methods for data_ray
setMethod('copyToR', '_p_data_ray', CopyToR_data_ray)
setMethod('copyToC', 'data_ray', CopyToC_data_ray)

# End definition of copy methods for data_ray
# End definition of copy functions & methods for data_ray

