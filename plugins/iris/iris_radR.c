/* svn $Id: iris_radR.c 60 2008-11-11 13:49:31Z john $

   radR : an R-based platform for acquisition and analysis of radar data
   Copyright (C) 2006, 2007 John Brzustowski        

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

********************************************************************************

   iris_radR.c: read raw iris data files.

   We handle only the specific kind generated by Environment Canada's
   weather radar network, as described here:

     http://citeseer.ist.psu.edu/430679.html for a full description.

   There are three types of raw product files produced:

   CONVOL:  reflectivity volume scan
            PRF: 1200  Plen: 2us
	    One product: 
            1: DB_DBT: Total power: dbZ = (x-64)/2, 0 means NA; 255 = not scanned
	Bin range: 999.6093 497.7778   Number of bins: 48...256

   DOPVOL1_A/B/C (alternating PRFs between 890 and 1100 Hz; Plen 800ns; A,B,C are different elevation angles)
	Bin range: 497.7778   Number of bins: 225

   DOPVOL2 (constant PRF of 1200 Hz; Plen ?)
	Bin range: 997.7876   Number of bins: 226

   All DOPVOL files have four interleaved products each:

	1: DB_DBT: Total power;  dbZ = (x-64)/2; 0 = no data; 255 = not scanned
	2: DB_DBZ: Clutter-corrected Reflectivity; dbZ = (x-64)/2; 0 = no data; 255 = not scanned
	3: DB_VEL: Velocity; vel (m/s) = (x-128) * Nyquist / 127; 0 = unavailable; Nyquist = wavelength * PRF / 4 * K,
	          where K is 3 for the 4:3 double PRF mode, and 1 for the constant PRF mode.
	4: DB_WIDTH: Width; spectrum width  = x/256 * unambiguous velocity; 0=no data; 255=not scanned
	            Is this the standard error of the velocity estimate?




   The wavelength for these radars is 5.32cm

   Further assumptions:

   - each product in a sweep has the same number of rays, and they are stored interleaved
   - data for each bin in a ray is 8 bits wide
   - all bins in all rays for all product in a sweep have the same bin_range (it
     can vary from sweep to sweep)
   - within a product and within a sweep, the number of bins in a ray must be constant.
     However, different products within a sweep may have different numbers of bins,
     and the same product may have a different number of bins in different sweeps.

     FIXME: in fact, isn't bin_range constant within an entire raw product file,
     since we're calculating it from a subfield of the product header??
*/
 
#include "iris.h"
#include "radRmodule.h"
#include <tar.h>

#include <time.h>

// the maximum number of products per sweep; this is currently 4 for EnvCan radar

#define MAX_PRODUCTS_PER_SWEEP 4

double ymds_time_to_ts(struct ymds_time *y) {
  // make a double timestamp (seconds since the epoch)
  // from an iris ymds_time structure

  struct tm tm;
  time_t t;

  tm.tm_year = y->iyear - 1900; // origin 0=1900
  tm.tm_mon = y->imon - 1; // origin 0=January
  tm.tm_mday = y->iday; // origin 1=1st of month
  tm.tm_hour = y->isec / 3600; 
  tm.tm_min = (y->isec % 3600) / 60;
  tm.tm_sec = y->isec % 60;
  tm.tm_isdst = y->imills & (1 << 10); // bit 10 flags that time is in daylight savings time
  t = mktime (&tm);
  return (y->imills & 0x3ff) / 1000.0 + (double) t; // milliseconds are in lowest 10 bits of y->imills
}


void *get_object_as_ptr(SEXP ptr, int argno) {
  void *p = NULL;
  if (TYPEOF(ptr) == RAWSXP)
    p = (void *) RAW_POINTER(ptr);
  else if (TYPEOF(ptr) == EXTPTRSXP)
    p = (void *) EXTPTR_PTR(ptr);
  else
    Rf_error("Argument %d must be an EXTPTR or RAW object", argno);
  return p;
}

/* symbol table entries for some attribute names */

SEXP lab_az_lo, lab_az_hi, lab_el_lo, lab_el_hi, lab_ts, lab_bin_range;

/* 
   static buffer of maximum possible size for a ray (header + data);
   we decompress raw data into this
*/
static struct data_ray drbuf;

SEXP 
get_raw_sweeps (SEXP dataptr) 
{
  /* 
     Return the raw ray data for a set of sweeps.

     dataptr: EXTPTRSXP or RAWSXP that points to the start of a raw product file
              (i.e. points to a struct product_hdr)

     RETURNS: VECSXP (R list) with n elements, one for each sweep.
              Each element is a list of matrices.
	      The list has these attributes:
		  "az_lo"	: REALSXP angles of ray start azimuth
		  "az_hi"	: REALSXP angles of ray end azimuth
		  "el_lo"	: REALSXP angles of ray start elevation
		  "el_hi"	: REALSXP angles of ray end elevation
		  "ts"		: REALSXP timestamps of rays
		  "bin_range"	: REALSXP range covered by a bin, in metres
	      Each matrix in the list is an INTSXP with each ray as a column.
  */

  char *nextp; /* pointer to start of next record */
  short *p; /* pointer to current location */
  short *dst; /* pointer to data ray buffer destination (for uncompressing) */
  int *out[MAX_PRODUCTS_PER_SWEEP];      /* pointer to output array */
  int i, j;
  int ns, nr = 0, np; /* numbers of sweeps, rays per sweep, ingest products */
  int nb[MAX_PRODUCTS_PER_SWEEP]; /* number of bins per ray by product */
  int nbp; /* number of bins in current product */
  int is, ir, ip; /* indexes of current sweep, ray, and product numbers */
  int mode; /* if positive, we're copying data; if zero, we're looking for a code */
  struct ingest_data_header *idh, *first_idh = NULL;
  struct ingest_header *ih;
  struct dsp_data_mask *ddm;
  struct product_hdr *phd;

  SEXP rv;
  SEXP matlist = NULL;
  SEXP az_lo = NULL, az_hi = NULL, el_lo = NULL, el_hi = NULL, ts = NULL, bin_range = NULL;
  SEXP mat[MAX_PRODUCTS_PER_SWEEP];

  nextp = (char *) get_object_as_ptr(dataptr, 1);
  phd = (struct product_hdr *) nextp;
  /* skip over product header */

  nextp += TAPE_RECORD_LEN;

  /* get number of sweeps, dsp data mask then skip over header */

  ih = (struct ingest_header *) nextp;
  ns = ih -> icf.isweeps_done;
  ddm = & ih -> tcf.dsp.DataMask;

  /* count the number of "on" bits in the first word of the data mask;
     This is the number of products.  FIXME: deal properly with other
     words in the data mask. */

  for (np = 0, i = sizeof(ddm->iWord0) * 8, j = ddm->iWord0; i > 0; --i) {
    np += j & 1;
    j >>= 1;
  }  

  nextp += TAPE_RECORD_LEN;

  /* allocate return list */

  PROTECT(rv = allocVector(VECSXP, ns));
  
  /* scan through remaining part of file */

  dst = (short *) & drbuf;
  mode = 0;

  for (p = (short *) nextp, is = ir = 0; is < ns ;++p ) {

    if (p == (short *) nextp) {
      /* we've reached the end of the record, move pointers forward */
#ifdef RADR_DEBUG
      printf("  ray: %d\n",  ((struct raw_prod_bhdr *)p)->iray_num);
#endif
      p = (short *) (((char *) p) + sizeof(struct raw_prod_bhdr)); /* skip raw_prod_bhdr */
      nextp += TAPE_RECORD_LEN; /* point to start of next record */
      if (ir == 0) {
	/* we're starting a new sweep
	   get and skip over the ingest data header(s) */
	nr = 0;
	first_idh = (struct ingest_data_header *) p;  /* remember where the first ingest_data_header is */
	for (i = 0; i < np; ++i) {
	  idh = (struct ingest_data_header *) p;
	  p = (short *) (idh + 1);
	  if (idh->ibits_bin > 8)
	    Rf_error("Can't handle data with %d bits per sample.", idh->ibits_bin);
	  /* get the number of rays for this sweep, for all products */
	  /* use irtotl, not iwritn, since there is at least a header written
	     for each ray. */
	  nr += idh->irtotl;
	}
      }
    }

    if (mode) {
      /* we're copying words into the data ray buffer */
      *dst++ = *p;
      --mode;
    } else {
      /* we're at a "compression" code */
      if (*p > 2) {
	/* skip *p zeroes */
	memset(dst, 0, (*p) * sizeof(short));
	dst += *p;
      } else if (*p < 0) {
	/* set mode to indicate we're to copy over *p (ignoring high bit) data words */
	mode = (*p) & 0x7fff;
      } else if (*p == 1) {
	/* we've finished "uncompressing" this ray, record its info */

	ip = ir % np; /* which product this ray belongs to */

	if (ir < np) {
	  /* this is the first ray for a product in this sweep; get the number of bins and allocate the matrix for this sweep */
	  nb[ir] = drbuf.hdr.ibincount;
	  PROTECT(mat[ip] = allocMatrix(INTSXP, nb[ip], nr / np));
	  out[ip] = INTEGER(mat[ip]);
	  if (ir == 0) {
	    // this is the first ray in this sweep, so allocate the list of product matrices
	    PROTECT(matlist = allocVector(VECSXP, np));
	    setAttrib(matlist, lab_az_lo,	 PROTECT(az_lo 		= allocVector(REALSXP, nr / np)));
	    setAttrib(matlist, lab_az_hi,	 PROTECT(az_hi 		= allocVector(REALSXP, nr / np)));
	    setAttrib(matlist, lab_el_lo,	 PROTECT(el_lo 		= allocVector(REALSXP, nr / np)));
	    setAttrib(matlist, lab_el_hi,	 PROTECT(el_hi 		= allocVector(REALSXP, nr / np)));
	    setAttrib(matlist, lab_ts,		 PROTECT(ts    		= allocVector(REALSXP, 1)));
	    /* get the timestamp for this sweep */
	    REAL(ts)[0] = ymds_time_to_ts (&first_idh->time); 
	    setAttrib(matlist, lab_bin_range,	 PROTECT(bin_range 	= allocVector(REALSXP, 1)));
	    /* compute the bin range; the values are in cm and we convert to m */
	    REAL(bin_range)[0] = (phd->end.ibin_last - phd->end.ibin_first) / (100.0 * phd->end.ibin_out_num);
	    SET_VECTOR_ELT(rv, is, matlist);
	    UNPROTECT(7); /* these are now protected by rv */ 
	  }
	  SET_VECTOR_ELT(matlist, ip, mat[ip]);
	  UNPROTECT(1);  /* mat[ip] is now protected by rv via matlist */
	}
	/* get spherical "bouding box" for this ray, converting from binary angle to radians */
#define BIN_ANGLE_2_RAD (2 * M_PI / 65536)

	if (ip == 0) {
	  /* these values are assumed to be the same for corresponding interleaved rays of all products in a sweep */
	  REAL(az_lo)[ir / np] = drbuf.hdr.iaz_start * BIN_ANGLE_2_RAD;
	  REAL(az_hi)[ir / np] = drbuf.hdr.iaz_end   * BIN_ANGLE_2_RAD;
	  REAL(el_lo)[ir / np] = drbuf.hdr.iel_start * BIN_ANGLE_2_RAD;
	  REAL(el_hi)[ir / np] = drbuf.hdr.iel_end   * BIN_ANGLE_2_RAD;
	}

	/* copy bin values */

#ifdef RADR_DEBUG
	printf("%3d %3d %d\n", is, ir, (dst - (short *) & drbuf));
#endif
	for (i = 0, nbp = nb[ip]; i < nbp; ++i)
	  *(out[ip]++) = drbuf.data.iData1[i];
	
	/* reset start of ray decompression buffer */
	dst = (short *) & drbuf;

	/* bump up ray index */

	++ir;
	if (ir == nr) {
	  /* we've finished a sweep, so skip anything left in this record and restart the ray counter */
	  ir = 0;
	  ++is;
	  p = ((short *) nextp) - 1; /* -1 because p is incremented by the for loop */
	}
      } else if (*p == 0) {
	// nothing to do but skip this word
      }
    }
  }
  UNPROTECT(1); /* only rv was still protected; it protects everything else */
  return rv;
}


static char octal_buff[13];

SEXP
get_tar_header (SEXP ptr) {
  /* return the items of a tar file header as an R list

     ptr: EXTPTRSXP or RAWSXP whose storage is the 512-byte tar header
 
     Returns: a list with the following elements:

   Field Name	Byte Offset	Length in Bytes	Field Type
  */
#define TAR_NAME 		(p+0)
#define TAR_NAME_LEN 		100	/*		NUL-terminated if NUL fits */
#define TAR_MODE 		(p+100)
#define TAR_MODE_LEN 		8 
#define TAR_UID 		(p+108)
#define TAR_UID_LEN 		8 
#define TAR_GID 		(p+116)
#define TAR_GID_LEN 		8 
#define TAR_SIZE 		(p+124)
#define TAR_SIZE_LEN 		12 
#define TAR_MTIME 		(p+136)
#define TAR_MTIME_LEN 		12 
#define TAR_CHKSUM 		(p+148)
#define TAR_CHKSUM_LEN 		8 
#define TAR_TYPEFLAG 		(p+156)
#define TAR_TYPEFLAG_LEN 	1	/*		see below */
#define TAR_LINKNAME 		(p+157)
#define TAR_LINKNAME_LEN 	100	/*		NUL-terminated if NUL fits */
#define TAR_MAGIC 		(p+257)
#define TAR_MAGIC_LEN 		6	/*		must be TMAGIC (NUL term.) */
#define TAR_VERSION 		(p+263)
#define TAR_VERSION_LEN 	2	/*		must be TVERSION */
#define TAR_UNAME 		(p+265)
#define TAR_UNAME_LEN 		32	/*		NUL-terminated */
#define TAR_GNAME 		(p+297)
#define TAR_GNAME_LEN 		32	/*		NUL-terminated */
#define TAR_DEVMAJOR 		(p+329)
#define TAR_DEVMAJOR_LEN 	8 
#define TAR_DEVMINOR 		(p+337)
#define TAR_DEVMINOR_LEN 	8 
#define TAR_PREFIX 		(p+345)
#define TAR_PREFIX_LEN 		155	/*		NUL-terminated if NUL fits */

  char *p;
  char name_buff[256];

#define OCT2INT(p, n) ({strncpy(octal_buff, p, n); strtoll(p, NULL, 8);})

  SEXP rv;

  p = (char *) get_object_as_ptr(ptr, 1);

  /* return NULL if the entire header is zeroes; we cheat and just check the name */
  if (*TAR_NAME == '\0')
    return R_NilValue;

  PROTECT(rv = allocVector(VECSXP, 9));
  memset(name_buff, 0, sizeof(name_buff));
    if (*TAR_PREFIX) {
      strncpy(name_buff, TAR_PREFIX, TAR_PREFIX_LEN);
      strcat(name_buff, "/");
    }
    
  strncat(name_buff, TAR_NAME, TAR_NAME_LEN);
  SET_VECTOR_ELT(rv, 0, mkString(name_buff));
  SET_VECTOR_ELT(rv, 1, ScalarInteger(OCT2INT(TAR_MODE, TAR_MODE_LEN)));
  SET_VECTOR_ELT(rv, 2, ScalarInteger(OCT2INT(TAR_UID, TAR_UID_LEN)));
  SET_VECTOR_ELT(rv, 3, ScalarInteger(OCT2INT(TAR_GID, TAR_GID_LEN)));
  SET_VECTOR_ELT(rv, 4, ScalarReal(OCT2INT(TAR_SIZE, TAR_SIZE_LEN)));
  SET_VECTOR_ELT(rv, 5, ScalarReal(OCT2INT(TAR_MTIME, TAR_MTIME_LEN)));
  SET_VECTOR_ELT(rv, 6, mkString(TAR_UNAME));
  SET_VECTOR_ELT(rv, 7, mkString(TAR_GNAME));
  /* TRUE if it's a regular file, FALSE otherwise */
  SET_VECTOR_ELT(rv, 8, ScalarLogical(*TAR_TYPEFLAG == '0' || *TAR_TYPEFLAG == '\0'));
  
  UNPROTECT(1);
  return rv;
}
  

#include <R_ext/Rdynload.h>

R_CallMethodDef CallEntries[] = {
   {"get_raw_sweeps", (DL_FUNC) &get_raw_sweeps, 1},
   {"get_tar_header", (DL_FUNC) &get_tar_header, 1},
   {NULL, NULL, 0}
};

void R_init_iris_radR(DllInfo *dll) {
  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);

  R_PreserveObject (lab_az_lo 	  = install ("az_lo"));
  R_PreserveObject (lab_az_hi 	  = install ("az_hi"));
  R_PreserveObject (lab_el_lo 	  = install ("el_lo"));
  R_PreserveObject (lab_el_hi 	  = install ("el_hi"));
  R_PreserveObject (lab_ts 	  = install ("ts"));
  R_PreserveObject (lab_bin_range = install ("bin_range"));
    
}

void
R_unload_iris_radR(DllInfo *info)
{
  R_ReleaseObject (lab_az_lo);
  R_ReleaseObject (lab_az_hi);
  R_ReleaseObject (lab_el_lo);
  R_ReleaseObject (lab_el_hi);
  R_ReleaseObject (lab_ts);
  R_ReleaseObject (lab_bin_range);
}
