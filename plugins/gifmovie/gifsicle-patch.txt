Index: Makefile.in
===================================================================
--- Makefile.in	(revision 1)
+++ Makefile.in	(working copy)
@@ -670,6 +670,9 @@
 gifview:
 	@cd src && $(MAKE) gifview
 
+win2rgb:
+	@cd src && $(MAKE) win2rgb
+
 srclinks:
 	cd $(top_srcdir); sh ./sourcecheckout.sh
 
Index: src/win2rgb.c
===================================================================
--- src/win2rgb.c	(revision 0)
+++ src/win2rgb.c	(revision 4)
@@ -0,0 +1,148 @@
+/*
+  win2rgb: quickly dump a window to a simple raw file.  This file can be read by gifsicle.
+*/
+
+#include <config.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <assert.h>
+#include <errno.h>
+
+#  if defined (_WIN32) 
+#    include <windows.h>
+     typedef HWND Win_ID;
+#  else
+#    include <X11/Xlib.h>
+#    include <X11/Xutil.h>
+     typedef Window Win_ID;
+#  endif
+
+#define Error(...) {fprintf(stderr, ##__VA_ARGS__); exit(1);} 
+/* a text file header which describes the file format */
+
+static char rgb_header[] = 
+  "RGB file: after this header, contents are:\n"	\
+  "unsigned short width;\n"				\
+  "unsigned short height;\n"				\
+  "unsigned int []pixels;\n"				\
+  "Pixels are integers of the form 0xAARRGGBB\n"	\
+  "and stored row-by-row from top to bottom.\n";
+
+#define _RGB_HEADER_SIZE (sizeof(_rgb_header))
+
+void
+window_to_rgbfile(Win_ID win)
+{
+  char win_name[64];
+
+#  ifdef _WIN32
+  HWND hwnd_plot;
+  PBITMAPINFO bmhdr;
+  HDC bmdc;
+  HDC hdcr;
+  HDC hdc;
+  HBITMAP bmh;
+  BITMAP bm;
+  RECT r;
+#  else
+  Display *disp;
+  XImage *img;
+  XWindowAttributes attr;
+#  endif
+  unsigned int *pix;
+  unsigned short w, h;
+  
+#  ifdef _WIN32
+  if (win == 0)
+    if (!(win = GetDesktopWindow()))
+      Error ("could not open desktop window");
+  if (!GetWindowRect((HWND) win, &r))
+    Error("unable to get rectangle for window %xl", (unsigned int) win);
+  w = r.right - r.left;
+  h = r.bottom - r.top;
+  bmhdr = calloc(sizeof(BITMAPINFO) + 256 * sizeof(RGBQUAD), 1);
+  bmhdr->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+  bmhdr->bmiHeader.biPlanes = 1;
+  bmhdr->bmiHeader.biBitCount = 32;
+  bmhdr->bmiHeader.biCompression = BI_RGB;
+  bmhdr->bmiHeader.biSizeImage = 0;
+  bmhdr->bmiHeader.biXPelsPerMeter = 0;
+  bmhdr->bmiHeader.biYPelsPerMeter = 0;
+  bmhdr->bmiHeader.biClrUsed = 256;
+  bmhdr->bmiHeader.biWidth = w;
+  bmhdr->bmiHeader.biHeight = -h;
+  if (!(hdcr = GetDC (NULL)))
+    Error("unable to get DC for root window");
+  if (!(bmdc = CreateCompatibleDC (hdcr)))
+    Error("unable to create compatible DC for bitmap");
+  if (!(bmh = CreateDIBSection (hdc, bmhdr, DIB_RGB_COLORS, (void **) &pix, NULL, 0)))
+    Error("unable to create device independent bitmap section");
+  if (!SelectObject (bmdc, bmh))
+    Error("unable to select bitmap to its DC");
+  if (! BitBlt( bmdc,
+	  0, 0,
+	  w, h,
+	  hdcr,
+	  r.left, r.top,
+	  SRCCOPY
+		))
+    Error("unable to copy window data to bitmap");
+#  else
+
+  if (!(disp = XOpenDisplay(NULL)))
+    Error("could not open X display");
+
+  if (win == 0)
+    if (!(win = RootWindow(disp, 0)))
+      error ("could not open root window on display");
+
+  if (!(XGetWindowAttributes(disp, win, &attr)))
+    Error("could not get attributes for window %xl", (unsigned int) win);
+
+  if (!(img = XGetImage(disp, win, 0, 0, w = attr.width, h = attr.height, 0xffffffffUL, ZPixmap)))
+    Error("could not get window %xl data as Ximage", (unsigned int) win);
+
+  if (img->depth < 24)
+    Error("lazy programmer: can't handle windows with bit depth %d", img->depth);
+
+  pix = (unsigned int *) img->data;
+#  endif
+
+  fputs(rgb_header, stdout);
+
+  fwrite(&w, sizeof(w), 1, stdout);
+  fwrite(&h, sizeof(h), 1, stdout);
+  fwrite(pix, sizeof(unsigned int), w * (int) h, stdout);
+  fclose(stdout);
+
+#ifdef _WIN32
+  DeleteObject(bmh);
+  ReleaseDC(NULL, bmdc);
+  ReleaseDC(NULL, hdcr);
+  free(bmhdr);
+#else
+  XDestroyImage(img);
+  XCloseDisplay(disp);
+#endif
+}
+
+#ifdef _WIN32
+/* set the mode for stdout to binary */
+#include <fcntl.h> // _O_BINARY
+unsigned int _CRT_fmode = _O_BINARY; 
+#endif
+
+int
+main(int argc, char *argv[]) {
+  Win_ID win;
+  char c;
+
+  if (argc < 2 || 1 != sscanf(argv[1], "%lx%c", &win, &c)) {
+    puts("Usage wintorgb WINID > outfile.rgb\n" \
+	 "where WINID is a hexadecimal window id; e.g. 0xa123\n");
+    exit(1);
+  }
+  window_to_rgbfile(win);
+}

Property changes on: src/win2rgb.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/Makefile.mingw
===================================================================
--- src/Makefile.mingw	(revision 0)
+++ src/Makefile.mingw	(revision 4)
@@ -0,0 +1,479 @@
+# Makefile.in generated by automake 1.10 from Makefile.am.
+# src/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+
+pkgdatadir = $(datadir)/gifsicle
+pkglibdir = $(libdir)/gifsicle
+pkgincludedir = $(includedir)/gifsicle
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+bin_PROGRAMS = gifsicle$(EXEEXT)  gifdiff$(EXEEXT) win2rgb$(EXEEXT)
+EXTRA_PROGRAMS = gifview$(EXEEXT) gifdiff$(EXEEXT) win2rgb$(EXEEXT)
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in strerror.c
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(bindir)"
+binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(bin_PROGRAMS)
+am_gifdiff_OBJECTS = clp.$(OBJEXT) giffunc.$(OBJEXT) gifread.$(OBJEXT) \
+	gifdiff.$(OBJEXT)
+gifdiff_OBJECTS = $(am_gifdiff_OBJECTS)
+gifdiff_LDADD = $(LDADD)
+am_gifsicle_OBJECTS = clp.$(OBJEXT) giffunc.$(OBJEXT) \
+	gifread.$(OBJEXT) gifunopt.$(OBJEXT) merge.$(OBJEXT) \
+	optimize.$(OBJEXT) quantize.$(OBJEXT) support.$(OBJEXT) \
+	xform.$(OBJEXT) gifsicle.$(OBJEXT)
+gifsicle_OBJECTS = $(am_gifsicle_OBJECTS)
+am__DEPENDENCIES_1 = 
+am_gifview_OBJECTS = clp.$(OBJEXT) giffunc.$(OBJEXT) gifread.$(OBJEXT) \
+	gifx.$(OBJEXT) gifview.$(OBJEXT)
+gifview_OBJECTS = $(am_gifview_OBJECTS)
+am_win2rgb_OBJECTS = win2rgb.$(OBJEXT)
+win2rgb_OBJECTS = $(am_win2rgb_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(gifdiff_SOURCES) $(gifsicle_SOURCES) $(gifview_SOURCES)
+DIST_SOURCES = $(gifdiff_SOURCES) $(gifsicle_SOURCES) \
+	$(gifview_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /usr/src/gifsicle-1.52/missing --run aclocal-1.10
+AMTAR = ${SHELL} /usr/src/gifsicle-1.52/missing --run tar
+AUTOCONF = ${SHELL} /usr/src/gifsicle-1.52/missing --run autoconf
+AUTOHEADER = ${SHELL} /usr/src/gifsicle-1.52/missing --run autoheader
+AUTOMAKE = ${SHELL} /usr/src/gifsicle-1.52/missing --run automake-1.10
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CYGPATH_W = cygpath -w
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = /cygdrive/c/Rtools/bin/grep -E
+EXEEXT = .exe
+GIFWRITE_O = gifwrite.o
+GREP = /cygdrive/c/Rtools/bin/grep
+INSTALL = /cygdrive/c/R/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LDFLAGS = 
+LIBOBJS = 
+LIBS = 
+LTLIBOBJS = 
+MAKEINFO = ${SHELL} /usr/src/gifsicle-1.52/missing --run makeinfo
+MALLOC_O = fmalloc.o
+MKDIR_P = /cygdrive/c/Rtools/bin/mkdir -p
+OBJEXT = o
+OTHERMANS =  gifdiff.1
+OTHERPROGRAMS =  gifdiff$(EXEEXT) win2rgb$(EXEEXT)
+PACKAGE = gifsicle
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = 
+VERSION = 1.52
+XMKMF = 
+X_CFLAGS = 
+X_EXTRA_LIBS = 
+X_LIBS = 
+X_PRE_LIBS = 
+abs_builddir = /usr/src/gifsicle-1.52/src
+abs_srcdir = /usr/src/gifsicle-1.52/src
+abs_top_builddir = /usr/src/gifsicle-1.52
+abs_top_srcdir = /usr/src/gifsicle-1.52
+ac_ct_CC = gcc
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build_alias = 
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host_alias = 
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = $(SHELL) /usr/src/gifsicle-1.52/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+mandir = ${datarootdir}/man
+mkdir_p = /cygdrive/c/Rtools/bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target_alias = 
+top_builddir = ..
+top_srcdir = ..
+AUTOMAKE_OPTIONS = foreign check-news
+LDADD = fmalloc.o 
+gifsicle_LDADD = $(LDADD) gifwrite.o  -lgdi32 -lm
+gifview_LDADD = $(LDADD)   -lX11 
+win2rgb_LDADD = -lgdi32
+gifsicle_DEPENDENCIES = gifwrite.o fmalloc.o 
+gifview_DEPENDENCIES = fmalloc.o 
+gifdiff_DEPENDENCIES = fmalloc.o 
+gifsicle_SOURCES = clp.c \
+		giffunc.c gifread.c gifunopt.c \
+		gifsicle.h merge.c optimize.c quantize.c support.c xform.c \
+		gifsicle.c
+
+gifview_SOURCES = clp.c \
+		giffunc.c gifread.c gifx.c \
+		gifview.c
+
+gifdiff_SOURCES = clp.c \
+		giffunc.c gifread.c \
+		gifdiff.c
+
+win2rgb_SOURCES = win2rgb.c
+
+INCLUDES = $(X_CFLAGS) -I$(top_srcdir)/include
+EXTRA_DIST = dmalloc.h dmalloc.c fmalloc.c gifwrite.c ungifwrt.c \
+	Makefile.bcc Makefile.w32 win32cfg.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(bindir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(bindir)/$$f" || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
+	done
+
+clean-binPROGRAMS:
+	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
+gifdiff$(EXEEXT): $(gifdiff_OBJECTS) $(gifdiff_DEPENDENCIES) 
+	@rm -f gifdiff$(EXEEXT)
+	$(LINK) $(gifdiff_OBJECTS) $(gifdiff_LDADD) $(LIBS)
+gifsicle$(EXEEXT): $(gifsicle_OBJECTS) $(gifsicle_DEPENDENCIES) 
+	@rm -f gifsicle$(EXEEXT)
+	$(LINK) $(gifsicle_OBJECTS) $(gifsicle_LDADD) $(LIBS)
+gifview$(EXEEXT): $(gifview_OBJECTS) $(gifview_DEPENDENCIES) 
+	@rm -f gifview$(EXEEXT)
+	$(LINK) $(gifview_OBJECTS) $(gifview_LDADD) $(LIBS)
+win2rgb$(EXEEXT): $(win2rgb_OBJECTS) $(win2rgb_DEPENDENCIES) 
+	@rm -f win2rgb$(EXEEXT)
+	$(LINK) $(win2rgb_OBJECTS) $(win2rgb_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+include $(DEPDIR)/strerror.Po
+include ./$(DEPDIR)/clp.Po
+include ./$(DEPDIR)/gifdiff.Po
+include ./$(DEPDIR)/giffunc.Po
+include ./$(DEPDIR)/gifread.Po
+include ./$(DEPDIR)/gifsicle.Po
+include ./$(DEPDIR)/gifunopt.Po
+include ./$(DEPDIR)/gifview.Po
+include ./$(DEPDIR)/gifx.Po
+include ./$(DEPDIR)/merge.Po
+include ./$(DEPDIR)/optimize.Po
+include ./$(DEPDIR)/quantize.Po
+include ./$(DEPDIR)/support.Po
+include ./$(DEPDIR)/win2rgb.Po
+include ./$(DEPDIR)/xform.Po
+
+.c.o:
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+#	source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c $<
+
+.c.obj:
+	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+#	source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS)
+installdirs:
+	for dir in "$(DESTDIR)$(bindir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-binPROGRAMS clean-generic mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf $(DEPDIR) ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am: install-binPROGRAMS
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf $(DEPDIR) ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
+	clean-generic ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-binPROGRAMS \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-binPROGRAMS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Property changes on: src/Makefile.mingw
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/quantize.c
===================================================================
--- src/quantize.c	(revision 1)
+++ src/quantize.c	(working copy)
@@ -7,10 +7,14 @@
    as this notice is kept intact and this source code is made available. There
    is no warranty, express or implied. */
 
+
 #include <config.h>
 #include "gifsicle.h"
 #include <assert.h>
 #include <string.h>
+#ifdef _GET_WIN
+#include <math.h>
+#endif
 
 typedef struct Gif_Histogram {
   Gif_Color *c;
@@ -101,7 +105,7 @@
 {
   Gif_Histogram hist;
   Gif_Color *linear;
-  Gif_Color transparent_color;
+  Gif_Color transparent_color = {0, 0, 0, 0}; /* -Wall */
   unsigned long ntransparent = 0;
   unsigned long nbackground = 0;
   int x, y, i;
@@ -636,7 +640,7 @@
   /* find the closest color in the new colormap */
   {
     Gif_Color *col = new_cm->col;
-    int ncol = new_cm->ncol, i, found;
+    int ncol = new_cm->ncol, i, found = 0; /* -Wall */
     uint32_t min_dist = 0xFFFFFFFFU;
     
     if (new_cm_grayscale) {
@@ -1071,3 +1075,346 @@
   free_all_color_hash_items();
   Gif_DeleteArray(hash);
 }
+
+#ifdef _GET_WIN
+
+#define N_FIXED_COMP_R 6
+#define N_FIXED_COMP_G 8
+#define N_FIXED_COMP_B 5
+#define N_FIXED_COLORS (N_FIXED_COMP_R * N_FIXED_COMP_G * N_FIXED_COMP_B)
+#define FIXED_PAL_GAMMA 1
+
+static uint8_t fixed_pal_map_R[256];
+static uint8_t fixed_pal_map_G[256];
+static uint8_t fixed_pal_map_B[256];
+static uint8_t fixed_pal_map_GRAY[256];
+
+void
+make_component_map(uint8_t n, double gamma, uint8_t stride, uint8_t *map) 
+{
+  /* for each i in 0:255, set map[i] to the partial index for the
+     color component, given there are n levels of the component;
+     stride is how much to increase the partial index by for each
+     step in the color component map */
+
+  uint8_t lo, hi, icomp;
+  uint32_t i;
+  
+  icomp = 0;								
+  lo = 0;								
+  hi = pow(1 / (n - 1.0), gamma) * 255;	
+  for (i = 0; i < 256; ++i) {				
+    if (i > hi) {							
+      lo = hi;								
+      ++icomp;							
+      hi = pow((icomp + 1) / (n - 1.0), gamma) * 255; 
+    }									
+    if (i - lo < hi - i)						
+      map[i] = icomp * stride;
+    else								
+      map[i] = (icomp + 1) * stride;
+  } 
+}
+
+
+Gif_Stream*
+window_as_gfs(uint32_t *pix, uint16_t w, uint16_t h)
+{
+
+  /* create a gfs to hold the image contained in the pixel buffer dat
+     with given width and height.  A fixed colormap will is used. */
+
+  uint8_t iR, iG, iB, lo, hi, int_gray_lo, int_gray_hi, n_grays;
+  Gif_Stream *gfs;
+  Gif_Image *gfi;
+  uint32_t i, n;
+  int8_t gray_thresh;
+  uint8_t *gifdat;
+  Gif_Color *hist;
+
+  n = w * h;
+
+  gfs = Gif_NewStream();
+  gfi = Gif_NewImage();
+  
+  gfi->identifier = NULL;
+  gfi->comment = NULL;
+  
+  gfi->transparent = -1; /* no support for transparency in windows, yet */
+  
+  gfi->delay = 0;
+  gfi->disposal = GIF_DISPOSAL_NONE; /* FIXME: what should we use here? */
+  
+  gfi->left = 0;
+  gfi->top = 0;
+  
+  gfi->width = w;
+  gfi->height = h;
+  gfi->interlace = 0;
+  gfi->img = Gif_NewArray(uint8_t *, h + 1); /* FIXME: this is h+1 as elsewhere, rather than h; why? */
+  gifdat = gfi->image_data = Gif_NewArray(uint8_t, w * h);
+  for (i=0; i <= h; ++i)
+    gfi->img[i] = gfi->image_data + i * w;
+
+  gfi->free_image_data = Gif_DeleteArrayFunc;
+
+  gfi->compressed_len = 0;
+  gfi->compressed = NULL;
+  gfi->free_compressed = NULL;
+
+  gfi->user_data = NULL;
+  gfi->free_user_data = NULL;
+
+  gfi->refcount = 1;
+
+  /* create a map big enough to hold the colors for this rgb image */
+
+  gfi->local = Gif_NewFullColormap(n, n);
+  hist = gfi->local->col;
+
+  i = 0;
+  for (iR = 0; iR < N_FIXED_COMP_R; ++iR) {
+    for (iG = 0; iG < N_FIXED_COMP_G; ++iG) {
+      for (iB = 0; iB < N_FIXED_COMP_B; ++iB) {
+	hist[i].haspixel = 0;
+	hist[i].red =    ((pow(iR / (N_FIXED_COMP_R - 1.0), FIXED_PAL_GAMMA) * 255));
+	hist[i].green =  ((pow(iG / (N_FIXED_COMP_G - 1.0), FIXED_PAL_GAMMA) * 255));
+	hist[i].blue =   ((pow(iB / (N_FIXED_COMP_B - 1.0), FIXED_PAL_GAMMA) * 255));
+	++i;
+      }
+    }
+  }
+
+  /* fill the rest of the map with intermediate grayscale; i.e.  exclude black and white, which we already have */
+  for (/**/ ; i < 256; ++i) {
+    hist[i].haspixel = 0;
+    hist[i].red = hist[i].green = hist[i].blue = ((pow((i - N_FIXED_COLORS + 1) / (255 - N_FIXED_COLORS + 2.0), FIXED_PAL_GAMMA) * 255));
+  }
+
+  /* range of grays for which we have intermediate grays */
+
+  int_gray_lo = hist[N_FIXED_COLORS].red / 2;
+  int_gray_hi = (hist[255].red + 256) / 2;
+
+  /* the number of grays, including white and black */
+  n_grays = 256 - N_FIXED_COLORS + 2;
+
+  /* maximum intercomponent difference for which we'll map to gray */
+
+  gray_thresh = 256 / (n_grays);
+
+  /* make a map from colour component to partial palette index with
+     closest value */
+
+  make_component_map(N_FIXED_COMP_R,           FIXED_PAL_GAMMA, N_FIXED_COMP_G * N_FIXED_COMP_B, fixed_pal_map_R);
+  make_component_map(N_FIXED_COMP_G,           FIXED_PAL_GAMMA, N_FIXED_COMP_B,                  fixed_pal_map_G);
+  make_component_map(N_FIXED_COMP_B,           FIXED_PAL_GAMMA, 1,                               fixed_pal_map_B);
+  make_component_map(n_grays,                  FIXED_PAL_GAMMA, 1,                               fixed_pal_map_GRAY);
+
+  /* correct the indexes for the gray palette: map white to white;
+     leave black as black; map intermediates to entries at palette
+     end */
+
+  for (i = 0; i < 256; ++i) {
+    if (fixed_pal_map_GRAY[i] == n_grays - 1)
+      fixed_pal_map_GRAY[i] = N_FIXED_COLORS - 1;
+    else if (fixed_pal_map_GRAY[i] > 0)
+      fixed_pal_map_GRAY[i] += N_FIXED_COLORS - 1;
+  }
+
+  /* Map each pixel's colour to the reduced color, favouring grays where possible */
+
+  for (i = 0; i < n; ++i) {
+    iB = pix[i] & 0xff;
+    iG = (pix[i] >> 8) & 0xff;
+    iR = (pix[i] >> 16) & 0xff;
+    if (   (int) iB - (int) iG > gray_thresh 
+	|| (int) iG - (int) iB > gray_thresh 
+	|| (int) iB - (int) iR > gray_thresh 
+	|| (int) iR - (int) iB > gray_thresh
+	|| (int) iR - (int) iG > gray_thresh
+	|| (int) iG - (int) iR > gray_thresh
+	) {
+      /* this pixel is not approximately gray; use the regular map */
+      gifdat[i] = fixed_pal_map_R[iR] + fixed_pal_map_G[iG] + fixed_pal_map_B[iB];
+    } else {
+      /* this pixel is approximately gray; use the grayscale map */
+      gifdat[i] = fixed_pal_map_GRAY[((int) iR + iG + iB) / 3];
+    }
+  }
+
+  /* Fill in the fields of the Gif_Stream */
+
+  gfs->background = N_FIXED_COLORS - 1;
+  gfs->global = NULL;
+  gfs->screen_width = w;
+  gfs->screen_height = h;
+  gfs->loopcount = -1;
+  gfs->comment = NULL;
+  gfs->images = Gif_NewArray(Gif_Image *, 1);
+  gfs->images[0] = gfi;
+  gfs->nimages = 1;
+  gfs->imagescap = 1;
+  gfs->extensions = NULL;
+  gfs->errors = 0;
+  gfs->userflags = 0;
+  gfs->refcount = 1;
+
+  return(gfs);
+}
+
+#endif
+
+#ifdef _GET_RGB
+
+static  uint32_t *_rgb_pixels;
+
+static int
+pixval_sort_compare(const void *va, const void *vb)
+{
+  return _rgb_pixels [*(unsigned *) va] - _rgb_pixels [*(unsigned *) vb];
+}
+
+Gif_Stream*
+rgb_as_gfs(FILE *f, char *filename, Gif_Colormap *(*adapt_func)(Gif_Color *, int, int))
+{
+
+  /* create a Gif_Stream from a .rgb file 
+
+     After the header, which has already been read, the .rgb file looks like this:
+
+     unsigned short width;
+     unsigned short height;
+     unsigned int pixels[];
+
+     with pixels in 0xAARRGGBB format.
+  */
+
+  Gif_Stream *gfs;
+  Gif_Image *gfi;
+  uint32_t i, j, k, n, n_unique;
+  uint16_t w, h;
+  int8_t gray_thresh;
+  uint32_t *rgb_index;
+  uint8_t *gifdat;
+  Gif_Color *hist, *save_hist;
+  Gif_Colormap *src_map, *save_src_map;
+  color_hash_item **src_hash;
+  uint32_t *new_color_index;
+
+  if (1 != fread(&w, sizeof(w), 1, f) ||
+      1 != fread(&h, sizeof(h), 1, f) ||
+      ! (_rgb_pixels = Gif_NewArray(uint32_t, n = w * (uint32_t) h)) ||
+      1 != fread(_rgb_pixels, n * sizeof(uint32_t), 1, f))
+    error("%s: couldn't read RGB file; contents corrupt or out of memory", filename);
+
+  gfs = Gif_NewStream();
+  gfi = Gif_NewImage();
+  
+  gfi->identifier = NULL;
+  gfi->comment = NULL;
+  
+  gfi->transparent = -1; /* no support for transparency in rgb files, yet */
+  
+  gfi->delay = 0;
+  gfi->disposal = GIF_DISPOSAL_NONE; /* FIXME: what should we use here? */
+  
+  gfi->left = 0;
+  gfi->top = 0;
+  
+  gfi->width = w;
+  gfi->height = h;
+  gfi->interlace = 0;
+  gfi->img = Gif_NewArray(uint8_t *, h + 1); /* FIXME: this is h+1 as elsewhere, rather than h; why? */
+  gifdat = gfi->image_data = Gif_NewArray(uint8_t, n);
+  for (i=0; i <= h; ++i)
+    gfi->img[i] = gfi->image_data + i * w;
+
+  gfi->free_image_data = Gif_DeleteArrayFunc;
+
+  gfi->compressed_len = 0;
+  gfi->compressed = NULL;
+  gfi->free_compressed = NULL;
+
+  gfi->user_data = NULL;
+  gfi->free_user_data = NULL;
+
+  gfi->refcount = 1;
+
+  /* sort the image pixels and then create a histogram */
+
+  rgb_index = Gif_NewArray(uint32_t, n);
+
+  for (i = 0; i < n; ++i)
+    rgb_index[i] = i;
+
+  qsort(rgb_index, n, sizeof(uint32_t), pixval_sort_compare);
+
+  /* count the number of different pixel values */
+
+  for (i = 1, n_unique = 1; i < n; ++i)
+    if (_rgb_pixels[rgb_index[i]] != _rgb_pixels[rgb_index[i-1]])
+      ++n_unique;
+
+  src_map = Gif_NewFullColormap(n_unique, n_unique);
+  hist = src_map->col;
+
+  /* fill in the histogram */
+
+  for (i = 0, j = 0; i < n; ++j) {
+    /* invariant: rgb_index[i] is the index of a pixel whose color we haven't seen yet */
+    hist[j].haspixel = 1;
+    hist[j].red = (_rgb_pixels[rgb_index[i]] >> 16) & 0xff;
+    hist[j].green = (_rgb_pixels[rgb_index[i]] >> 8) & 0xff;
+    hist[j].blue = _rgb_pixels[rgb_index[i]] & 0xff;
+    /* count remaining pixels of the same color */
+    for (k = i++; i < n && _rgb_pixels[rgb_index[i]] == _rgb_pixels[rgb_index[i-1]]; ++i);
+    hist[j].pixel = i - k;
+  }
+  
+  /* save a copy of the histogram, since it gets altered by adapt_func */
+
+  save_src_map = Gif_NewFullColormap(n_unique, n_unique);
+  memcpy (save_src_map->col, src_map->col, n_unique * sizeof(Gif_Color));
+
+  /* create a reduced colormap */
+
+  gfi->local = (*adapt_func) (src_map->col, n_unique, 256);
+
+  /* for each color in the original hash, find its new color */
+  src_hash = new_color_hash();
+  new_color_index = Gif_NewArray(uint32_t, n_unique);
+
+  save_hist = save_src_map->col;
+  for (i = 0; i < n_unique; ++i)
+    new_color_index[i] = hash_color(save_hist[i].red, save_hist[i].green, save_hist[i].blue, src_hash, gfi->local);
+
+  /* Map each pixel's colour to the reduced color; we do this by going through the
+     source histogram, mapping the correct number of pixels back through the inverse
+     of the permutation that sorted them */
+
+  for (i = 0, j = 0; j < n_unique; ++j) {
+    for (k = save_hist[j].pixel; k > 0; --k)
+      gifdat[rgb_index[i++]] = new_color_index[j];
+  }
+  /* Fill in the fields of the Gif_Stream */
+
+  gfs->background = 0; // FIXME?
+  gfs->global = NULL;
+  gfs->screen_width = w;
+  gfs->screen_height = h;
+  gfs->loopcount = -1;
+  gfs->comment = NULL;
+  gfs->images = Gif_NewArray(Gif_Image *, 1);
+  gfs->images[0] = gfi;
+  gfs->nimages = 1;
+  gfs->imagescap = 1;
+  gfs->extensions = NULL;
+  gfs->errors = 0;
+  gfs->userflags = 0;
+  gfs->refcount = 1;
+
+  return(gfs);
+}
+
+#endif /* _GET_RGB */
Index: src/Makefile.in
===================================================================
--- src/Makefile.in	(revision 1)
+++ src/Makefile.in	(working copy)
@@ -30,8 +30,8 @@
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-bin_PROGRAMS = gifsicle$(EXEEXT) @OTHERPROGRAMS@
-EXTRA_PROGRAMS = gifview$(EXEEXT) gifdiff$(EXEEXT)
+bin_PROGRAMS = gifsicle$(EXEEXT) @OTHERPROGRAMS@ win2rgb$(EXEEXT)
+EXTRA_PROGRAMS = gifview$(EXEEXT) gifdiff$(EXEEXT) win2rgb$(EXEEXT)
 subdir = src
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in strerror.c
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
@@ -57,6 +57,8 @@
 am_gifview_OBJECTS = clp.$(OBJEXT) giffunc.$(OBJEXT) gifread.$(OBJEXT) \
 	gifx.$(OBJEXT) gifview.$(OBJEXT)
 gifview_OBJECTS = $(am_gifview_OBJECTS)
+am_win2rgb_OBJECTS = win2rgb.$(OBJEXT)
+win2rgb_OBJECTS = $(am_win2rgb_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(top_builddir)@am__isrc@
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
@@ -64,9 +66,10 @@
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(gifdiff_SOURCES) $(gifsicle_SOURCES) $(gifview_SOURCES)
+SOURCES = $(gifdiff_SOURCES) $(gifsicle_SOURCES) $(gifview_SOURCES) \
+	$(win2rgb_SOURCES)
 DIST_SOURCES = $(gifdiff_SOURCES) $(gifsicle_SOURCES) \
-	$(gifview_SOURCES)
+	$(gifview_SOURCES) $(win2rgb_SOURCES)
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -165,11 +168,13 @@
 top_srcdir = @top_srcdir@
 AUTOMAKE_OPTIONS = foreign check-news
 LDADD = @MALLOC_O@ @LIBOBJS@
-gifsicle_LDADD = $(LDADD) @GIFWRITE_O@
+gifsicle_LDADD = $(LDADD) @GIFWRITE_O@ @X_LIBS@ @X_PRE_LIBS@ -lX11 @X_EXTRA_LIBS@ -lm
 gifview_LDADD = $(LDADD) @X_LIBS@ @X_PRE_LIBS@ -lX11 @X_EXTRA_LIBS@
+win2rgb_LDADD = $(LDADD) @X_LIBS@ @X_PRE_LIBS@ -lX11 @X_EXTRA_LIBS@ 
 gifsicle_DEPENDENCIES = @GIFWRITE_O@ @MALLOC_O@ @LIBOBJS@
 gifview_DEPENDENCIES = @MALLOC_O@ @LIBOBJS@
 gifdiff_DEPENDENCIES = @MALLOC_O@ @LIBOBJS@
+win2rgb_DEPENDENCIES = @MALLOC_O@ @LIBOBJS@
 gifsicle_SOURCES = clp.c \
 		giffunc.c gifread.c gifunopt.c \
 		gifsicle.h merge.c optimize.c quantize.c support.c xform.c \
@@ -183,6 +188,7 @@
 		giffunc.c gifread.c \
 		gifdiff.c
 
+win2rgb_SOURCES = win2rgb.c
 INCLUDES = $(X_CFLAGS) -I$(top_srcdir)/include
 EXTRA_DIST = dmalloc.h dmalloc.c fmalloc.c gifwrite.c ungifwrt.c \
 	Makefile.bcc Makefile.w32 win32cfg.h
@@ -252,6 +258,9 @@
 gifview$(EXEEXT): $(gifview_OBJECTS) $(gifview_DEPENDENCIES) 
 	@rm -f gifview$(EXEEXT)
 	$(LINK) $(gifview_OBJECTS) $(gifview_LDADD) $(LIBS)
+win2rgb$(EXEEXT): $(win2rgb_OBJECTS) $(win2rgb_DEPENDENCIES) 
+	@rm -f win2rgb$(EXEEXT)
+	$(LINK) $(win2rgb_OBJECTS) $(win2rgb_LDADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -272,6 +281,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/optimize.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/quantize.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/support.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win2rgb.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xform.Po@am__quote@
 
 .c.o:
Index: src/gifwrite.c
===================================================================
--- src/gifwrite.c	(revision 1)
+++ src/gifwrite.c	(working copy)
@@ -172,7 +172,7 @@
   
   Gif_Node *work_node;
   Gif_Node *next_node;
-  Gif_Code next_code;
+  Gif_Code next_code = 0; /* -Wall */
   Gif_Code output_code;
   Gif_Code clear_code;
   Gif_Code eoi_code;
Index: src/gifsicle.c
===================================================================
--- src/gifsicle.c	(revision 1)
+++ src/gifsicle.c	(working copy)
@@ -24,7 +24,6 @@
 # include <io.h>
 #endif
 
-
 Gt_Frame def_frame;
 
 Gt_Frameset *frames = 0;
@@ -729,7 +728,336 @@
     output_frames();
 }
 
+#ifdef _GET_WIN
 
+void
+input_window(Win_ID win)
+{
+  char win_name[64];
+
+#  ifdef _WIN32
+  HWND hwnd_plot;
+  PBITMAPINFO bmhdr;
+  HDC bmdc;
+  HDC hdcr;
+  HDC hdc;
+  HBITMAP bmh;
+  BITMAP bm;
+  RECT r;
+#  else
+  Display *disp;
+  XImage *img;
+  XWindowAttributes attr;
+#  endif
+  Gif_Stream *gfs;
+  int saved_next_frame = next_frame;
+  Gt_Frame old_def_frame;
+  uint32_t w, h, *pix;
+  int i;
+  
+  input = 0;
+  frames_done = 0;
+  next_frame = 0;
+  next_input = 0;
+  if (next_output)
+    combine_output_options();
+  files_given++;  /* the window is effectively a gif file */
+
+  /* Get the contents of a window into a new buffer.  Pixels are
+     stored as unsigned 32 bit integers of the form 0xAARRGGBB with AA
+     undefined.  Pixels are stored row-by-row with no padding.  Record
+     the image width and height. */
+
+#  ifdef _WIN32
+  if (win == 0)
+    if (!(win = GetDesktopWindow()))
+      error ("could not open desktop window");
+  if (!GetWindowRect((HWND) win, &r))
+    error("unable to get rectangle for window %xl", (unsigned int) win);
+  w = r.right - r.left;
+  h = r.bottom - r.top;
+  bmhdr = calloc(sizeof(BITMAPINFO) + 256 * sizeof(RGBQUAD), 1);
+  bmhdr->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+  bmhdr->bmiHeader.biPlanes = 1;
+  bmhdr->bmiHeader.biBitCount = 32;
+  bmhdr->bmiHeader.biCompression = BI_RGB;
+  bmhdr->bmiHeader.biSizeImage = 0;
+  bmhdr->bmiHeader.biXPelsPerMeter = 0;
+  bmhdr->bmiHeader.biYPelsPerMeter = 0;
+  bmhdr->bmiHeader.biClrUsed = 256;
+  bmhdr->bmiHeader.biWidth = w;
+  bmhdr->bmiHeader.biHeight = -h;
+  if (!(hdcr = GetDC (NULL)))
+    error("unable to get DC for root window");
+  if (!(bmdc = CreateCompatibleDC (hdcr)))
+    error("unable to create compatible DC for bitmap");
+  if (!(bmh = CreateDIBSection (hdc, bmhdr, DIB_RGB_COLORS, (void **) &pix, NULL, 0)))
+    error("unable to create device independent bitmap section");
+  if (!SelectObject (bmdc, bmh))
+    error("unable to select bitmap to its DC");
+  if (! BitBlt( bmdc,
+	  0, 0,
+	  w, h,
+	  hdcr,
+	  r.left, r.top,
+	  SRCCOPY
+		))
+    error("unable to copy window data to bitmap");
+#  else
+
+  if (!(disp = XOpenDisplay(NULL)))
+    error("could not open X display");
+
+  if (win == 0)
+    if (!(win = RootWindow(disp, 0)))
+      error ("could not open root window on display");
+
+  if (!(XGetWindowAttributes(disp, win, &attr)))
+    error("could not get attributes for window %xl", (unsigned int) win);
+
+  if (!(img = XGetImage(disp, win, 0, 0, w = attr.width, h = attr.height, 0xffffffffUL, ZPixmap)))
+    error("could not get window %xl data as Ximage", (unsigned int) win);
+
+  if (img->depth < 24)
+    error("lazy programmer: can't handle windows with bit depth %d", img->depth);
+
+  pix = (uint32_t *) img->data;
+#  endif
+
+  if (infoing == 1)
+    set_mode(INFOING);
+
+  sprintf(win_name, "(window) %xl", (unsigned int) win);
+  input_name = win_name;
+
+  if (verbosing)
+    verbose_open('<', win_name);
+  
+  gfs = window_as_gfs(pix, w, h);
+
+  input = gfs;
+  
+  /* Processing when we've got a new input frame */
+  if (mode == BLANK_MODE)
+    set_mode(MERGING);
+  
+  if (active_output_data.output_name == 0) {
+    /* Don't override explicit output names.
+       This code works 'cause output_name is reset to 0 after each output. */
+    if (mode == BATCHING)
+      active_output_data.output_name = input_name;
+    else if (mode == EXPLODING) {
+      /* Explode into current directory. */
+      const char *explode_name = (input_name ? input_name : "#stdin#");
+      const char *slash = strrchr(explode_name, PATHNAME_SEPARATOR);
+      if (slash)
+	active_output_data.output_name = slash + 1;
+      else
+	active_output_data.output_name = explode_name;
+    }
+  }
+  
+  /* This code rather sucks. Here's the problem: Since we consider options
+     strictly sequentially, one at a time, we can't tell the difference
+     between these:
+     
+     --name=X g.gif             h.gif   // name on g.gif #0
+     --name=X g.gif          #2 h.gif   // name on g.gif #2
+              g.gif --name=X #2 h.gif   // name on g.gif #2
+              g.gif --name=X    h.gif   // name on h.gif #0 !!!
+      
+     Here's the solution. Mark when we CHANGE an option. After processing
+     an input GIF, mark all the options as 'unchanged' -- but leave the
+     VALUES as is. Then when we read the next frame, CLEAR the unchanged
+     options. So it's like so: (* means changed, . means not.)
+     
+     [-.] --name=X [X*] g.gif [X.] #2 [-.] h.gif   == name on g.gif #2
+     [-.] g.gif [-.] --name=X [X*] #2 [-.] h.gif  == name on g.gif #2
+     [-.] --name=X [X*] g.gif [X.|-.] h.gif  == name on g.gif #0
+     [-.] g.gif [-.] --name=X [X*] h.gif  == name on h.gif #0 */
+  
+  /* Clear old options from the last input stream */
+  if (!CHANGED(saved_next_frame, CH_NAME))
+    def_frame.name = 0;
+  if (!CHANGED(saved_next_frame, CH_COMMENT))
+    def_frame.comment = 0;
+  if (!CHANGED(saved_next_frame, CH_EXTENSION))
+    def_frame.extensions = 0;
+  def_frame.input_filename = input_name;
+  
+  old_def_frame = def_frame;
+  first_input_frame = frames->count;
+  if (gfs->nimages > 1)
+    def_frame.position_is_offset = 1;
+  for (i = 0; i < gfs->nimages; i++)
+    add_frame(frames, -1, gfs, gfs->images[i]);
+  def_frame = old_def_frame;
+  
+  apply_color_transforms(input_transforms, gfs);
+  gfs->refcount++;
+
+#ifdef _WIN32
+  DeleteObject(bmh);
+  ReleaseDC(NULL, bmdc);
+  ReleaseDC(NULL, hdcr);
+  free(bmhdr);
+#else
+  XDestroyImage(img);
+  XCloseDisplay(disp);
+#endif
+}
+
+#endif
+
+#ifdef _GET_RGB
+static char _rgb_header[] = 
+  "RGB file: after this header, contents are:\n"	\
+  "unsigned short width;\n"				\
+  "unsigned short height;\n"				\
+  "unsigned int []pixels;\n"				\
+  "Pixels are integers of the form 0xAARRGGBB\n"	\
+  "and stored row-by-row from top to bottom.\n";
+
+#define _RGB_HEADER_SIZE (sizeof(_rgb_header) - 1)
+
+void
+input_rgb(const char *name)
+{
+  static char *component_namebuf = 0;
+  FILE *f;
+  Gif_Stream *gfs;
+  int i;
+  int saved_next_frame = next_frame;
+  int componentno = 0;
+  const char *main_name = 0;
+  Gt_Frame old_def_frame;
+  char header_buff[_RGB_HEADER_SIZE + 1];
+  unsigned short width, height;
+  Gif_Colormap *(*adapt_func)(Gif_Color *, int, int);
+  
+  input = 0;
+  input_name = name;
+  frames_done = 0;
+  next_frame = 0;
+  next_input = 0;
+  if (next_output)
+    combine_output_options();
+  files_given++;
+
+  if (infoing == 1)
+    set_mode(INFOING);
+
+  f = open_giffile(name);
+  if (!f)
+    return;
+
+  main_name = name;
+
+ retry_file:
+  /* read file */
+
+  gifread_error_count = 0;
+  if (1 != fread(header_buff, _RGB_HEADER_SIZE, 1, f) ||
+      strncmp(header_buff, _rgb_header, _RGB_HEADER_SIZE))
+    error("%s: not an RGB file", name);
+
+  /* use the current colormap algorithm to reduce the colormap */
+
+  switch (active_output_data.colormap_algorithm) {
+  case COLORMAP_DIVERSITY:
+    adapt_func = &colormap_flat_diversity;
+    break;
+      
+  case COLORMAP_BLEND_DIVERSITY:
+    adapt_func = &colormap_blend_diversity;
+    break;
+      
+  case COLORMAP_MEDIAN_CUT:
+    adapt_func = &colormap_median_cut;
+    break;
+      
+  default:
+    fatal_error("can't happen");
+      
+  }
+
+  gfs = rgb_as_gfs (f, (char *)name, adapt_func);
+
+  input = gfs;
+  
+  /* Processing when we've got a new input frame */
+  if (mode == BLANK_MODE)
+    set_mode(MERGING);
+  
+  if (active_output_data.output_name == 0) {
+    /* Don't override explicit output names.
+       This code works 'cause output_name is reset to 0 after each output. */
+    if (mode == BATCHING)
+      active_output_data.output_name = input_name;
+    else if (mode == EXPLODING) {
+      /* Explode into current directory. */
+      const char *explode_name = (input_name ? input_name : "#stdin#");
+      const char *slash = strrchr(explode_name, PATHNAME_SEPARATOR);
+      if (slash)
+	active_output_data.output_name = slash + 1;
+      else
+	active_output_data.output_name = explode_name;
+    }
+  }
+  
+  /* This code rather sucks. Here's the problem: Since we consider options
+     strictly sequentially, one at a time, we can't tell the difference
+     between these:
+     
+     --name=X g.gif             h.gif   // name on g.gif #0
+     --name=X g.gif          #2 h.gif   // name on g.gif #2
+              g.gif --name=X #2 h.gif   // name on g.gif #2
+              g.gif --name=X    h.gif   // name on h.gif #0 !!!
+      
+     Here's the solution. Mark when we CHANGE an option. After processing
+     an input GIF, mark all the options as 'unchanged' -- but leave the
+     VALUES as is. Then when we read the next frame, CLEAR the unchanged
+     options. So it's like so: (* means changed, . means not.)
+     
+     [-.] --name=X [X*] g.gif [X.] #2 [-.] h.gif   == name on g.gif #2
+     [-.] g.gif [-.] --name=X [X*] #2 [-.] h.gif  == name on g.gif #2
+     [-.] --name=X [X*] g.gif [X.|-.] h.gif  == name on g.gif #0
+     [-.] g.gif [-.] --name=X [X*] h.gif  == name on h.gif #0 */
+  
+  /* Clear old options from the last input stream */
+  if (!CHANGED(saved_next_frame, CH_NAME))
+    def_frame.name = 0;
+  if (!CHANGED(saved_next_frame, CH_COMMENT))
+    def_frame.comment = 0;
+  if (!CHANGED(saved_next_frame, CH_EXTENSION))
+    def_frame.extensions = 0;
+  def_frame.input_filename = input_name;
+  
+  old_def_frame = def_frame;
+  first_input_frame = frames->count;
+  if (gfs->nimages > 1)
+    def_frame.position_is_offset = 1;
+  for (i = 0; i < gfs->nimages; i++)
+    add_frame(frames, -1, gfs, gfs->images[i]);
+  def_frame = old_def_frame;
+  
+  if (unoptimizing)
+    if (!Gif_Unoptimize(gfs)) {
+      static int context = 0;
+      warning("'%s' is too complex to unoptimize", name);
+      if (!context) {
+	warncontext("(The reason was local color tables or complex transparency.");
+	warncontext("Try running the GIF through 'gifsicle --colors=255' first.)");
+      }
+      context = 1;
+    }
+  
+  apply_color_transforms(input_transforms, gfs);
+  gfs->refcount++;
+}
+
+#endif
+
 /*****
  * colormap stuff
  **/
@@ -1787,8 +2115,25 @@
       
      case Clp_NotOption:
       if (clp->vstr[0] != '#' || !frame_argument(clp, clp->vstr)) {
+#ifdef _GET_WIN
+	Win_ID win;
+	char c;
+	assert(sizeof(Win_ID) <= sizeof(unsigned long) && "Win_ID needs a different format conversion than %lx");
+
 	input_done();
-	input_stream(clp->vstr);
+	/* test for a window ID; i.e. a hex number filling the string */
+	if (1 == sscanf(clp->vstr, "%lx%c", &win, &c))
+	  input_window(win);
+	else 
+#endif
+#ifdef _GET_RGB
+	  /* test for an ".rgb" file */
+	  if (strlen(clp->vstr) >= 4 && 0 == strcasecmp(clp->vstr + strlen(clp->vstr) - 4, ".rgb"))
+	    input_rgb(clp->vstr);
+	  else
+#endif
+	  
+	  input_stream(clp->vstr);
       }
       break;
       
Index: src/Makefile.am
===================================================================
--- src/Makefile.am	(revision 1)
+++ src/Makefile.am	(working copy)
@@ -1,16 +1,18 @@
 ## Process this file with automake to produce Makefile.in
 AUTOMAKE_OPTIONS = foreign check-news
 
-bin_PROGRAMS = gifsicle @OTHERPROGRAMS@
-EXTRA_PROGRAMS = gifview gifdiff
+bin_PROGRAMS = gifsicle @OTHERPROGRAMS@ win2rgb
+EXTRA_PROGRAMS = gifview gifdiff win2rgb
 
 LDADD = @MALLOC_O@ @LIBOBJS@
-gifsicle_LDADD = $(LDADD) @GIFWRITE_O@
+gifsicle_LDADD = $(LDADD) @GIFWRITE_O@ @X_LIBS@ @X_PRE_LIBS@ -lX11 @X_EXTRA_LIBS@ -lm
 gifview_LDADD = $(LDADD) @X_LIBS@ @X_PRE_LIBS@ -lX11 @X_EXTRA_LIBS@
+win2rgb_LDADD = $(LDADD) @X_LIBS@ @X_PRE_LIBS@ -lX11 @X_EXTRA_LIBS@ 
 
 gifsicle_DEPENDENCIES = @GIFWRITE_O@ @MALLOC_O@ @LIBOBJS@
 gifview_DEPENDENCIES = @MALLOC_O@ @LIBOBJS@
 gifdiff_DEPENDENCIES = @MALLOC_O@ @LIBOBJS@
+win2rgb_DEPENDENCIES =  @MALLOC_O@ @LIBOBJS@
 
 gifsicle_SOURCES = clp.c \
 		giffunc.c gifread.c gifunopt.c \
@@ -25,6 +27,8 @@
 		giffunc.c gifread.c \
 		gifdiff.c
 
+win2rgb_SOURCES = win2rgb.c
+
 INCLUDES = $(X_CFLAGS) -I$(top_srcdir)/include
 
 EXTRA_DIST = dmalloc.h dmalloc.c fmalloc.c gifwrite.c ungifwrt.c \
Index: src/gifsicle.h
===================================================================
--- src/gifsicle.h	(revision 1)
+++ src/gifsicle.h	(working copy)
@@ -15,6 +15,9 @@
 #define NORETURN
 #endif
 
+#define _GET_WIN
+#define _GET_RGB
+
 typedef struct Gt_Frameset Gt_Frameset;
 typedef struct Gt_Crop Gt_Crop;
 typedef struct Gt_ColorTransform Gt_ColorTransform;
@@ -221,6 +224,14 @@
 	 color_hash_item **, uint32_t *);
 void	colormap_stream(Gif_Stream *, Gif_Colormap *, colormap_image_func);
 
+#ifdef _GET_WIN
+Gif_Stream* window_as_gfs(uint32_t *pix, uint16_t w, uint16_t h);
+#endif
+
+#ifdef _GET_RGB
+Gif_Stream* rgb_as_gfs(FILE *f, char *filename, Gif_Colormap *(*adapt_func)(Gif_Color *, int, int));
+#endif
+
 /*****
  * parsing stuff
  **/
@@ -248,6 +259,19 @@
 extern const char *input_name;
 
 void		input_stream(const char *);
+
+#ifdef _GET_WIN
+#  if defined (_WIN32) 
+#    include <windows.h>
+     typedef HWND Win_ID;
+#  else
+#    include <X11/Xlib.h>
+#    include <X11/Xutil.h>
+     typedef Window Win_ID;
+#  endif
+void            input_window(Win_ID win);
+#endif
+
 void		input_done(void);
 void		output_frames(void);
 
Index: README
===================================================================
--- README	(revision 1)
+++ README	(working copy)
@@ -1,6 +1,25 @@
-GIFSICLE 1.52
+GIFSICLE 1.52 (patched)
 =============
 
+NOTE: this is a patched version of Gifsicle 1.52.  It adds the ability
+to capture a full-color window into a GIF, using a 6-8-5 (R-G-B)
+palette with 16 additional intermediate grayscale values.  The window
+is specified by giving a hexadecimal ID (beginning with "0x") as a
+filename, with 0x0 representing the root or Desktop window.
+
+It also adds the ability to read .rgb files, which are raw 32-bit
+per pixel files with a header and size information at the start.
+A program can quickly and easily dump e.g. window contents to such .rgb
+files, as the demo program win2rgb does
+
+e.g.
+
+    gifsicle 0x00A1e300 > mywin.gif
+    gifsicle 0x0 > desktop.gif
+    gifsicle myfile.rgb > myfile.gif
+
+The patch is by John Brzustowski jbrzusto AT fastmail DOT fm. 
+
 ABOUT GIFSICLE
 --------------
    Gifsicle twaddles GIF image files in a variety of ways. It is better
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 1)
+++ Makefile.am	(working copy)
@@ -17,6 +17,9 @@
 gifview:
 	@cd src && $(MAKE) gifview
 
+win2rgb:
+	@cd src && $(MAKE) win2rgb
+
 srclinks:
 	cd $(top_srcdir); sh ./sourcecheckout.sh
 
