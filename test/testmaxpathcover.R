## test the maximum weight path cover routine by generating a DAG
## with random edge weights.
## The vertices are random points in the unit square, and the
## edge weights are random, except that weights of edges going
## from right to left are all zero
##
## A maximum path cover is generated by calling both
## max_path_cover and bipartite_matching.  The difference
## is internal: the former deals intelligently with sparse
## graphs (even though its wrapper routine accepts the same
## full matrix as does bipartite_matching).
##
## If compiled with -DRADR_DEBUG, both library functions check their
## answers by verifying dual feasibility and complementary slackness.

dyn.load(paste("plugins/maxpathcover", .Platform$dynlib.ext, sep=""))
dyn.load(paste("plugins/maxmatch", .Platform$dynlib.ext, sep=""))
doit <- function(SIZE, frac = 9/10, graph=FALSE) {
  c1 <<- complex(r=runif(SIZE), i=runif(SIZE))
  c1<<-c1[order(Re(c1))]
  m <<- matrix(as.integer(runif(SIZE^2) * 1000000), SIZE, SIZE)
  m[Re(c1)[row(m)] >= Re(c1)[col(m)]] <<- as.integer(0)
  ## thin out the graph
  m[ceiling(runif(floor(SIZE^2*frac)) * (SIZE^2))] <<- 0
  print(m)
  pred <<- integer(SIZE)
  succ <<- integer(SIZE)
  print("Using max_path_cover")
  tw <<- .Call("max_path_cover", m, pred, succ)
  print("Using bipartite_matching")
  post <<- .Call("bipartite_matching", m)
  if (any(is.na(succ) != is.na(post)))
    print("*** non-matched nodes differ")
  if (any(succ[!is.na(succ)] != post[!is.na(post)]))
    print("*** matching of nodes differs")
  print(paste("Max weight by maxpathcover: ", tw))
  print(paste("Max weight by maxmatch:     ", sum(m[cbind((1:SIZE)[!is.na(post)], post[!is.na(post)])])))
  if (graph) {
    in.cover <<- rep(1, SIZE)
    in.cover[succ] <<- 2
    in.cover[pred] <<- 2

    plot(Re(c1), Im(c1), col=in.cover, xlim=c(0,1), ylim=c(0,1))
    for (i in 1:SIZE)
      if (in.cover[i] == 1)
        for (j in 1:SIZE)
          if (m[i, j] > 0) 
            lines(c(Re(c1)[i], Re(c1)[j]), c(Im(c1)[i], Im(c1)[j]), col="black", lty="dashed")
    for (i in 1:SIZE) {
      if (!is.na(succ[i]))
        lines(c(Re(c1)[i], Re(c1)[succ[i]]), c(Im(c1)[i], Im(c1)[succ[i]]), col="red")
    }
    for (i in 1:SIZE) {
      if (!is.na(post[i]))
        lines(c(Re(c1)[i], Re(c1)[post[i]]), c(Im(c1)[i], Im(c1)[post[i]]), col="blue", lty="dotted")
    }
  }
}

doit(20, graph=TRUE)
